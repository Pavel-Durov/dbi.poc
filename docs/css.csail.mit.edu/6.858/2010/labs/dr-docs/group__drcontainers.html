<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>DynamoRIO API: Container Data Structures</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
<link rel="shortcut icon" type="image/x-icon" href="favicon.ico" />
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="contents">
<h1>Container Data Structures</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#g2cde78f27c3374749c462a5d58a5e38e">hash_type_t</a> { <br>
&nbsp;&nbsp;<a class="el" href="group__drcontainers.html#gg2cde78f27c3374749c462a5d58a5e38e7e83c8ad190fd19419c301ace3bcbe2e">HASH_INTPTR</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__drcontainers.html#gg2cde78f27c3374749c462a5d58a5e38e3a57810af6552f1efcda7a6abddbe92a">HASH_STRING</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__drcontainers.html#gg2cde78f27c3374749c462a5d58a5e38ee0b0e4c68e2bab129d1d2a6ff43d44d4">HASH_STRING_NOCASE</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__drcontainers.html#gg2cde78f27c3374749c462a5d58a5e38ea90b8cffea02e8d64d001982ddb0c310">HASH_CUSTOM</a>
<br>
 }</td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#gb341e9839c6cbd89a5a442df73468f5f">stri_eq</a> (const char *s1, const char *s2)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#gf202d20209b04c9ea9fd0657f3cfccc6">hashtable_global_config</a> (void *(*alloc_func)(size_t), void(*free_func)(void *, size_t), void(*assert_fail_func)(const char *))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#g96d69f3a60f5ba9c75698649465be695">hashtable_init</a> (hashtable_t *table, uint num_bits, <a class="el" href="group__drcontainers.html#g2cde78f27c3374749c462a5d58a5e38e">hash_type_t</a> hashtype, bool str_dup)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#g307d17165381371418414308b3eed803">hashtable_init_ex</a> (hashtable_t *table, uint num_bits, <a class="el" href="group__drcontainers.html#g2cde78f27c3374749c462a5d58a5e38e">hash_type_t</a> hashtype, bool str_dup, bool synch, void(*free_payload_func)(void *), uint(*hash_key_func)(void *), bool(*cmp_key_func)(void *, void *))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#ga6af018f2bb18648861e76bc0fdec96e">hashtable_lookup</a> (hashtable_t *table, void *key)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#g9d898d532b4ce1111bdd8bac317c6849">hashtable_lookup_keep_locked</a> (hashtable_t *table, void *key)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#g42cb0b8a85c6b4cdba6ee7b984aeff25">hashtable_add</a> (hashtable_t *table, void *key, void *payload)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#g3d443ee70d3fd35d853b9697f999cbf7">hashtable_add_replace</a> (hashtable_t *table, void *key, void *payload)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#g8972b42e34447e229489ab120271dbfd">hashtable_remove</a> (hashtable_t *table, void *key)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#g9e402d49c64df6809c82483a8ddd6770">hashtable_delete</a> (hashtable_t *table)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#g98ba198cad4e146607e8a07db005b514">hashtable_lock</a> (hashtable_t *table)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#g8d7f9e88180c79d080113e2bec858dbf">hashtable_unlock</a> (hashtable_t *table)</td></tr>

</table>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="g2cde78f27c3374749c462a5d58a5e38e"></a><!-- doxytag: member="hashtable.h::hash_type_t" ref="g2cde78f27c3374749c462a5d58a5e38e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__drcontainers.html#g2cde78f27c3374749c462a5d58a5e38e">hash_type_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The type of hash key <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="gg2cde78f27c3374749c462a5d58a5e38e7e83c8ad190fd19419c301ace3bcbe2e"></a><!-- doxytag: member="HASH_INTPTR" ref="gg2cde78f27c3374749c462a5d58a5e38e7e83c8ad190fd19419c301ace3bcbe2e" args="" -->HASH_INTPTR</em>&nbsp;</td><td>
A pointer-sized integer or pointer </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg2cde78f27c3374749c462a5d58a5e38e3a57810af6552f1efcda7a6abddbe92a"></a><!-- doxytag: member="HASH_STRING" ref="gg2cde78f27c3374749c462a5d58a5e38e3a57810af6552f1efcda7a6abddbe92a" args="" -->HASH_STRING</em>&nbsp;</td><td>
A case-sensitive string </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg2cde78f27c3374749c462a5d58a5e38ee0b0e4c68e2bab129d1d2a6ff43d44d4"></a><!-- doxytag: member="HASH_STRING_NOCASE" ref="gg2cde78f27c3374749c462a5d58a5e38ee0b0e4c68e2bab129d1d2a6ff43d44d4" args="" -->HASH_STRING_NOCASE</em>&nbsp;</td><td>
A case-insensitive string </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg2cde78f27c3374749c462a5d58a5e38ea90b8cffea02e8d64d001982ddb0c310"></a><!-- doxytag: member="HASH_CUSTOM" ref="gg2cde78f27c3374749c462a5d58a5e38ea90b8cffea02e8d64d001982ddb0c310" args="" -->HASH_CUSTOM</em>&nbsp;</td><td>
A custom key (hash and cmp operations must be provided) </td></tr>
</table>
</dl>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g42cb0b8a85c6b4cdba6ee7b984aeff25"></a><!-- doxytag: member="hashtable.h::hashtable_add" ref="g42cb0b8a85c6b4cdba6ee7b984aeff25" args="(hashtable_t *table, void *key, void *payload)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hashtable_add           </td>
          <td>(</td>
          <td class="paramtype">hashtable_t *&nbsp;</td>
          <td class="paramname"> <em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>payload</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a new entry. Returns false if an entry for <code>key</code> already exists. <dl class="note" compact><dt><b>Note:</b></dt><dd>Never use NULL as a payload as that is used for a lookup failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g3d443ee70d3fd35d853b9697f999cbf7"></a><!-- doxytag: member="hashtable.h::hashtable_add_replace" ref="g3d443ee70d3fd35d853b9697f999cbf7" args="(hashtable_t *table, void *key, void *payload)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* hashtable_add_replace           </td>
          <td>(</td>
          <td class="paramtype">hashtable_t *&nbsp;</td>
          <td class="paramname"> <em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>payload</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a new entry, replacing an existing entry if any. <dl class="note" compact><dt><b>Note:</b></dt><dd>Never use NULL as a payload as that is used for a lookup failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g9e402d49c64df6809c82483a8ddd6770"></a><!-- doxytag: member="hashtable.h::hashtable_delete" ref="g9e402d49c64df6809c82483a8ddd6770" args="(hashtable_t *table)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hashtable_delete           </td>
          <td>(</td>
          <td class="paramtype">hashtable_t *&nbsp;</td>
          <td class="paramname"> <em>table</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destroys all storage for the table. If free_payload_func was specified calls it for each payload. 
</div>
</div><p>
<a class="anchor" name="gf202d20209b04c9ea9fd0657f3cfccc6"></a><!-- doxytag: member="hashtable.h::hashtable_global_config" ref="gf202d20209b04c9ea9fd0657f3cfccc6" args="(void *(*alloc_func)(size_t), void(*free_func)(void *, size_t), void(*assert_fail_func)(const char *))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hashtable_global_config           </td>
          <td>(</td>
          <td class="paramtype">void *(*)(size_t)&nbsp;</td>
          <td class="paramname"> <em>alloc_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *, size_t)&nbsp;</td>
          <td class="paramname"> <em>free_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(const char *)&nbsp;</td>
          <td class="paramname"> <em>assert_fail_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The hashtable has parametrized heap and assert routines for flexibility. This routine must be called BEFORE any other hashtable_ routine; else, the defaults will be used. 
</div>
</div><p>
<a class="anchor" name="g96d69f3a60f5ba9c75698649465be695"></a><!-- doxytag: member="hashtable.h::hashtable_init" ref="g96d69f3a60f5ba9c75698649465be695" args="(hashtable_t *table, uint num_bits, hash_type_t hashtype, bool str_dup)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hashtable_init           </td>
          <td>(</td>
          <td class="paramtype">hashtable_t *&nbsp;</td>
          <td class="paramname"> <em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>num_bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drcontainers.html#g2cde78f27c3374749c462a5d58a5e38e">hash_type_t</a>&nbsp;</td>
          <td class="paramname"> <em>hashtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>str_dup</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initializes a hashtable with the given size, hash type, and whether to duplicate string keys. All operations are synchronized by default. 
</div>
</div><p>
<a class="anchor" name="g307d17165381371418414308b3eed803"></a><!-- doxytag: member="hashtable.h::hashtable_init_ex" ref="g307d17165381371418414308b3eed803" args="(hashtable_t *table, uint num_bits, hash_type_t hashtype, bool str_dup, bool synch, void(*free_payload_func)(void *), uint(*hash_key_func)(void *), bool(*cmp_key_func)(void *, void *))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hashtable_init_ex           </td>
          <td>(</td>
          <td class="paramtype">hashtable_t *&nbsp;</td>
          <td class="paramname"> <em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>num_bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drcontainers.html#g2cde78f27c3374749c462a5d58a5e38e">hash_type_t</a>&nbsp;</td>
          <td class="paramname"> <em>hashtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>str_dup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>synch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&nbsp;</td>
          <td class="paramname"> <em>free_payload_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint(*)(void *)&nbsp;</td>
          <td class="paramname"> <em>hash_key_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(void *, void *)&nbsp;</td>
          <td class="paramname"> <em>cmp_key_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initializes a hashtable with the given size, hash type, whether to duplicate string keys, whether to synchronize each operation, a callback for freeing each payload, a callback for hashing a key, and a callback for comparing two keys. Even when <code>synch</code> is false, the hashtable's lock is initialized and can be used via hashtable_lock and hashtable_unlock, allowing the caller to extend synchronization beyond just the operation in question, to include accessing a looked-up payload, e.g. 
</div>
</div><p>
<a class="anchor" name="g98ba198cad4e146607e8a07db005b514"></a><!-- doxytag: member="hashtable.h::hashtable_lock" ref="g98ba198cad4e146607e8a07db005b514" args="(hashtable_t *table)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hashtable_lock           </td>
          <td>(</td>
          <td class="paramtype">hashtable_t *&nbsp;</td>
          <td class="paramname"> <em>table</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Acquires the hashtable lock. 
</div>
</div><p>
<a class="anchor" name="ga6af018f2bb18648861e76bc0fdec96e"></a><!-- doxytag: member="hashtable.h::hashtable_lookup" ref="ga6af018f2bb18648861e76bc0fdec96e" args="(hashtable_t *table, void *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* hashtable_lookup           </td>
          <td>(</td>
          <td class="paramtype">hashtable_t *&nbsp;</td>
          <td class="paramname"> <em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the payload for the given key, or NULL if the key is not found 
</div>
</div><p>
<a class="anchor" name="g9d898d532b4ce1111bdd8bac317c6849"></a><!-- doxytag: member="hashtable.h::hashtable_lookup_keep_locked" ref="g9d898d532b4ce1111bdd8bac317c6849" args="(hashtable_t *table, void *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* hashtable_lookup_keep_locked           </td>
          <td>(</td>
          <td class="paramtype">hashtable_t *&nbsp;</td>
          <td class="paramname"> <em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like hashtable_lookup but does not unlock the hashtable lock 
</div>
</div><p>
<a class="anchor" name="g8972b42e34447e229489ab120271dbfd"></a><!-- doxytag: member="hashtable.h::hashtable_remove" ref="g8972b42e34447e229489ab120271dbfd" args="(hashtable_t *table, void *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hashtable_remove           </td>
          <td>(</td>
          <td class="paramtype">hashtable_t *&nbsp;</td>
          <td class="paramname"> <em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes the entry for key. If free_payload_func was specified calls it for the payload being removed. Returns false if no such entry exists. 
</div>
</div><p>
<a class="anchor" name="g8d7f9e88180c79d080113e2bec858dbf"></a><!-- doxytag: member="hashtable.h::hashtable_unlock" ref="g8d7f9e88180c79d080113e2bec858dbf" args="(hashtable_t *table)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hashtable_unlock           </td>
          <td>(</td>
          <td class="paramtype">hashtable_t *&nbsp;</td>
          <td class="paramname"> <em>table</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Releases the hashtable lock. 
</div>
</div><p>
<a class="anchor" name="gb341e9839c6cbd89a5a442df73468f5f"></a><!-- doxytag: member="hashtable.h::stri_eq" ref="gb341e9839c6cbd89a5a442df73468f5f" args="(const char *s1, const char *s2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stri_eq           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>s2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Caseless string compare 
</div>
</div><p>
</div>
<hr size="1"><address style="text-align: center;"><small>
<img border=0 src="favicon.png"> &nbsp; DynamoRIO API version 2.0.0 --- Thu Apr 22 00:18:20 2010 
&nbsp; <img border=0 src="favicon.png">
</body>
</html>
