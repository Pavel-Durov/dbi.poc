<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>DynamoRIO API: dr_tools.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
<link rel="shortcut icon" type="image/x-icon" href="favicon.ico" />
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="contents">
<h1>dr_tools.h File Reference</h1>Main API routines, including transparency support.  
<a href="dr__tools_8h.html#_details">More...</a>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__dr__mem__info__t.html">_dr_mem_info_t</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">union &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="union__version__number__t.html">_version_number_t</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__module__names__t.html">_module_names_t</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__module__data__t.html">_module_data_t</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__dr__export__info__t.html">_dr_export_info_t</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__tracedump__file__header__t.html">_tracedump_file_header_t</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__tracedump__trace__header__t.html">_tracedump_trace_header_t</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__tracedump__stub__data.html">_tracedump_stub_data</a></td></tr>

<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#c2c501052e751bc9c72c622b1ca8b96c">DR_MEMPROT_NONE</a>&nbsp;&nbsp;&nbsp;0x00</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#b430d92dd0d6338ec3e42b527ae91efb">DR_MEMPROT_READ</a>&nbsp;&nbsp;&nbsp;0x01</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#1dafb99a4933112c603189bc091fa752">DR_MEMPROT_WRITE</a>&nbsp;&nbsp;&nbsp;0x02</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#d98be75b6fde3dc1dbfb8bfda59fce66">DR_MEMPROT_EXEC</a>&nbsp;&nbsp;&nbsp;0x04</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#bd6d066ab9bdd578d4000e80df8503bc">DR_ASSERT_MSG</a>(x, msg)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#7c07630dffdfd92bc6ee63abf405768c">DR_ASSERT</a>(x)&nbsp;&nbsp;&nbsp;DR_ASSERT_MSG(x, &quot;&quot;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#d0772bc47090cec1a333baf1259f226d">DR_FILE_READ</a>&nbsp;&nbsp;&nbsp;0x1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#11f713faf2e1eac95bc26a98b67e28cc">DR_FILE_WRITE_REQUIRE_NEW</a>&nbsp;&nbsp;&nbsp;0x2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#c989ab040f48c4c91cc3a6ea63f9ec1f">DR_FILE_WRITE_APPEND</a>&nbsp;&nbsp;&nbsp;0x4</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#5fb30eb2b5d14486b3ecbc2b2457dfdb">DR_FILE_WRITE_OVERWRITE</a>&nbsp;&nbsp;&nbsp;0x8</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#77a3b276c8d9a62bf6d78c3707d4effd">DR_FILE_ALLOW_LARGE</a>&nbsp;&nbsp;&nbsp;0x10</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a675a6270b664511299295ebc1f5562e">DR_SEEK_SET</a>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#d31bd52878d2454d8263d0951cfd1ca0">DR_SEEK_CUR</a>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#06e58c043e838f1457853329fd4344a3">DR_SEEK_END</a>&nbsp;&nbsp;&nbsp;2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#1632479322efa3952798f98177b54471">LOG_NONE</a>&nbsp;&nbsp;&nbsp;0x00000000</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#9dd9f361c4a23133f724c84192eef8e1">LOG_STATS</a>&nbsp;&nbsp;&nbsp;0x00000001</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#9fdb93b09477bb1b1ee08d132dd6f4dc">LOG_TOP</a>&nbsp;&nbsp;&nbsp;0x00000002</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#9390202fe239f2ee56c097d6940d10f6">LOG_THREADS</a>&nbsp;&nbsp;&nbsp;0x00000004</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#87ef794555c43a1988eb760835b2fa76">LOG_SYSCALLS</a>&nbsp;&nbsp;&nbsp;0x00000008</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#5895b0ef2efc255ad93e50bc88277b6d">LOG_ASYNCH</a>&nbsp;&nbsp;&nbsp;0x00000010</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#54bbda8cb7e78f2ea32209bab2d7201c">LOG_INTERP</a>&nbsp;&nbsp;&nbsp;0x00000020</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#06582648acdd995a11019f726b15adda">LOG_EMIT</a>&nbsp;&nbsp;&nbsp;0x00000040</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#438ad3561d9d8616ff702b36d0b2bb7c">LOG_LINKS</a>&nbsp;&nbsp;&nbsp;0x00000080</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#031661fca6b5cb813db972d758caca2b">LOG_CACHE</a>&nbsp;&nbsp;&nbsp;0x00000100</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#7c5fcb805e6a1fdfac332931888b3ef7">LOG_FRAGMENT</a>&nbsp;&nbsp;&nbsp;0x00000200</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#9929e24db31369398fbdc52ee040b234">LOG_DISPATCH</a>&nbsp;&nbsp;&nbsp;0x00000400</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#2575baf458eee6334f746544f91fa6cf">LOG_MONITOR</a>&nbsp;&nbsp;&nbsp;0x00000800</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#5522e92b98898a21b7c26ba9df95f094">LOG_HEAP</a>&nbsp;&nbsp;&nbsp;0x00001000</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#557f3a77c5d95b7cd06661245030c687">LOG_VMAREAS</a>&nbsp;&nbsp;&nbsp;0x00002000</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#8879b800acfbbe8f2ada805be6ef5121">LOG_SYNCH</a>&nbsp;&nbsp;&nbsp;0x00004000</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#abb9931c63f1cf95cacca6463d5a9b09">LOG_MEMSTATS</a>&nbsp;&nbsp;&nbsp;0x00008000</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#9f746aa1ef6a208cd1cd7174a694c9e5">LOG_OPTS</a>&nbsp;&nbsp;&nbsp;0x00010000</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#8ad7f6071c29a882af67d3a72fe4e787">LOG_SIDELINE</a>&nbsp;&nbsp;&nbsp;0x00020000</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#65630bab8d9fcde517b3f8ecb03c6de9">LOG_SYMBOLS</a>&nbsp;&nbsp;&nbsp;0x00040000</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#297668a84187b740ff4fe1e1d6e52eeb">LOG_RCT</a>&nbsp;&nbsp;&nbsp;0x00080000</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#4f3856a58f1f9971ebcd62c99a448a5a">LOG_NT</a>&nbsp;&nbsp;&nbsp;0x00100000</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#51c2bbdf11618716da67a305dd24ddde">LOG_HOT_PATCHING</a>&nbsp;&nbsp;&nbsp;0x00200000</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#6ec73009ed3f0c2baa1d3c44033c261e">LOG_HTABLE</a>&nbsp;&nbsp;&nbsp;0x00400000</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#bba5e74dd3a5577b7af5177960ecb9dd">LOG_MODULEDB</a>&nbsp;&nbsp;&nbsp;0x00800000</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#7574ce4aa047de1f4a564c9b441e69dc">LOG_ALL</a>&nbsp;&nbsp;&nbsp;0x00ffffff</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#7af2dcd801f468cdc1cce40f7e885ffc">BB_ORIGIN_HEADER_SIZE</a>&nbsp;&nbsp;&nbsp;(sizeof(app_pc)+sizeof(int))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#25512292915eb6d1109b90f9c3bd1518">STUB_DATA_FIXED_SIZE</a>&nbsp;&nbsp;&nbsp;(offsetof(<a class="el" href="struct__tracedump__stub__data.html">tracedump_stub_data_t</a>, count))</td></tr>

<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef struct <a class="el" href="struct__dr__mem__info__t.html">_dr_mem_info_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#2834876d9bbe13989ed6ebc2e2f94c6a">dr_mem_info_t</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#b855db7dce02dc18831280f19df840cf">module_handle_t</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef union <a class="el" href="union__version__number__t.html">_version_number_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ee552e6017b95b4708435b9467223d98">version_number_t</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef struct <a class="el" href="struct__module__names__t.html">_module_names_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#8d2fef062beef2b521283369e0108282">module_names_t</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#fd116a488df74505f27ff57cd49b9f88">dr_module_iterator_t</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef struct <a class="el" href="struct__dr__export__info__t.html">_dr_export_info_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#f3e96c875a305558239b74496c4030d0">dr_export_info_t</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef struct <br class="typebreak">
<a class="el" href="struct__tracedump__file__header__t.html">_tracedump_file_header_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#99aca5de3a975309ebf0f24cfe42c1e8">tracedump_file_header_t</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef struct <br class="typebreak">
<a class="el" href="struct__tracedump__trace__header__t.html">_tracedump_trace_header_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#3fe0415406026b8daf538ab6ac31519d">tracedump_trace_header_t</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef struct <a class="el" href="struct__tracedump__stub__data.html">_tracedump_stub_data</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#fbec914b027f98ee51e888671aac55f0">tracedump_stub_data_t</a></td></tr>

<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ff97be516bbb1aecdb6bd043841aaa10">dr_mem_type_t</a> { <br>
&nbsp;&nbsp;<a class="el" href="dr__tools_8h.html#ff97be516bbb1aecdb6bd043841aaa1060e91c7b948d92d08b74ee0cd50dee3d">DR_MEMTYPE_FREE</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="dr__tools_8h.html#ff97be516bbb1aecdb6bd043841aaa106edf083337f9c953747a2cf4461dcbf7">DR_MEMTYPE_IMAGE</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="dr__tools_8h.html#ff97be516bbb1aecdb6bd043841aaa10c0350de0d08726ea8a5a5f02bb7010b0">DR_MEMTYPE_DATA</a>
<br>
 }</td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#f63184f56cc0508e2840f64e84b1c48d">dr_standalone_init</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#54934632c814904bd9e0ce9c83980466">dr_using_all_private_caches</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#902bfca468a7a2cc3dbc45b4bd127444">dr_request_synchronized_exit</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#10831623706378cfc3082c0e27e31c4c">dr_get_options</a> (<a class="el" href="dr__defines_8h.html#68540a70b4f8150a4fe6dcec91bf8825">client_id_t</a> client_id)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#fb7d403eb032bd14ae78807ae3d59ea0">dr_get_client_path</a> (<a class="el" href="dr__defines_8h.html#68540a70b4f8150a4fe6dcec91bf8825">client_id_t</a> client_id)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ace5e8084f523fd25871b31463c7ecda">dr_get_application_name</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">process_id_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#83b3658ca78e6b7adc81c57691f0fe50">dr_get_process_id</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">process_id_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#11575b203a0558f5df50126ff04c4598">dr_get_parent_id</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#c5804006579a63b49827169d3ffbebc8">dr_is_wow64</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#e517c4817d67af6ad92b8f1d7694080a">dr_get_time</a> (<a class="el" href="structdr__time__t.html">dr_time_t</a> *time)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">uint64&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#4b187636a3fc9ba7964ae11a7fd30fb6">dr_get_milliseconds</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#12c1ca981b7d3049cb2d31c0f19da332">dr_abort</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#4274226adda06339e247e4a311abdd9b">dr_thread_alloc</a> (void *drcontext, size_t size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#3f1f3862009f52182e9ca1f943fa6f14">dr_thread_free</a> (void *drcontext, void *mem, size_t size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#60faa40f7e8c819c34fd25cb367c5473">dr_global_alloc</a> (size_t size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ce8794210449c50fb4d411ad74a8dec1">dr_global_free</a> (void *mem, size_t size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#c32b5be072876c25a832d510efeba6e4">dr_nonheap_alloc</a> (size_t size, uint prot)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#401b819525f805d04e0a9560fdcfdf89">dr_nonheap_free</a> (void *mem, size_t size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#3687f50774c89e7a09833a71adbb7771">__wrap_malloc</a> (size_t size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#dcaad79adf4fc109015dd6a2d49b9031">__wrap_realloc</a> (void *mem, size_t size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#82dca5b3d5bfbd3de8891502badd861e">__wrap_free</a> (void *mem)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a1dd6ff985f0b21deada31ea33485737">dr_memory_is_readable</a> (const byte *pc, size_t size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#d158d2822dd8bb9caa9604d84b666bfa">dr_query_memory</a> (const byte *pc, byte **base_pc, size_t *size, uint *prot)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#5a6e4049f8accbc73ec5dbaf0deb25a7">dr_query_memory_ex</a> (const byte *pc, OUT <a class="el" href="struct__dr__mem__info__t.html">dr_mem_info_t</a> *info)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#55ca77553e86a0656dc186ae3fc8222f">dr_virtual_query</a> (const byte *pc, MEMORY_BASIC_INFORMATION *mbi, size_t mbi_size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#6a94558696130c76f34dcdac0ce50c47">dr_safe_read</a> (const void *base, size_t size, void *out_buf, size_t *bytes_read)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#b94f47b693cc7dd9eecba07d8cfd1bc8">dr_safe_write</a> (void *base, size_t size, const void *in_buf, size_t *bytes_written)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#2c3a19a0dc146c1e5b6747e89bacfb55">dr_memory_protect</a> (void *base, size_t size, uint new_prot)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#813f98fcc06c0a1198262b744e98eced">dr_memory_is_dr_internal</a> (const byte *pc)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#2a67b03d64626f3d0a78b64bf096ed25">dr_memory_is_in_client</a> (const byte *pc)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#55da3fd48670f25ec69ee5daf5975de5">dr_mutex_create</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aab148b68bc8e1479a14c175cbf42fc0">dr_mutex_destroy</a> (void *mutex)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#04beaefb3e0be6bd0dac39f76398ec1e">dr_mutex_lock</a> (void *mutex)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#61a3a4ffffd0058a37211405fbb6ba51">dr_mutex_unlock</a> (void *mutex)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#6b2ae4a29e2dc18dde2a6f01f26cbe79">dr_mutex_trylock</a> (void *mutex)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct__module__data__t.html">module_data_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#4892d089da710e952a23055bd7db38af">dr_lookup_module</a> (byte *pc)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct__module__data__t.html">module_data_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ddd653edd3322cfb025ef8bdc6ae1060">dr_lookup_module_by_name</a> (const char *name)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="dr__tools_8h.html#fd116a488df74505f27ff57cd49b9f88">dr_module_iterator_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#3310b1bfc22da285af72b1a4a9d10945">dr_module_iterator_start</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#1702cf25e24e722d9441f92c41fac33e">dr_module_iterator_hasnext</a> (<a class="el" href="dr__tools_8h.html#fd116a488df74505f27ff57cd49b9f88">dr_module_iterator_t</a> *mi)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct__module__data__t.html">module_data_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#9d49edb3a7b59f5d817afaa8fc0f1ef9">dr_module_iterator_next</a> (<a class="el" href="dr__tools_8h.html#fd116a488df74505f27ff57cd49b9f88">dr_module_iterator_t</a> *mi)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#15134844f1dd3e914c0da59c65cb3a8d">dr_module_iterator_stop</a> (<a class="el" href="dr__tools_8h.html#fd116a488df74505f27ff57cd49b9f88">dr_module_iterator_t</a> *mi)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct__module__data__t.html">module_data_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#8c99a2d79ed312cd852d57e975601adc">dr_copy_module_data</a> (const <a class="el" href="struct__module__data__t.html">module_data_t</a> *data)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#d72ba1e8b98c8e01f2c28ef2e4d3e16e">dr_free_module_data</a> (<a class="el" href="struct__module__data__t.html">module_data_t</a> *data)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#082fe71b00688310237fbc2e027c4388">dr_module_preferred_name</a> (const <a class="el" href="struct__module__data__t.html">module_data_t</a> *data)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#c520aa05555ecbf9e525de582d4baa8c">dr_lookup_module_section</a> (<a class="el" href="dr__tools_8h.html#b855db7dce02dc18831280f19df840cf">module_handle_t</a> lib, byte *pc, IMAGE_SECTION_HEADER *section_out)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">generic_func_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#8da7923ecc4e020e31442bcc8d9f8d3e">dr_get_proc_address</a> (<a class="el" href="dr__tools_8h.html#b855db7dce02dc18831280f19df840cf">module_handle_t</a> lib, const char *name)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#f1a068ad89408abbcfba026706810211">dr_get_proc_address_ex</a> (<a class="el" href="dr__tools_8h.html#b855db7dce02dc18831280f19df840cf">module_handle_t</a> lib, const char *name, <a class="el" href="struct__dr__export__info__t.html">dr_export_info_t</a> *info OUT, size_t info_len)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">reg_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#1e01fe123ecc9908ada9c9fccbf3f6ab">dr_syscall_get_param</a> (void *drcontext, int param_num)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#c21a83f1812443112303ef3ea8b76de2">dr_syscall_set_param</a> (void *drcontext, int param_num, reg_t new_value)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">reg_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#d12463724bf63a891e991891c72e6a4b">dr_syscall_get_result</a> (void *drcontext)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#601cd2b724ac627aef0756a4c4eee637">dr_syscall_set_result</a> (void *drcontext, reg_t value)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#bc80dfdf8bff3c3feb486aacd69aba7c">dr_syscall_set_sysnum</a> (void *drcontext, int new_num)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#76797a9310bf67ebeb820d80e11764b8">dr_syscall_invoke_another</a> (void *drcontext)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#1ee2651cad7bafe65f3df7d4aeb82120">dr_create_dir</a> (const char *fname)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#02f86a68a105442a029baa05a1af9d57">dr_directory_exists</a> (const char *fname)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#f471633d0954d80c09ca6c2bfe40475b">dr_file_exists</a> (const char *fname)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">file_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#e3ae2190774a204af207602791a32cb6">dr_open_file</a> (const char *fname, uint mode_flags)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#c25b305e0be9f6c09f9761b14f3bbc74">dr_close_file</a> (file_t f)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#e51098d1c742e3189a197db0c212eaa9">dr_flush_file</a> (file_t f)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">ssize_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#eddf708cc2271dc50209b3e78e1d23fb">dr_write_file</a> (file_t f, const void *buf, size_t count)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">ssize_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#71f6940085912cdce608f317a27fc397">dr_read_file</a> (file_t f, void *buf, size_t count)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#18c2c9d68ceceef8c6455b06502667ee">dr_file_seek</a> (file_t f, int64 offset, int origin)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int64&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#1fc1d26f3050d6f361e7b07f98c7e82d">dr_file_tell</a> (file_t f)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">file_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#66ef4b43d78d787c7622569d30717051">dr_dup_file_handle</a> (file_t f)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#332a14861f12823994465e8c9b6a3015">dr_log</a> (void *drcontext, uint mask, uint level, const char *fmt,...)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">file_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#fd7e9d485a84aa147e0ec0e75ad6d962">dr_get_logfile</a> (void *drcontext)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#f91a810b83f1173a5720a955c3d0fd4a">dr_is_notify_on</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">file_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#0353e78f517dc281de22539682d9e6d9">dr_get_stdout_file</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">file_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#20dccb3e2b03e8f408b2a340c70a28e2">dr_get_stderr_file</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">file_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ed162d7ad949b05fe8232771eaeca6a9">dr_get_stdin_file</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#d444a204e7ca45f9965cfe973470375a">dr_messagebox</a> (const char *fmt,...)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#bad2eddb3786e3e909ff36da39b7e31e">dr_printf</a> (const char *fmt,...)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#fe7ede5b10890505021ac03e8f9ba97f">dr_fprintf</a> (file_t f, const char *fmt,...)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#b0c5f2529d9c076b5b0b0e92a70834b7">dr_snprintf</a> (char *buf, size_t max, const char *fmt,...)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ecb77c99028d913a72c6aaeef48db785">dr_print_instr</a> (void *drcontext, file_t f, <a class="el" href="structinstr__t.html">instr_t</a> *instr, const char *msg)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#5902fa16202c9c42d96c755e9412d372">dr_print_opnd</a> (void *drcontext, file_t f, <a class="el" href="structopnd__t.html">opnd_t</a> opnd, const char *msg)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#13217cc252506b06184c7c72adedf26c">dr_get_current_drcontext</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">thread_id_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#3980d703cc13379a6b57396a7901b1d1">dr_get_thread_id</a> (void *drcontext)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#787aff5df1ded3de8a7ce9f3efef0594">dr_get_tls_field</a> (void *drcontext)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#05b499c8a3115e9ceb4c45dbee660738">dr_set_tls_field</a> (void *drcontext, void *value)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#95b53d79cae021a473c39f3b2662323f">dr_raw_tls_calloc</a> (OUT reg_id_t *segment_register, OUT uint *offset, IN uint num_slots, IN uint alignment)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#fc53219d019078a38c80ffa80d71829e">dr_raw_tls_cfree</a> (uint offset, uint num_slots)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#c6b80b83502ff13d4674b13e7b30b555">dr_create_client_thread</a> (void(*func)(void *param), void *arg)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#f154e498d8b185931ef970676cb65351">dr_sleep</a> (int time_ms)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#c262422c1e5e487113176bd4193c387f">dr_thread_yield</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#01fbe357fcc8352ba63c9a1a23e0c207">dr_suspend_all_other_threads</a> (OUT void ***drcontexts, OUT uint *num_suspended, OUT uint *num_unsuspended)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#1193842150b09442a1b3c91f4e02d280">dr_resume_all_other_threads</a> (IN void **drcontexts, IN uint num_suspended)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#9191c67a267070ed51289d7192f986aa">dr_set_itimer</a> (int which, uint millisec, void(*func)(void *drcontext, <a class="el" href="struct__dr__mcontext__t.html">dr_mcontext_t</a> *mcontext))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">uint&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#b5cd85ea911bd99dedbd8d05796260bc">dr_get_itimer</a> (int which)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#5421c0abd69da94ed3e7fb898d5bb132">dr_replace_fragment</a> (void *drcontext, void *tag, instrlist_t *ilist)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#7600cc31d68dc0e30ab91261d08836ed">dr_delete_fragment</a> (void *drcontext, void *tag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#be87d17869a51a66d59eecf459d71cc0">dr_flush_region</a> (app_pc start, size_t size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#56909cf76e4a71fca13731053ef48928">dr_unlink_flush_region</a> (app_pc start, size_t size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#fa5ea6649e644074ca55f456c89264e8">dr_delay_flush_region</a> (app_pc start, size_t size, uint flush_id, void(*flush_completion_callback)(int flush_id))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#775fdf1d5a55b5fbca094a4d2f18d28f">dr_fragment_exists_at</a> (void *drcontext, void *tag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ad3b09e886366ac10341e69a577555dd">dr_bb_exists_at</a> (void *drcontext, void *tag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">uint&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#cfe1f6436b234406bde1970ecfa614b5">dr_fragment_size</a> (void *drcontext, void *tag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">app_pc&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#724aa7f7e87a604071fffa0a01925bf0">dr_fragment_app_pc</a> (void *tag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">app_pc&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#cd67a10cd03a382853a0523bde9990f5">dr_app_pc_for_decoding</a> (app_pc pc)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#9e262e93823dbc5914eca34540afbc07">dr_mark_trace_head</a> (void *drcontext, void *tag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#1e3f7e4e3e4048021966c04a4b00fbc9">dr_trace_head_at</a> (void *drcontext, void *tag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#1d4c9a29f1c962457c123322aa3e1931">dr_trace_exists_at</a> (void *drcontext, void *tag)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Main API routines, including transparency support. 
<p>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="7af2dcd801f468cdc1cce40f7e885ffc"></a><!-- doxytag: member="dr_tools.h::BB_ORIGIN_HEADER_SIZE" ref="7af2dcd801f468cdc1cce40f7e885ffc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BB_ORIGIN_HEADER_SIZE&nbsp;&nbsp;&nbsp;(sizeof(app_pc)+sizeof(int))          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Size of tag + bb_code_size fields for each bb. <a class="el" href="struct__tracedump__stub__data.html#b397d14965f6ac0c4f0c28a36f667200">tracedump_stub_data_t.stub_size</a> will not exceed this value. 
</div>
</div><p>
<a class="anchor" name="7c07630dffdfd92bc6ee63abf405768c"></a><!-- doxytag: member="dr_tools.h::DR_ASSERT" ref="7c07630dffdfd92bc6ee63abf405768c" args="(x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_ASSERT          </td>
          <td>(</td>
          <td class="paramtype">x&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;DR_ASSERT_MSG(x, &quot;&quot;)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If <code>x</code> is false, displays a message about an assertion failure and then calls <a class="el" href="dr__tools_8h.html#12c1ca981b7d3049cb2d31c0f19da332">dr_abort()</a> 
</div>
</div><p>
<a class="anchor" name="bd6d066ab9bdd578d4000e80df8503bc"></a><!-- doxytag: member="dr_tools.h::DR_ASSERT_MSG" ref="bd6d066ab9bdd578d4000e80df8503bc" args="(x, msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_ASSERT_MSG          </td>
          <td>(</td>
          <td class="paramtype">x,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">msg&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment">((void)((!(x)) ? \
        (<a class="code" href="dr__tools_8h.html#d444a204e7ca45f9965cfe973470375a">dr_messagebox</a>(<span class="stringliteral">"ASSERT FAILURE: %s:%d: %s (%s)"</span>, __FILE__,  __LINE__, #x, msg),\
         <a class="code" href="dr__tools_8h.html#12c1ca981b7d3049cb2d31c0f19da332">dr_abort</a>(), 0) : 0))
</pre></div>If <code>x</code> is false, displays a message about an assertion failure (appending <code>msg</code> to the message) and then calls <a class="el" href="dr__tools_8h.html#12c1ca981b7d3049cb2d31c0f19da332">dr_abort()</a> 
</div>
</div><p>
<a class="anchor" name="77a3b276c8d9a62bf6d78c3707d4effd"></a><!-- doxytag: member="dr_tools.h::DR_FILE_ALLOW_LARGE" ref="77a3b276c8d9a62bf6d78c3707d4effd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_FILE_ALLOW_LARGE&nbsp;&nbsp;&nbsp;0x10          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Open with large (&gt;2GB) file support. Only applicable on 32-bit Linux. <dl class="note" compact><dt><b>Note:</b></dt><dd>DR's log files and tracedump files are all created with this flag. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d0772bc47090cec1a333baf1259f226d"></a><!-- doxytag: member="dr_tools.h::DR_FILE_READ" ref="d0772bc47090cec1a333baf1259f226d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_FILE_READ&nbsp;&nbsp;&nbsp;0x1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Open with read access. 
</div>
</div><p>
<a class="anchor" name="c989ab040f48c4c91cc3a6ea63f9ec1f"></a><!-- doxytag: member="dr_tools.h::DR_FILE_WRITE_APPEND" ref="c989ab040f48c4c91cc3a6ea63f9ec1f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_FILE_WRITE_APPEND&nbsp;&nbsp;&nbsp;0x4          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Open with write access. If the file already exists, set the file position to the end of the file. 
</div>
</div><p>
<a class="anchor" name="5fb30eb2b5d14486b3ecbc2b2457dfdb"></a><!-- doxytag: member="dr_tools.h::DR_FILE_WRITE_OVERWRITE" ref="5fb30eb2b5d14486b3ecbc2b2457dfdb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_FILE_WRITE_OVERWRITE&nbsp;&nbsp;&nbsp;0x8          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Open with write access. If the file already exists, truncate the file to zero length. 
</div>
</div><p>
<a class="anchor" name="11f713faf2e1eac95bc26a98b67e28cc"></a><!-- doxytag: member="dr_tools.h::DR_FILE_WRITE_REQUIRE_NEW" ref="11f713faf2e1eac95bc26a98b67e28cc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_FILE_WRITE_REQUIRE_NEW&nbsp;&nbsp;&nbsp;0x2          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Open with write access, but do not open if the file already exists. 
</div>
</div><p>
<a class="anchor" name="d98be75b6fde3dc1dbfb8bfda59fce66"></a><!-- doxytag: member="dr_tools.h::DR_MEMPROT_EXEC" ref="d98be75b6fde3dc1dbfb8bfda59fce66" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_MEMPROT_EXEC&nbsp;&nbsp;&nbsp;0x04          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Execute privileges. 
</div>
</div><p>
<a class="anchor" name="c2c501052e751bc9c72c622b1ca8b96c"></a><!-- doxytag: member="dr_tools.h::DR_MEMPROT_NONE" ref="c2c501052e751bc9c72c622b1ca8b96c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_MEMPROT_NONE&nbsp;&nbsp;&nbsp;0x00          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
No read, write, or execute privileges. 
</div>
</div><p>
<a class="anchor" name="b430d92dd0d6338ec3e42b527ae91efb"></a><!-- doxytag: member="dr_tools.h::DR_MEMPROT_READ" ref="b430d92dd0d6338ec3e42b527ae91efb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_MEMPROT_READ&nbsp;&nbsp;&nbsp;0x01          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read privileges. 
</div>
</div><p>
<a class="anchor" name="1dafb99a4933112c603189bc091fa752"></a><!-- doxytag: member="dr_tools.h::DR_MEMPROT_WRITE" ref="1dafb99a4933112c603189bc091fa752" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_MEMPROT_WRITE&nbsp;&nbsp;&nbsp;0x02          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write privileges. 
</div>
</div><p>
<a class="anchor" name="d31bd52878d2454d8263d0951cfd1ca0"></a><!-- doxytag: member="dr_tools.h::DR_SEEK_CUR" ref="d31bd52878d2454d8263d0951cfd1ca0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_SEEK_CUR&nbsp;&nbsp;&nbsp;1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
current file position 
</div>
</div><p>
<a class="anchor" name="06e58c043e838f1457853329fd4344a3"></a><!-- doxytag: member="dr_tools.h::DR_SEEK_END" ref="06e58c043e838f1457853329fd4344a3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_SEEK_END&nbsp;&nbsp;&nbsp;2          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
end of file 
</div>
</div><p>
<a class="anchor" name="a675a6270b664511299295ebc1f5562e"></a><!-- doxytag: member="dr_tools.h::DR_SEEK_SET" ref="a675a6270b664511299295ebc1f5562e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_SEEK_SET&nbsp;&nbsp;&nbsp;0          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
start of file 
</div>
</div><p>
<a class="anchor" name="7574ce4aa047de1f4a564c9b441e69dc"></a><!-- doxytag: member="dr_tools.h::LOG_ALL" ref="7574ce4aa047de1f4a564c9b441e69dc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_ALL&nbsp;&nbsp;&nbsp;0x00ffffff          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Log all data. 
</div>
</div><p>
<a class="anchor" name="5895b0ef2efc255ad93e50bc88277b6d"></a><!-- doxytag: member="dr_tools.h::LOG_ASYNCH" ref="5895b0ef2efc255ad93e50bc88277b6d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_ASYNCH&nbsp;&nbsp;&nbsp;0x00000010          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Log data related to signals/callbacks/etc. 
</div>
</div><p>
<a class="anchor" name="031661fca6b5cb813db972d758caca2b"></a><!-- doxytag: member="dr_tools.h::LOG_CACHE" ref="031661fca6b5cb813db972d758caca2b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_CACHE&nbsp;&nbsp;&nbsp;0x00000100          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Log data related to code cache management. 
</div>
</div><p>
<a class="anchor" name="9929e24db31369398fbdc52ee040b234"></a><!-- doxytag: member="dr_tools.h::LOG_DISPATCH" ref="9929e24db31369398fbdc52ee040b234" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_DISPATCH&nbsp;&nbsp;&nbsp;0x00000400          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Log data on every context switch dispatch. 
</div>
</div><p>
<a class="anchor" name="06582648acdd995a11019f726b15adda"></a><!-- doxytag: member="dr_tools.h::LOG_EMIT" ref="06582648acdd995a11019f726b15adda" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_EMIT&nbsp;&nbsp;&nbsp;0x00000040          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Log data related to emitting code. 
</div>
</div><p>
<a class="anchor" name="7c5fcb805e6a1fdfac332931888b3ef7"></a><!-- doxytag: member="dr_tools.h::LOG_FRAGMENT" ref="7c5fcb805e6a1fdfac332931888b3ef7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_FRAGMENT&nbsp;&nbsp;&nbsp;0x00000200          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Log data related to app code fragments. 
</div>
</div><p>
<a class="anchor" name="5522e92b98898a21b7c26ba9df95f094"></a><!-- doxytag: member="dr_tools.h::LOG_HEAP" ref="5522e92b98898a21b7c26ba9df95f094" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_HEAP&nbsp;&nbsp;&nbsp;0x00001000          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Log data related to memory management. 
</div>
</div><p>
<a class="anchor" name="51c2bbdf11618716da67a305dd24ddde"></a><!-- doxytag: member="dr_tools.h::LOG_HOT_PATCHING" ref="51c2bbdf11618716da67a305dd24ddde" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_HOT_PATCHING&nbsp;&nbsp;&nbsp;0x00200000          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Log data related to hot patching. 
</div>
</div><p>
<a class="anchor" name="6ec73009ed3f0c2baa1d3c44033c261e"></a><!-- doxytag: member="dr_tools.h::LOG_HTABLE" ref="6ec73009ed3f0c2baa1d3c44033c261e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_HTABLE&nbsp;&nbsp;&nbsp;0x00400000          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Log data related to hash tables. 
</div>
</div><p>
<a class="anchor" name="54bbda8cb7e78f2ea32209bab2d7201c"></a><!-- doxytag: member="dr_tools.h::LOG_INTERP" ref="54bbda8cb7e78f2ea32209bab2d7201c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_INTERP&nbsp;&nbsp;&nbsp;0x00000020          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Log data related to app interpretation. 
</div>
</div><p>
<a class="anchor" name="438ad3561d9d8616ff702b36d0b2bb7c"></a><!-- doxytag: member="dr_tools.h::LOG_LINKS" ref="438ad3561d9d8616ff702b36d0b2bb7c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_LINKS&nbsp;&nbsp;&nbsp;0x00000080          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Log data related to linking code. 
</div>
</div><p>
<a class="anchor" name="abb9931c63f1cf95cacca6463d5a9b09"></a><!-- doxytag: member="dr_tools.h::LOG_MEMSTATS" ref="abb9931c63f1cf95cacca6463d5a9b09" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_MEMSTATS&nbsp;&nbsp;&nbsp;0x00008000          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Log data related to memory statistics. 
</div>
</div><p>
<a class="anchor" name="bba5e74dd3a5577b7af5177960ecb9dd"></a><!-- doxytag: member="dr_tools.h::LOG_MODULEDB" ref="bba5e74dd3a5577b7af5177960ecb9dd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_MODULEDB&nbsp;&nbsp;&nbsp;0x00800000          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Log data related to the module database. 
</div>
</div><p>
<a class="anchor" name="2575baf458eee6334f746544f91fa6cf"></a><!-- doxytag: member="dr_tools.h::LOG_MONITOR" ref="2575baf458eee6334f746544f91fa6cf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_MONITOR&nbsp;&nbsp;&nbsp;0x00000800          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Log data related to trace building. 
</div>
</div><p>
<a class="anchor" name="1632479322efa3952798f98177b54471"></a><!-- doxytag: member="dr_tools.h::LOG_NONE" ref="1632479322efa3952798f98177b54471" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_NONE&nbsp;&nbsp;&nbsp;0x00000000          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Log no data. 
</div>
</div><p>
<a class="anchor" name="4f3856a58f1f9971ebcd62c99a448a5a"></a><!-- doxytag: member="dr_tools.h::LOG_NT" ref="4f3856a58f1f9971ebcd62c99a448a5a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_NT&nbsp;&nbsp;&nbsp;0x00100000          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Log data related to Windows Native API. 
</div>
</div><p>
<a class="anchor" name="9f746aa1ef6a208cd1cd7174a694c9e5"></a><!-- doxytag: member="dr_tools.h::LOG_OPTS" ref="9f746aa1ef6a208cd1cd7174a694c9e5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_OPTS&nbsp;&nbsp;&nbsp;0x00010000          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Log data related to optimizations. 
</div>
</div><p>
<a class="anchor" name="297668a84187b740ff4fe1e1d6e52eeb"></a><!-- doxytag: member="dr_tools.h::LOG_RCT" ref="297668a84187b740ff4fe1e1d6e52eeb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_RCT&nbsp;&nbsp;&nbsp;0x00080000          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Log data related to indirect transfers. 
</div>
</div><p>
<a class="anchor" name="8ad7f6071c29a882af67d3a72fe4e787"></a><!-- doxytag: member="dr_tools.h::LOG_SIDELINE" ref="8ad7f6071c29a882af67d3a72fe4e787" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_SIDELINE&nbsp;&nbsp;&nbsp;0x00020000          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Log data related to sideline threads. 
</div>
</div><p>
<a class="anchor" name="9dd9f361c4a23133f724c84192eef8e1"></a><!-- doxytag: member="dr_tools.h::LOG_STATS" ref="9dd9f361c4a23133f724c84192eef8e1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_STATS&nbsp;&nbsp;&nbsp;0x00000001          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Log per-thread and global statistics. 
</div>
</div><p>
<a class="anchor" name="65630bab8d9fcde517b3f8ecb03c6de9"></a><!-- doxytag: member="dr_tools.h::LOG_SYMBOLS" ref="65630bab8d9fcde517b3f8ecb03c6de9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_SYMBOLS&nbsp;&nbsp;&nbsp;0x00040000          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Log data related to app symbols. 
</div>
</div><p>
<a class="anchor" name="8879b800acfbbe8f2ada805be6ef5121"></a><!-- doxytag: member="dr_tools.h::LOG_SYNCH" ref="8879b800acfbbe8f2ada805be6ef5121" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_SYNCH&nbsp;&nbsp;&nbsp;0x00004000          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Log data related to synchronization. 
</div>
</div><p>
<a class="anchor" name="87ef794555c43a1988eb760835b2fa76"></a><!-- doxytag: member="dr_tools.h::LOG_SYSCALLS" ref="87ef794555c43a1988eb760835b2fa76" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_SYSCALLS&nbsp;&nbsp;&nbsp;0x00000008          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Log data related to system calls. 
</div>
</div><p>
<a class="anchor" name="9390202fe239f2ee56c097d6940d10f6"></a><!-- doxytag: member="dr_tools.h::LOG_THREADS" ref="9390202fe239f2ee56c097d6940d10f6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_THREADS&nbsp;&nbsp;&nbsp;0x00000004          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Log data related to threads. 
</div>
</div><p>
<a class="anchor" name="9fdb93b09477bb1b1ee08d132dd6f4dc"></a><!-- doxytag: member="dr_tools.h::LOG_TOP" ref="9fdb93b09477bb1b1ee08d132dd6f4dc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_TOP&nbsp;&nbsp;&nbsp;0x00000002          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Log top-level information. 
</div>
</div><p>
<a class="anchor" name="557f3a77c5d95b7cd06661245030c687"></a><!-- doxytag: member="dr_tools.h::LOG_VMAREAS" ref="557f3a77c5d95b7cd06661245030c687" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_VMAREAS&nbsp;&nbsp;&nbsp;0x00002000          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Log data related to address space regions. 
</div>
</div><p>
<a class="anchor" name="25512292915eb6d1109b90f9c3bd1518"></a><!-- doxytag: member="dr_tools.h::STUB_DATA_FIXED_SIZE" ref="25512292915eb6d1109b90f9c3bd1518" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STUB_DATA_FIXED_SIZE&nbsp;&nbsp;&nbsp;(offsetof(<a class="el" href="struct__tracedump__stub__data.html">tracedump_stub_data_t</a>, count))          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The last offset into tracedump_stub_data_t of always-present fields. 
</div>
</div><p>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="f3e96c875a305558239b74496c4030d0"></a><!-- doxytag: member="dr_tools.h::dr_export_info_t" ref="f3e96c875a305558239b74496c4030d0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__dr__export__info__t.html">_dr_export_info_t</a>  <a class="el" href="struct__dr__export__info__t.html">dr_export_info_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Data structure used by <a class="el" href="dr__tools_8h.html#f1a068ad89408abbcfba026706810211">dr_get_proc_address_ex()</a> to retrieve information about an exported symbol. 
</div>
</div><p>
<a class="anchor" name="2834876d9bbe13989ed6ebc2e2f94c6a"></a><!-- doxytag: member="dr_tools.h::dr_mem_info_t" ref="2834876d9bbe13989ed6ebc2e2f94c6a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__dr__mem__info__t.html">_dr_mem_info_t</a>  <a class="el" href="struct__dr__mem__info__t.html">dr_mem_info_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Describes a memory region. Used by <a class="el" href="dr__tools_8h.html#5a6e4049f8accbc73ec5dbaf0deb25a7">dr_query_memory_ex()</a>. 
</div>
</div><p>
<a class="anchor" name="fd116a488df74505f27ff57cd49b9f88"></a><!-- doxytag: member="dr_tools.h::dr_module_iterator_t" ref="fd116a488df74505f27ff57cd49b9f88" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void* <a class="el" href="dr__tools_8h.html#fd116a488df74505f27ff57cd49b9f88">dr_module_iterator_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
For dr_module_iterator_* interface 
</div>
</div><p>
<a class="anchor" name="b855db7dce02dc18831280f19df840cf"></a><!-- doxytag: member="dr_tools.h::module_handle_t" ref="b855db7dce02dc18831280f19df840cf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void* <a class="el" href="dr__tools_8h.html#b855db7dce02dc18831280f19df840cf">module_handle_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Type used for <a class="el" href="dr__tools_8h.html#8da7923ecc4e020e31442bcc8d9f8d3e">dr_get_proc_address()</a>. This can be obtained from the <a class="el" href="struct__module__data__t.html">_module_data_t</a> structure. It is equivalent to the base address of the module on both Windows and Linux. 
</div>
</div><p>
<a class="anchor" name="8d2fef062beef2b521283369e0108282"></a><!-- doxytag: member="dr_tools.h::module_names_t" ref="8d2fef062beef2b521283369e0108282" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__module__names__t.html">_module_names_t</a>  <a class="el" href="struct__module__names__t.html">module_names_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Holds the names of a module. This structure contains multiple fields corresponding to different sources of a module name. Note that some of these names may not exist for certain modules. It is highly likely, however, that at least one name is available. Use <a class="el" href="dr__tools_8h.html#082fe71b00688310237fbc2e027c4388">dr_module_preferred_name()</a> on the parent <a class="el" href="struct__module__data__t.html">_module_data_t</a> to get the preferred name of the module. 
</div>
</div><p>
<a class="anchor" name="99aca5de3a975309ebf0f24cfe42c1e8"></a><!-- doxytag: member="dr_tools.h::tracedump_file_header_t" ref="99aca5de3a975309ebf0f24cfe42c1e8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__tracedump__file__header__t.html">_tracedump_file_header_t</a>  <a class="el" href="struct__tracedump__file__header__t.html">tracedump_file_header_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<pre>
 Binary trace dump format:
 the file starts with a tracedump_file_header_t
 then, for each trace:
     struct _tracedump_trace_header
     if num_bbs &gt; 0 # tracedump_origins
       foreach bb:
           app_pc tag;
           int bb_code_size;
           byte code[bb_code_size];
     endif
     foreach exit:
       struct <a class="el" href="struct__tracedump__stub__data.html">_tracedump_stub_data</a>
       if linkcount_size &gt; 0
         linkcount_type_t count; # sizeof == linkcount_size
       endif
       if separate from body
       (i.e., exit_stub &lt; cache_start_pc || exit_stub &gt;= cache_start_pc+code_size):
           byte stub_code[15]; # all separate stubs are 15
       endif
     endfor
     byte code[code_size];
 if the -tracedump_threshold option (deprecated) was specified:
     int num_below_treshold
     linkcount_type_t count_below_threshold
   endif
</pre> 
</div>
</div><p>
<a class="anchor" name="fbec914b027f98ee51e888671aac55f0"></a><!-- doxytag: member="dr_tools.h::tracedump_stub_data_t" ref="fbec914b027f98ee51e888671aac55f0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__tracedump__stub__data.html">_tracedump_stub_data</a>  <a class="el" href="struct__tracedump__stub__data.html">tracedump_stub_data_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The format of a stub in a trace dump file. 
</div>
</div><p>
<a class="anchor" name="3fe0415406026b8daf538ab6ac31519d"></a><!-- doxytag: member="dr_tools.h::tracedump_trace_header_t" ref="3fe0415406026b8daf538ab6ac31519d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__tracedump__trace__header__t.html">_tracedump_trace_header_t</a>  <a class="el" href="struct__tracedump__trace__header__t.html">tracedump_trace_header_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Header for an individual trace in a binary trace dump file. 
</div>
</div><p>
<a class="anchor" name="ee552e6017b95b4708435b9467223d98"></a><!-- doxytag: member="dr_tools.h::version_number_t" ref="ee552e6017b95b4708435b9467223d98" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef union <a class="el" href="union__version__number__t.html">_version_number_t</a>  <a class="el" href="union__version__number__t.html">version_number_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Used to hold .rsrc section version number information. This number is usually presented as p1.p2.p3.p4 by PE parsing tools. 
</div>
</div><p>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="ff97be516bbb1aecdb6bd043841aaa10"></a><!-- doxytag: member="dr_tools.h::dr_mem_type_t" ref="ff97be516bbb1aecdb6bd043841aaa10" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="dr__tools_8h.html#ff97be516bbb1aecdb6bd043841aaa10">dr_mem_type_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Flags describing memory used by <a class="el" href="dr__tools_8h.html#5a6e4049f8accbc73ec5dbaf0deb25a7">dr_query_memory_ex()</a>. <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="ff97be516bbb1aecdb6bd043841aaa1060e91c7b948d92d08b74ee0cd50dee3d"></a><!-- doxytag: member="DR_MEMTYPE_FREE" ref="ff97be516bbb1aecdb6bd043841aaa1060e91c7b948d92d08b74ee0cd50dee3d" args="" -->DR_MEMTYPE_FREE</em>&nbsp;</td><td>
No memory is allocated here </td></tr>
<tr><td valign="top"><em><a class="anchor" name="ff97be516bbb1aecdb6bd043841aaa106edf083337f9c953747a2cf4461dcbf7"></a><!-- doxytag: member="DR_MEMTYPE_IMAGE" ref="ff97be516bbb1aecdb6bd043841aaa106edf083337f9c953747a2cf4461dcbf7" args="" -->DR_MEMTYPE_IMAGE</em>&nbsp;</td><td>
An executable file is mapped here </td></tr>
<tr><td valign="top"><em><a class="anchor" name="ff97be516bbb1aecdb6bd043841aaa10c0350de0d08726ea8a5a5f02bb7010b0"></a><!-- doxytag: member="DR_MEMTYPE_DATA" ref="ff97be516bbb1aecdb6bd043841aaa10c0350de0d08726ea8a5a5f02bb7010b0" args="" -->DR_MEMTYPE_DATA</em>&nbsp;</td><td>
Some other data is allocated here </td></tr>
</table>
</dl>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="82dca5b3d5bfbd3de8891502badd861e"></a><!-- doxytag: member="dr_tools.h::__wrap_free" ref="82dca5b3d5bfbd3de8891502badd861e" args="(void *mem)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void __wrap_free           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>mem</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Frees memory from DR's global memory pool. Memory must have been allocated with <a class="el" href="dr__tools_8h.html#3687f50774c89e7a09833a71adbb7771">__wrap_malloc()</a>. The __wrap routines are intended to be used with ld's -wrap option; see <a class="el" href="dr__tools_8h.html#3687f50774c89e7a09833a71adbb7771">__wrap_malloc()</a> for more information. <dl class="note" compact><dt><b>Note:</b></dt><dd>Currently Linux only. </dd></dl>

</div>
</div><p>
<a class="anchor" name="3687f50774c89e7a09833a71adbb7771"></a><!-- doxytag: member="dr_tools.h::__wrap_malloc" ref="3687f50774c89e7a09833a71adbb7771" args="(size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* __wrap_malloc           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allocates memory from DR's global memory pool, but mimics the behavior of malloc. Memory must be freed with <a class="el" href="dr__tools_8h.html#82dca5b3d5bfbd3de8891502badd861e">__wrap_free()</a>. The __wrap routines are intended to be used with ld's -wrap option to replace a client's use of malloc, realloc, and free with internal versions that allocate memory from DR's private pool. With -wrap, clients can link to libraries that allocate heap memory without interfering with application allocations. <dl class="note" compact><dt><b>Note:</b></dt><dd>Currently Linux only. </dd></dl>

</div>
</div><p>
<a class="anchor" name="dcaad79adf4fc109015dd6a2d49b9031"></a><!-- doxytag: member="dr_tools.h::__wrap_realloc" ref="dcaad79adf4fc109015dd6a2d49b9031" args="(void *mem, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* __wrap_realloc           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reallocates memory from DR's global memory pool, but mimics the behavior of realloc. Memory must be freed with <a class="el" href="dr__tools_8h.html#82dca5b3d5bfbd3de8891502badd861e">__wrap_free()</a>. The __wrap routines are intended to be used with ld's -wrap option; see <a class="el" href="dr__tools_8h.html#3687f50774c89e7a09833a71adbb7771">__wrap_malloc()</a> for more information. <dl class="note" compact><dt><b>Note:</b></dt><dd>Currently Linux only. </dd></dl>

</div>
</div><p>
<a class="anchor" name="12c1ca981b7d3049cb2d31c0f19da332"></a><!-- doxytag: member="dr_tools.h::dr_abort" ref="12c1ca981b7d3049cb2d31c0f19da332" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_abort           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Aborts the process immediately. 
</div>
</div><p>
<a class="anchor" name="cd67a10cd03a382853a0523bde9990f5"></a><!-- doxytag: member="dr_tools.h::dr_app_pc_for_decoding" ref="cd67a10cd03a382853a0523bde9990f5" args="(app_pc pc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">app_pc dr_app_pc_for_decoding           </td>
          <td>(</td>
          <td class="paramtype">app_pc&nbsp;</td>
          <td class="paramname"> <em>pc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Given an application PC, returns a PC that contains the application code corresponding to the original PC. In some circumstances on Windows DR inserts a jump on top of the original code, which the client will not see in the bb and trace hooks due to DR replacing it there with the displaced original application code in order to present the client with an unmodified view of the application code. A client should use this routine when attempting to decode the original application instruction that caused a fault from the translated fault address, as the translated address may actually point in the middle of DR's jump.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Other applications on the system sometimes insert their own hooks, which will not be hidden by DR and will appear to the client as jumps and subsequent displaced code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ad3b09e886366ac10341e69a577555dd"></a><!-- doxytag: member="dr_tools.h::dr_bb_exists_at" ref="ad3b09e886366ac10341e69a577555dd" args="(void *drcontext, void *tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_bb_exists_at           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>tag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if a basic block with tag <code>tag</code> exists in the code cache. 
</div>
</div><p>
<a class="anchor" name="c25b305e0be9f6c09f9761b14f3bbc74"></a><!-- doxytag: member="dr_tools.h::dr_close_file" ref="c25b305e0be9f6c09f9761b14f3bbc74" args="(file_t f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_close_file           </td>
          <td>(</td>
          <td class="paramtype">file_t&nbsp;</td>
          <td class="paramname"> <em>f</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Closes file <code>f</code>. 
</div>
</div><p>
<a class="anchor" name="8c99a2d79ed312cd852d57e975601adc"></a><!-- doxytag: member="dr_tools.h::dr_copy_module_data" ref="8c99a2d79ed312cd852d57e975601adc" args="(const module_data_t *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__module__data__t.html">module_data_t</a>* dr_copy_module_data           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__module__data__t.html">module_data_t</a> *&nbsp;</td>
          <td class="paramname"> <em>data</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Makes a copy of <code>data</code>. Copy must be freed with <a class="el" href="dr__tools_8h.html#d72ba1e8b98c8e01f2c28ef2e4d3e16e">dr_free_module_data()</a>. Useful for making persistent copies of module_data_t's received as part of image load and unload event callbacks. 
</div>
</div><p>
<a class="anchor" name="c6b80b83502ff13d4674b13e7b30b555"></a><!-- doxytag: member="dr_tools.h::dr_create_client_thread" ref="c6b80b83502ff13d4674b13e7b30b555" args="(void(*func)(void *param), void *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_create_client_thread           </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *param)&nbsp;</td>
          <td class="paramname"> <em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>arg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a new thread that is marked as a non-application thread (i.e., DR will let it run natively and not execute its code from the code cache). The thread will terminate automatically simply by returning from <code>func</code>; if running when the application terminates its last thread, the client thread will also terminate when DR shuts the process down.<p>
Init and exit events will not be raised for this thread (instead simply place init and exit code in <code>func</code>).<p>
The new client thread has a drcontext that can be used for thread-private heap allocations. It has a stack of the same size as the DR stack used by application threads.<p>
On Linux, this thread is guaranteed to have its own private itimer if <a class="el" href="dr__tools_8h.html#9191c67a267070ed51289d7192f986aa">dr_set_itimer()</a> is called from it. However this does mean it will have its own process id.<p>
A client thread should refrain from spending most of its time in calls to other libraries or making blocking or long-running system calls as such actions may incur performance or correctness problems with DR's synchronization engine, which needs to be able to suspend client threads at safe points and cannot determine whether the aforementioned actions are safe for suspension. Calling <a class="el" href="dr__tools_8h.html#f154e498d8b185931ef970676cb65351">dr_sleep()</a>, <a class="el" href="dr__tools_8h.html#c262422c1e5e487113176bd4193c387f">dr_thread_yield()</a>, <a class="el" href="dr__tools_8h.html#d444a204e7ca45f9965cfe973470375a">dr_messagebox()</a>, or using DR's locks are safe.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Thread creation via this routine is not yet fully transparent: on Windows, the thread will show up in the list of application threads if the operating system is queried about threads. The thread will not trigger a DLL_THREAD_ATTACH message. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1ee2651cad7bafe65f3df7d4aeb82120"></a><!-- doxytag: member="dr_tools.h::dr_create_dir" ref="1ee2651cad7bafe65f3df7d4aeb82120" args="(const char *fname)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_create_dir           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fname</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a new directory. Fails if the directory already exists or if it can't be created. 
</div>
</div><p>
<a class="anchor" name="fa5ea6649e644074ca55f456c89264e8"></a><!-- doxytag: member="dr_tools.h::dr_delay_flush_region" ref="fa5ea6649e644074ca55f456c89264e8" args="(app_pc start, size_t size, uint flush_id, void(*flush_completion_callback)(int flush_id))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_delay_flush_region           </td>
          <td>(</td>
          <td class="paramtype">app_pc&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>flush_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(int flush_id)&nbsp;</td>
          <td class="paramname"> <em>flush_completion_callback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Request a flush of all fragments containing code from the region [<code>start</code>, <code>start</code> + <code>size</code>). The flush will be performed at the next safe point in time (usually before any new code is added to the cache after this routine is called). If <code>flush_completion_callback</code> is non-NULL, it will be called with the <code>flush_id</code> provided to this routine when the flush completes, after which no execution will occur out of the fragments flushed. Returns true if the flush was successfully queued.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd><a class="el" href="dr__tools_8h.html#be87d17869a51a66d59eecf459d71cc0">dr_flush_region()</a> and <a class="el" href="dr__tools_8h.html#56909cf76e4a71fca13731053ef48928">dr_unlink_flush_region()</a> can give stronger guarantees on when the flush will occur, but have more restrictions on use. <p>
Use <code>size</code> == 1 to flush fragments containing the instruction at address <code>start</code>. A flush of <code>size</code> == 0 is not allowed. <p>
As currently implemented there may be a performance penalty for requesting a <code>flush_completion_callback</code>; for most performant usage set <code>flush_completion_callback</code> to NULL. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7600cc31d68dc0e30ab91261d08836ed"></a><!-- doxytag: member="dr_tools.h::dr_delete_fragment" ref="7600cc31d68dc0e30ab91261d08836ed" args="(void *drcontext, void *tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_delete_fragment           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>tag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deletes the fragment with tag <code>tag</code>. This routine is only valid with the -thread_private option; it deletes the fragment in the current thread only. After deletion, the existing fragment is allowed to complete execution. For example, a clean call deleting the currently executing fragment will safely return to the existing code. Subsequent executions will cause DynamoRIO to reconstruct the fragment, and therefore call the appropriate fragment-creation event hook, if registered.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This routine supports deletion for the current thread only. <code>drcontext</code> must be from the current thread and must be the drcontext used to create the instruction list.</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>false if the fragment does not exist and true otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="02f86a68a105442a029baa05a1af9d57"></a><!-- doxytag: member="dr_tools.h::dr_directory_exists" ref="02f86a68a105442a029baa05a1af9d57" args="(const char *fname)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_directory_exists           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fname</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks for the existence of a directory. <dl class="note" compact><dt><b>Note:</b></dt><dd>Windows only. </dd></dl>

</div>
</div><p>
<a class="anchor" name="66ef4b43d78d787c7622569d30717051"></a><!-- doxytag: member="dr_tools.h::dr_dup_file_handle" ref="66ef4b43d78d787c7622569d30717051" args="(file_t f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">file_t dr_dup_file_handle           </td>
          <td>(</td>
          <td class="paramtype">file_t&nbsp;</td>
          <td class="paramname"> <em>f</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a new copy of the file handle <code>f</code>. Returns INVALID_FILE on error. 
</div>
</div><p>
<a class="anchor" name="f471633d0954d80c09ca6c2bfe40475b"></a><!-- doxytag: member="dr_tools.h::dr_file_exists" ref="f471633d0954d80c09ca6c2bfe40475b" args="(const char *fname)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_file_exists           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fname</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks the existence of a file. <dl class="note" compact><dt><b>Note:</b></dt><dd>Windows only. </dd></dl>

</div>
</div><p>
<a class="anchor" name="18c2c9d68ceceef8c6455b06502667ee"></a><!-- doxytag: member="dr_tools.h::dr_file_seek" ref="18c2c9d68ceceef8c6455b06502667ee" args="(file_t f, int64 offset, int origin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_file_seek           </td>
          <td>(</td>
          <td class="paramtype">file_t&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>origin</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the current file position for file <code>f</code> to <code>offset</code> bytes from the specified origin, where <code>origin</code> is one of the DR_SEEK_* values. Returns true if successful. 
</div>
</div><p>
<a class="anchor" name="1fc1d26f3050d6f361e7b07f98c7e82d"></a><!-- doxytag: member="dr_tools.h::dr_file_tell" ref="1fc1d26f3050d6f361e7b07f98c7e82d" args="(file_t f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64 dr_file_tell           </td>
          <td>(</td>
          <td class="paramtype">file_t&nbsp;</td>
          <td class="paramname"> <em>f</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the current position for the file <code>f</code> in bytes from the start of the file. Returns -1 on an error. 
</div>
</div><p>
<a class="anchor" name="e51098d1c742e3189a197db0c212eaa9"></a><!-- doxytag: member="dr_tools.h::dr_flush_file" ref="e51098d1c742e3189a197db0c212eaa9" args="(file_t f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_flush_file           </td>
          <td>(</td>
          <td class="paramtype">file_t&nbsp;</td>
          <td class="paramname"> <em>f</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Flushes any buffers for file <code>f</code>. 
</div>
</div><p>
<a class="anchor" name="be87d17869a51a66d59eecf459d71cc0"></a><!-- doxytag: member="dr_tools.h::dr_flush_region" ref="be87d17869a51a66d59eecf459d71cc0" args="(app_pc start, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_flush_region           </td>
          <td>(</td>
          <td class="paramtype">app_pc&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Flush all fragments containing any code from the region [<code>start</code>, <code>start</code> + <code>size</code>). Once this routine returns no execution will occur out of the fragments flushed. This routine may only be called during a clean call from the cache or from a nudge event handler. It may not be called from any other event callback. No locks can held when calling this routine. If called from a clean call, caller can NOT return to the cache (the fragment that was called out of may have been flushed even if it doesn't apparently overlap the flushed region). Instead the caller must call <a class="el" href="dr__ir__utils_8h.html#86554ab412927d0a4f1b90d72f64a858">dr_redirect_execution()</a> after this routine to continue execution. Returns true if successful.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This routine may not be called from any registered event callback other than the nudge event; clean calls out of the cache may call this routine. <p>
If called from a clean call, caller must continue execution by calling <a class="el" href="dr__ir__utils_8h.html#86554ab412927d0a4f1b90d72f64a858">dr_redirect_execution()</a> after this routine, as the fragment containing the callout may have been flushed. The context and app_errno to use can be obtained via <a class="el" href="dr__ir__utils_8h.html#d78c531d7527907652e770960c07af38">dr_get_mcontext()</a> with the exception of the pc to continue at which must be passed as an argument to the callout (see <a class="el" href="dr__ir__instr_8h.html#57dbc129ab88dfdcf49f1105eba394a7">instr_get_app_pc()</a>) or otherwise determined. <p>
This routine may not be called while any locks are held that could block a thread processing a registered event callback or cache callout. <p>
<a class="el" href="dr__tools_8h.html#fa5ea6649e644074ca55f456c89264e8">dr_delay_flush_region()</a> has fewer restrictions on use, but is less synchronous. <p>
Use <code>size</code> == 1 to flush fragments containing the instruction at address <code>start</code>. A flush of <code>size</code> == 0 is not allowed. <p>
As currently implemented, <a class="el" href="dr__tools_8h.html#fa5ea6649e644074ca55f456c89264e8">dr_delay_flush_region()</a> with no completion callback routine specified can be substantially more performant. </dd></dl>

</div>
</div><p>
<a class="anchor" name="fe7ede5b10890505021ac03e8f9ba97f"></a><!-- doxytag: member="dr_tools.h::dr_fprintf" ref="fe7ede5b10890505021ac03e8f9ba97f" args="(file_t f, const char *fmt,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_fprintf           </td>
          <td>(</td>
          <td class="paramtype">file_t&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Printing to a file that won't interfere with the application's own printing. Currently non-buffered. <dl class="note" compact><dt><b>Note:</b></dt><dd>On Windows, this routine is not able to print to STDOUT or STDERR in the cmd window (issue 222). <p>
On Windows, this routine does not support printing floating point values. Use <a class="el" href="dr__tools_8h.html#b0c5f2529d9c076b5b0b0e92a70834b7">dr_snprintf()</a> instead. <p>
If the data to be printed is large it will be truncated to an internal buffer size. Use <a class="el" href="dr__tools_8h.html#eddf708cc2271dc50209b3e78e1d23fb">dr_write_file()</a> to print large buffers. <p>
On Linux this routine does not check for errors like EINTR. Use <a class="el" href="dr__tools_8h.html#eddf708cc2271dc50209b3e78e1d23fb">dr_write_file()</a> if that is a concern. </dd></dl>

</div>
</div><p>
<a class="anchor" name="724aa7f7e87a604071fffa0a01925bf0"></a><!-- doxytag: member="dr_tools.h::dr_fragment_app_pc" ref="724aa7f7e87a604071fffa0a01925bf0" args="(void *tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">app_pc dr_fragment_app_pc           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>tag</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the application PC of a fragment with tag <code>tag</code>. 
</div>
</div><p>
<a class="anchor" name="775fdf1d5a55b5fbca094a4d2f18d28f"></a><!-- doxytag: member="dr_tools.h::dr_fragment_exists_at" ref="775fdf1d5a55b5fbca094a4d2f18d28f" args="(void *drcontext, void *tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_fragment_exists_at           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>tag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns whether or not there is a fragment in code cache with tag <code>tag</code>. 
</div>
</div><p>
<a class="anchor" name="cfe1f6436b234406bde1970ecfa614b5"></a><!-- doxytag: member="dr_tools.h::dr_fragment_size" ref="cfe1f6436b234406bde1970ecfa614b5" args="(void *drcontext, void *tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint dr_fragment_size           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>tag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Looks up the fragment with tag <code>tag</code>. If not found, returns 0. If found, returns the total size occupied in the cache by the fragment. 
</div>
</div><p>
<a class="anchor" name="d72ba1e8b98c8e01f2c28ef2e4d3e16e"></a><!-- doxytag: member="dr_tools.h::dr_free_module_data" ref="d72ba1e8b98c8e01f2c28ef2e4d3e16e" args="(module_data_t *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_free_module_data           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__module__data__t.html">module_data_t</a> *&nbsp;</td>
          <td class="paramname"> <em>data</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Frees a module_data_t returned by <a class="el" href="dr__tools_8h.html#9d49edb3a7b59f5d817afaa8fc0f1ef9">dr_module_iterator_next()</a>, <a class="el" href="dr__tools_8h.html#4892d089da710e952a23055bd7db38af">dr_lookup_module()</a>, <a class="el" href="dr__tools_8h.html#ddd653edd3322cfb025ef8bdc6ae1060">dr_lookup_module_by_name()</a>, or <a class="el" href="dr__tools_8h.html#8c99a2d79ed312cd852d57e975601adc">dr_copy_module_data()</a>. <dl class="note" compact><dt><b>Note:</b></dt><dd>Should NOT be used with a module_data_t obtained as part of a module load or unload event. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ace5e8084f523fd25871b31463c7ecda"></a><!-- doxytag: member="dr_tools.h::dr_get_application_name" ref="ace5e8084f523fd25871b31463c7ecda" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* dr_get_application_name           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the image name (without path) of the current application. 
</div>
</div><p>
<a class="anchor" name="fb7d403eb032bd14ae78807ae3d59ea0"></a><!-- doxytag: member="dr_tools.h::dr_get_client_path" ref="fb7d403eb032bd14ae78807ae3d59ea0" args="(client_id_t client_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* dr_get_client_path           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#68540a70b4f8150a4fe6dcec91bf8825">client_id_t</a>&nbsp;</td>
          <td class="paramname"> <em>client_id</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the client library name and path that were originally specified to load the library. If the resulting string is longer than <a class="el" href="dr__defines_8h.html#95c7b582d53e0a376f2a0e89323b2a7b">MAXIMUM_PATH</a> it will be truncated. <code>client_id</code> is the client ID passed to a client's <a class="el" href="dr__api_8h.html#20a4dc9da7f6bb9121e30bb3570c6961">dr_init()</a> function. 
</div>
</div><p>
<a class="anchor" name="13217cc252506b06184c7c72adedf26c"></a><!-- doxytag: member="dr_tools.h::dr_get_current_drcontext" ref="13217cc252506b06184c7c72adedf26c" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* dr_get_current_drcontext           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the DR context of the current thread. 
</div>
</div><p>
<a class="anchor" name="b5cd85ea911bd99dedbd8d05796260bc"></a><!-- doxytag: member="dr_tools.h::dr_get_itimer" ref="b5cd85ea911bd99dedbd8d05796260bc" args="(int which)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint dr_get_itimer           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>which</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If an interval timer is already installed in the itimer sharing group that contains the calling thread, returns its frequency. Else returns 0.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>which</em>&nbsp;</td><td>Must be one of ITIMER_REAL, ITIMER_VIRTUAL, or ITIMER_PROF</td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Linux-only. </dd></dl>

</div>
</div><p>
<a class="anchor" name="fd7e9d485a84aa147e0ec0e75ad6d962"></a><!-- doxytag: member="dr_tools.h::dr_get_logfile" ref="fd7e9d485a84aa147e0ec0e75ad6d962" args="(void *drcontext)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">file_t dr_get_logfile           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the log file for the thread with drcontext <code>drcontext</code>. If <code>drcontext</code> is NULL, returns the main log file. 
</div>
</div><p>
<a class="anchor" name="4b187636a3fc9ba7964ae11a7fd30fb6"></a><!-- doxytag: member="dr_tools.h::dr_get_milliseconds" ref="4b187636a3fc9ba7964ae11a7fd30fb6" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64 dr_get_milliseconds           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
On Linux, returns the number of milliseconds since the Epoch (Jan 1, 1970). On Windows, returns the number of milliseconds since Jan 1, 1600 (this is the current UTC time). 
</div>
</div><p>
<a class="anchor" name="10831623706378cfc3082c0e27e31c4c"></a><!-- doxytag: member="dr_tools.h::dr_get_options" ref="10831623706378cfc3082c0e27e31c4c" args="(client_id_t client_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* dr_get_options           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#68540a70b4f8150a4fe6dcec91bf8825">client_id_t</a>&nbsp;</td>
          <td class="paramname"> <em>client_id</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the client-specific option string specified at client registration. <code>client_id</code> is the client ID passed to <a class="el" href="dr__api_8h.html#20a4dc9da7f6bb9121e30bb3570c6961">dr_init()</a>. 
</div>
</div><p>
<a class="anchor" name="11575b203a0558f5df50126ff04c4598"></a><!-- doxytag: member="dr_tools.h::dr_get_parent_id" ref="11575b203a0558f5df50126ff04c4598" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">process_id_t dr_get_parent_id           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the process id of the parent of the current process. <dl class="note" compact><dt><b>Note:</b></dt><dd>Linux only. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8da7923ecc4e020e31442bcc8d9f8d3e"></a><!-- doxytag: member="dr_tools.h::dr_get_proc_address" ref="8da7923ecc4e020e31442bcc8d9f8d3e" args="(module_handle_t lib, const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">generic_func_t dr_get_proc_address           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__tools_8h.html#b855db7dce02dc18831280f19df840cf">module_handle_t</a>&nbsp;</td>
          <td class="paramname"> <em>lib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the entry point of the exported function with the given name in the module with the given base. Returns NULL on failure. <dl class="note" compact><dt><b>Note:</b></dt><dd>On Linux this ignores symbol preemption by other modules and only examines the specified module. <p>
On Linux, in order to handle indirect code objects, use <a class="el" href="dr__tools_8h.html#f1a068ad89408abbcfba026706810211">dr_get_proc_address_ex()</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f1a068ad89408abbcfba026706810211"></a><!-- doxytag: member="dr_tools.h::dr_get_proc_address_ex" ref="f1a068ad89408abbcfba026706810211" args="(module_handle_t lib, const char *name, dr_export_info_t *info OUT, size_t info_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_get_proc_address_ex           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__tools_8h.html#b855db7dce02dc18831280f19df840cf">module_handle_t</a>&nbsp;</td>
          <td class="paramname"> <em>lib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__dr__export__info__t.html">dr_export_info_t</a> *info&nbsp;</td>
          <td class="paramname"> <em>OUT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>info_len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns information in <code>info</code> about the symbol <code>name</code> exported by the module <code>lib</code>. Returns false if the symbol is not found. <dl class="note" compact><dt><b>Note:</b></dt><dd>On Linux this ignores symbol preemption by other modules and only examines the specified module. </dd></dl>

</div>
</div><p>
<a class="anchor" name="83b3658ca78e6b7adc81c57691f0fe50"></a><!-- doxytag: member="dr_tools.h::dr_get_process_id" ref="83b3658ca78e6b7adc81c57691f0fe50" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">process_id_t dr_get_process_id           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the process id of the current process. 
</div>
</div><p>
<a class="anchor" name="20dccb3e2b03e8f408b2a340c70a28e2"></a><!-- doxytag: member="dr_tools.h::dr_get_stderr_file" ref="20dccb3e2b03e8f408b2a340c70a28e2" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">file_t dr_get_stderr_file           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a handle to stderr. 
</div>
</div><p>
<a class="anchor" name="ed162d7ad949b05fe8232771eaeca6a9"></a><!-- doxytag: member="dr_tools.h::dr_get_stdin_file" ref="ed162d7ad949b05fe8232771eaeca6a9" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">file_t dr_get_stdin_file           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a handle to stdin. 
</div>
</div><p>
<a class="anchor" name="0353e78f517dc281de22539682d9e6d9"></a><!-- doxytag: member="dr_tools.h::dr_get_stdout_file" ref="0353e78f517dc281de22539682d9e6d9" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">file_t dr_get_stdout_file           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a handle to stdout. 
</div>
</div><p>
<a class="anchor" name="3980d703cc13379a6b57396a7901b1d1"></a><!-- doxytag: member="dr_tools.h::dr_get_thread_id" ref="3980d703cc13379a6b57396a7901b1d1" args="(void *drcontext)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">thread_id_t dr_get_thread_id           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the thread id of the thread with drcontext <code>drcontext</code>. 
</div>
</div><p>
<a class="anchor" name="e517c4817d67af6ad92b8f1d7694080a"></a><!-- doxytag: member="dr_tools.h::dr_get_time" ref="e517c4817d67af6ad92b8f1d7694080a" args="(dr_time_t *time)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_get_time           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdr__time__t.html">dr_time_t</a> *&nbsp;</td>
          <td class="paramname"> <em>time</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the current time. 
</div>
</div><p>
<a class="anchor" name="787aff5df1ded3de8a7ce9f3efef0594"></a><!-- doxytag: member="dr_tools.h::dr_get_tls_field" ref="787aff5df1ded3de8a7ce9f3efef0594" args="(void *drcontext)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* dr_get_tls_field           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the user-controlled thread-local-storage field. To generate an instruction sequence that reads the drcontext field inline in the code cache, use <a class="el" href="dr__ir__utils_8h.html#3831354cc7402d68719d8055fb3e9931">dr_insert_read_tls_field()</a>. 
</div>
</div><p>
<a class="anchor" name="60faa40f7e8c819c34fd25cb367c5473"></a><!-- doxytag: member="dr_tools.h::dr_global_alloc" ref="60faa40f7e8c819c34fd25cb367c5473" args="(size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* dr_global_alloc           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allocates <code>size</code> bytes of memory from DR's global memory pool. 
</div>
</div><p>
<a class="anchor" name="ce8794210449c50fb4d411ad74a8dec1"></a><!-- doxytag: member="dr_tools.h::dr_global_free" ref="ce8794210449c50fb4d411ad74a8dec1" args="(void *mem, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_global_free           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Frees memory allocated by <a class="el" href="dr__tools_8h.html#60faa40f7e8c819c34fd25cb367c5473">dr_global_alloc()</a>. <code>size</code> must be the same as that passed to <a class="el" href="dr__tools_8h.html#60faa40f7e8c819c34fd25cb367c5473">dr_global_alloc()</a>. 
</div>
</div><p>
<a class="anchor" name="f91a810b83f1173a5720a955c3d0fd4a"></a><!-- doxytag: member="dr_tools.h::dr_is_notify_on" ref="f91a810b83f1173a5720a955c3d0fd4a" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_is_notify_on           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true iff the -stderr_mask runtime option is non-zero, indicating that the user wants notification messages printed to stderr. 
</div>
</div><p>
<a class="anchor" name="c5804006579a63b49827169d3ffbebc8"></a><!-- doxytag: member="dr_tools.h::dr_is_wow64" ref="c5804006579a63b49827169d3ffbebc8" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_is_wow64           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if this process is a 32-bit process operating on a 64-bit Windows kernel, known as Windows-On-Windows-64, or WOW64. Returns false otherwise. 
</div>
</div><p>
<a class="anchor" name="332a14861f12823994465e8c9b6a3015"></a><!-- doxytag: member="dr_tools.h::dr_log" ref="332a14861f12823994465e8c9b6a3015" args="(void *drcontext, uint mask, uint level, const char *fmt,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_log           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes to DR's log file for the thread with drcontext <code>drcontext</code> if the current loglevel is &gt;= <code>level</code> and the current <code>logmask</code> &amp; <code>mask</code> != 0. The mask constants are below. Logging is disabled for the release build. If <code>drcontext</code> is NULL, writes to the main log file. 
</div>
</div><p>
<a class="anchor" name="4892d089da710e952a23055bd7db38af"></a><!-- doxytag: member="dr_tools.h::dr_lookup_module" ref="4892d089da710e952a23055bd7db38af" args="(byte *pc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__module__data__t.html">module_data_t</a>* dr_lookup_module           </td>
          <td>(</td>
          <td class="paramtype">byte *&nbsp;</td>
          <td class="paramname"> <em>pc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Looks up the module containing <code>pc</code>. If a module containing <code>pc</code> is found returns a module_data_t describing that module else returns NULL. Can be used to obtain a module_handle_t for <a class="el" href="dr__tools_8h.html#c520aa05555ecbf9e525de582d4baa8c">dr_lookup_module_section()</a>. <dl class="note" compact><dt><b>Note:</b></dt><dd>Returned module_data_t must be freed with <a class="el" href="dr__tools_8h.html#d72ba1e8b98c8e01f2c28ef2e4d3e16e">dr_free_module_data()</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ddd653edd3322cfb025ef8bdc6ae1060"></a><!-- doxytag: member="dr_tools.h::dr_lookup_module_by_name" ref="ddd653edd3322cfb025ef8bdc6ae1060" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__module__data__t.html">module_data_t</a>* dr_lookup_module_by_name           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Looks up the module with name <code>name</code> ignoring case. If an exact name match is found returns a module_data_t describing that module else returns NULL. User must call <a class="el" href="dr__tools_8h.html#d72ba1e8b98c8e01f2c28ef2e4d3e16e">dr_free_module_data()</a> on the returned module_data_t once finished. Can be used to obtain a module_handle_t for <a class="el" href="dr__tools_8h.html#8da7923ecc4e020e31442bcc8d9f8d3e">dr_get_proc_address()</a>. <dl class="note" compact><dt><b>Note:</b></dt><dd>Returned module_data_t must be freed with <a class="el" href="dr__tools_8h.html#d72ba1e8b98c8e01f2c28ef2e4d3e16e">dr_free_module_data()</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c520aa05555ecbf9e525de582d4baa8c"></a><!-- doxytag: member="dr_tools.h::dr_lookup_module_section" ref="c520aa05555ecbf9e525de582d4baa8c" args="(module_handle_t lib, byte *pc, IMAGE_SECTION_HEADER *section_out)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_lookup_module_section           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__tools_8h.html#b855db7dce02dc18831280f19df840cf">module_handle_t</a>&nbsp;</td>
          <td class="paramname"> <em>lib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&nbsp;</td>
          <td class="paramname"> <em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IMAGE_SECTION_HEADER *&nbsp;</td>
          <td class="paramname"> <em>section_out</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns whether <code>pc</code> is within a section within the module in <code>section_found</code> and information about that section in <code>section_out</code>. <dl class="note" compact><dt><b>Note:</b></dt><dd>Not yet available on Linux. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9e262e93823dbc5914eca34540afbc07"></a><!-- doxytag: member="dr_tools.h::dr_mark_trace_head" ref="9e262e93823dbc5914eca34540afbc07" args="(void *drcontext, void *tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_mark_trace_head           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>tag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Marks the fragment associated with tag <code>tag</code> as a trace head. The fragment need not exist yet -- once it is created it will be marked as a trace head.<p>
DR associates a counter with a trace head and once it passes the -hot_threshold parameter, DR begins building a trace. Before each fragment is added to the trace, DR calls the client's end_trace callback to determine whether to end the trace. (The callback will be called both for standard DR traces and for client-defined traces.)<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Some fragments are unsuitable for trace heads. DR will ignore attempts to mark such fragments as trace heads and will return false. If the client marks a fragment that doesn't exist yet as a trace head and DR later determines that the fragment is unsuitable for a trace head it will unmark the fragment as a trace head without notifying the client.<p>
Some fragments' notion of trace heads is dependent on which previous block targets them. For these fragments, calling this routine will only mark as a trace head for targets from the same memory region.</dd></dl>
Returns true if the target fragment is marked as a trace head. 
</div>
</div><p>
<a class="anchor" name="813f98fcc06c0a1198262b744e98eced"></a><!-- doxytag: member="dr_tools.h::dr_memory_is_dr_internal" ref="813f98fcc06c0a1198262b744e98eced" args="(const byte *pc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_memory_is_dr_internal           </td>
          <td>(</td>
          <td class="paramtype">const byte *&nbsp;</td>
          <td class="paramname"> <em>pc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true iff pc is memory allocated by DR for its own purposes, and would not exist if the application were run natively. 
</div>
</div><p>
<a class="anchor" name="2a67b03d64626f3d0a78b64bf096ed25"></a><!-- doxytag: member="dr_tools.h::dr_memory_is_in_client" ref="2a67b03d64626f3d0a78b64bf096ed25" args="(const byte *pc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_memory_is_in_client           </td>
          <td>(</td>
          <td class="paramtype">const byte *&nbsp;</td>
          <td class="paramname"> <em>pc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true iff pc is located inside a client library. 
</div>
</div><p>
<a class="anchor" name="a1dd6ff985f0b21deada31ea33485737"></a><!-- doxytag: member="dr_tools.h::dr_memory_is_readable" ref="a1dd6ff985f0b21deada31ea33485737" args="(const byte *pc, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_memory_is_readable           </td>
          <td>(</td>
          <td class="paramtype">const byte *&nbsp;</td>
          <td class="paramname"> <em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks to see that all bytes with addresses in the range [<code>pc</code>, <code>pc</code> + <code>size</code> - 1] are readable and that reading from that range won't generate an exception (see also <a class="el" href="dr__tools_8h.html#6a94558696130c76f34dcdac0ce50c47">dr_safe_read()</a>). <dl class="note" compact><dt><b>Note:</b></dt><dd>Nothing guarantees that the memory will stay readable for any length of time. <p>
On Linux, especially if the app is in the middle of loading a library and has not properly set up the .bss yet, a page that seems readable can still generate SIGBUS if beyond the end of an mmapped file. Use <a class="el" href="dr__tools_8h.html#6a94558696130c76f34dcdac0ce50c47">dr_safe_read()</a> to avoid such problems. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2c3a19a0dc146c1e5b6747e89bacfb55"></a><!-- doxytag: member="dr_tools.h::dr_memory_protect" ref="2c3a19a0dc146c1e5b6747e89bacfb55" args="(void *base, size_t size, uint new_prot)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_memory_protect           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>new_prot</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Modifies the memory protections of the region from <code>start</code> through <code>start</code> + <code>size</code>. Modification of memory allocated by DR or of the DR or client libraries themselves is allowed under the assumption that the client knows what it is doing. Modification of the ntdll.dll library on Windows is not allowed. Returns true if successful. 
</div>
</div><p>
<a class="anchor" name="d444a204e7ca45f9965cfe973470375a"></a><!-- doxytag: member="dr_tools.h::dr_messagebox" ref="d444a204e7ca45f9965cfe973470375a" args="(const char *fmt,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_messagebox           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Displays a message in a pop-up window. <dl class="note" compact><dt><b>Note:</b></dt><dd>Windows only. <p>
On Windows Vista most Windows services are unable to display message boxes. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1702cf25e24e722d9441f92c41fac33e"></a><!-- doxytag: member="dr_tools.h::dr_module_iterator_hasnext" ref="1702cf25e24e722d9441f92c41fac33e" args="(dr_module_iterator_t *mi)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_module_iterator_hasnext           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__tools_8h.html#fd116a488df74505f27ff57cd49b9f88">dr_module_iterator_t</a> *&nbsp;</td>
          <td class="paramname"> <em>mi</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if there is another loaded module in the iterator. 
</div>
</div><p>
<a class="anchor" name="9d49edb3a7b59f5d817afaa8fc0f1ef9"></a><!-- doxytag: member="dr_tools.h::dr_module_iterator_next" ref="9d49edb3a7b59f5d817afaa8fc0f1ef9" args="(dr_module_iterator_t *mi)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__module__data__t.html">module_data_t</a>* dr_module_iterator_next           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__tools_8h.html#fd116a488df74505f27ff57cd49b9f88">dr_module_iterator_t</a> *&nbsp;</td>
          <td class="paramname"> <em>mi</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the module_data_t for the next loaded module in the iterator. User must call <a class="el" href="dr__tools_8h.html#d72ba1e8b98c8e01f2c28ef2e4d3e16e">dr_free_module_data()</a> on the returned module_data_t once finished. <dl class="note" compact><dt><b>Note:</b></dt><dd>Returned module_data_t must be freed with <a class="el" href="dr__tools_8h.html#d72ba1e8b98c8e01f2c28ef2e4d3e16e">dr_free_module_data()</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="3310b1bfc22da285af72b1a4a9d10945"></a><!-- doxytag: member="dr_tools.h::dr_module_iterator_start" ref="3310b1bfc22da285af72b1a4a9d10945" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="dr__tools_8h.html#fd116a488df74505f27ff57cd49b9f88">dr_module_iterator_t</a>* dr_module_iterator_start           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize a new module iterator. The returned module iterator contains a snapshot of the modules loaded at the time it was created. Use <a class="el" href="dr__tools_8h.html#1702cf25e24e722d9441f92c41fac33e">dr_module_iterator_hasnext()</a> and <a class="el" href="dr__tools_8h.html#9d49edb3a7b59f5d817afaa8fc0f1ef9">dr_module_iterator_next()</a> to walk the loaded modules. Call <a class="el" href="dr__tools_8h.html#15134844f1dd3e914c0da59c65cb3a8d">dr_module_iterator_stop()</a> when finished to release the iterator. <dl class="note" compact><dt><b>Note:</b></dt><dd>The iterator does not prevent modules from being loaded or unloaded while the iterator is being walked. </dd></dl>

</div>
</div><p>
<a class="anchor" name="15134844f1dd3e914c0da59c65cb3a8d"></a><!-- doxytag: member="dr_tools.h::dr_module_iterator_stop" ref="15134844f1dd3e914c0da59c65cb3a8d" args="(dr_module_iterator_t *mi)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_module_iterator_stop           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__tools_8h.html#fd116a488df74505f27ff57cd49b9f88">dr_module_iterator_t</a> *&nbsp;</td>
          <td class="paramname"> <em>mi</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
User should call this routine to free the module iterator. 
</div>
</div><p>
<a class="anchor" name="082fe71b00688310237fbc2e027c4388"></a><!-- doxytag: member="dr_tools.h::dr_module_preferred_name" ref="082fe71b00688310237fbc2e027c4388" args="(const module_data_t *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* dr_module_preferred_name           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__module__data__t.html">module_data_t</a> *&nbsp;</td>
          <td class="paramname"> <em>data</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the preferred name for the module described by <code>data</code> from <code>data-&gt;module_names</code>. 
</div>
</div><p>
<a class="anchor" name="55da3fd48670f25ec69ee5daf5975de5"></a><!-- doxytag: member="dr_tools.h::dr_mutex_create" ref="55da3fd48670f25ec69ee5daf5975de5" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* dr_mutex_create           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initializes a mutex.<p>
Warning: there are restrictions on when DR-provided mutexes, and locks in general, can be held by a client: no lock should be held while application code is executing in the code cache. Locks can be used while inside client code reached from clean calls out of the code cache, but they must be released before returning to the cache. Failing to follow these restrictions can lead to deadlocks. 
</div>
</div><p>
<a class="anchor" name="aab148b68bc8e1479a14c175cbf42fc0"></a><!-- doxytag: member="dr_tools.h::dr_mutex_destroy" ref="aab148b68bc8e1479a14c175cbf42fc0" args="(void *mutex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_mutex_destroy           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>mutex</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deletes <code>mutex</code>. 
</div>
</div><p>
<a class="anchor" name="04beaefb3e0be6bd0dac39f76398ec1e"></a><!-- doxytag: member="dr_tools.h::dr_mutex_lock" ref="04beaefb3e0be6bd0dac39f76398ec1e" args="(void *mutex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_mutex_lock           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>mutex</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Locks <code>mutex</code>. Waits until the mutex is successfully held. 
</div>
</div><p>
<a class="anchor" name="6b2ae4a29e2dc18dde2a6f01f26cbe79"></a><!-- doxytag: member="dr_tools.h::dr_mutex_trylock" ref="6b2ae4a29e2dc18dde2a6f01f26cbe79" args="(void *mutex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_mutex_trylock           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>mutex</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tries once to lock <code>mutex</code>, returns whether or not successful. 
</div>
</div><p>
<a class="anchor" name="61a3a4ffffd0058a37211405fbb6ba51"></a><!-- doxytag: member="dr_tools.h::dr_mutex_unlock" ref="61a3a4ffffd0058a37211405fbb6ba51" args="(void *mutex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_mutex_unlock           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>mutex</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unlocks <code>mutex</code>. Asserts that mutex is currently locked. 
</div>
</div><p>
<a class="anchor" name="c32b5be072876c25a832d510efeba6e4"></a><!-- doxytag: member="dr_tools.h::dr_nonheap_alloc" ref="c32b5be072876c25a832d510efeba6e4" args="(size_t size, uint prot)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* dr_nonheap_alloc           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>prot</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allocates <code>size</code> bytes of memory as a separate allocation from DR's heap, allowing for separate protection. The <code>prot</code> protection should use the DR_MEMPROT_READ, DR_MEMPROT_WRITE, and DR_MEMPROT_EXEC bits. When creating a region to hold dynamically generated code, use this routine in order to create executable memory. 
</div>
</div><p>
<a class="anchor" name="401b819525f805d04e0a9560fdcfdf89"></a><!-- doxytag: member="dr_tools.h::dr_nonheap_free" ref="401b819525f805d04e0a9560fdcfdf89" args="(void *mem, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_nonheap_free           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Frees memory allocated by <a class="el" href="dr__tools_8h.html#c32b5be072876c25a832d510efeba6e4">dr_nonheap_alloc()</a>. <code>size</code> must be the same as that passed to <a class="el" href="dr__tools_8h.html#c32b5be072876c25a832d510efeba6e4">dr_nonheap_alloc()</a>. 
</div>
</div><p>
<a class="anchor" name="e3ae2190774a204af207602791a32cb6"></a><!-- doxytag: member="dr_tools.h::dr_open_file" ref="e3ae2190774a204af207602791a32cb6" args="(const char *fname, uint mode_flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">file_t dr_open_file           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>mode_flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Opens the file <code>fname</code>. On Windows, <code>fname</code> must be an absolute path. If no such file exists then one is created. The file access mode is set by the <code>mode_flags</code> argument which is drawn from the DR_FILE_* defines ORed together. Returns INVALID_FILE if unsuccessful.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>No more then one write mode flag can be specified.<p>
DR does not hide files opened by clients from the application, to allow clients to open application files and other forms of interaction. Some applications close all file descriptors, and clients may want to watch for the close system call and turn it into a nop (e.g., return -EBADF and not execute it on Linux) if targeting a client-owned filed. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ecb77c99028d913a72c6aaeef48db785"></a><!-- doxytag: member="dr_tools.h::dr_print_instr" ref="ecb77c99028d913a72c6aaeef48db785" args="(void *drcontext, file_t f, instr_t *instr, const char *msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_print_instr           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">file_t&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>msg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Prints <code>msg</code> followed by the instruction <code>instr</code> to file <code>f</code>. 
</div>
</div><p>
<a class="anchor" name="5902fa16202c9c42d96c755e9412d372"></a><!-- doxytag: member="dr_tools.h::dr_print_opnd" ref="5902fa16202c9c42d96c755e9412d372" args="(void *drcontext, file_t f, opnd_t opnd, const char *msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_print_opnd           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">file_t&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td>
          <td class="paramname"> <em>opnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>msg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Prints <code>msg</code> followed by the operand <code>opnd</code> to file <code>f</code>. 
</div>
</div><p>
<a class="anchor" name="bad2eddb3786e3e909ff36da39b7e31e"></a><!-- doxytag: member="dr_tools.h::dr_printf" ref="bad2eddb3786e3e909ff36da39b7e31e" args="(const char *fmt,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_printf           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Stdout printing that won't interfere with the application's own printing. Currently non-buffered. <dl class="note" compact><dt><b>Note:</b></dt><dd>On Windows, this routine is not able to print to the cmd window (issue 222). <p>
On Windows, this routine does not support printing floating point values. Use <a class="el" href="dr__tools_8h.html#b0c5f2529d9c076b5b0b0e92a70834b7">dr_snprintf()</a> instead. <p>
If the data to be printed is large it will be truncated to an internal buffer size. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d158d2822dd8bb9caa9604d84b666bfa"></a><!-- doxytag: member="dr_tools.h::dr_query_memory" ref="d158d2822dd8bb9caa9604d84b666bfa" args="(const byte *pc, byte **base_pc, size_t *size, uint *prot)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_query_memory           </td>
          <td>(</td>
          <td class="paramtype">const byte *&nbsp;</td>
          <td class="paramname"> <em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte **&nbsp;</td>
          <td class="paramname"> <em>base_pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&nbsp;</td>
          <td class="paramname"> <em>prot</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
An os neutral method for querying a memory address. Returns true iff a memory region containing <code>pc</code> is found. If found additional information about the memory region is returned in the optional out arguments <code>base_pc</code>, <code>size</code>, and <code>prot</code> where <code>base_pc</code> is the start address of the memory region continaing <code>pc</code>, <code>size</code> is the size of said memory region and <code>prot</code> is an ORed combination of DR_MEMPROT_* flags describing its current protection.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>To examine only application memory, skip memory for which <a class="el" href="dr__tools_8h.html#813f98fcc06c0a1198262b744e98eced">dr_memory_is_dr_internal()</a> or <a class="el" href="dr__tools_8h.html#2a67b03d64626f3d0a78b64bf096ed25">dr_memory_is_in_client()</a> returns true. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5a6e4049f8accbc73ec5dbaf0deb25a7"></a><!-- doxytag: member="dr_tools.h::dr_query_memory_ex" ref="5a6e4049f8accbc73ec5dbaf0deb25a7" args="(const byte *pc, OUT dr_mem_info_t *info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_query_memory_ex           </td>
          <td>(</td>
          <td class="paramtype">const byte *&nbsp;</td>
          <td class="paramname"> <em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT <a class="el" href="struct__dr__mem__info__t.html">dr_mem_info_t</a> *&nbsp;</td>
          <td class="paramname"> <em>info</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Provides additional information beyond <a class="el" href="dr__tools_8h.html#d158d2822dd8bb9caa9604d84b666bfa">dr_query_memory()</a>. Returns true if it was able to obtain information (including about free regions) and sets the fields of <code>info</code>. This routine can be used to iterate over the entire address space. Returns false on failure.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>To examine only application memory, skip memory for which <a class="el" href="dr__tools_8h.html#813f98fcc06c0a1198262b744e98eced">dr_memory_is_dr_internal()</a> returns true. </dd></dl>

</div>
</div><p>
<a class="anchor" name="95b53d79cae021a473c39f3b2662323f"></a><!-- doxytag: member="dr_tools.h::dr_raw_tls_calloc" ref="95b53d79cae021a473c39f3b2662323f" args="(OUT reg_id_t *segment_register, OUT uint *offset, IN uint num_slots, IN uint alignment)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_raw_tls_calloc           </td>
          <td>(</td>
          <td class="paramtype">OUT reg_id_t *&nbsp;</td>
          <td class="paramname"> <em>segment_register</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT uint *&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN uint&nbsp;</td>
          <td class="paramname"> <em>num_slots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN uint&nbsp;</td>
          <td class="paramname"> <em>alignment</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allocates <code>num_slots</code> contiguous thread-local storage slots that can be directly accessed via an offset from <code>segment_register</code>. These slots will be initialized to 0 for each new thread. The slot offsets are [<code>offset</code> .. <code>offset</code> + (num_slots - 1)]. These slots are disjoint from the <a class="el" href="dr__ir__utils_8h.html#89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a> register spill slots and the client tls field (<a class="el" href="dr__tools_8h.html#787aff5df1ded3de8a7ce9f3efef0594">dr_get_tls_field()</a>). Returns whether or not the slots were successfully obtained.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>These slots are useful for thread-shared code caches. With thread-private caches, DR's memory pools are guaranteed to be reachable via absolute or rip-relative accesses from the code cache and client libraries.<p>
These slots are a limited resource. On Windows the slots are shared with the application and reserving even one slot can result in failure to initialize for certain applications. On Linux they are more plentiful and transparent but currently DR limits clients to no more than 64 slots. </dd></dl>

</div>
</div><p>
<a class="anchor" name="fc53219d019078a38c80ffa80d71829e"></a><!-- doxytag: member="dr_tools.h::dr_raw_tls_cfree" ref="fc53219d019078a38c80ffa80d71829e" args="(uint offset, uint num_slots)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_raw_tls_cfree           </td>
          <td>(</td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>num_slots</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Frees <code>num_slots</code> raw thread-local storage slots starting at offset <code>offset</code> that were allocated with <a class="el" href="dr__tools_8h.html#95b53d79cae021a473c39f3b2662323f">dr_raw_tls_calloc()</a>. Returns whether or not the slots were successfully freed. 
</div>
</div><p>
<a class="anchor" name="71f6940085912cdce608f317a27fc397"></a><!-- doxytag: member="dr_tools.h::dr_read_file" ref="71f6940085912cdce608f317a27fc397" args="(file_t f, void *buf, size_t count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t dr_read_file           </td>
          <td>(</td>
          <td class="paramtype">file_t&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads up to <code>count</code> bytes from file <code>f</code> into <code>buf</code>. Returns the actual number read. 
</div>
</div><p>
<a class="anchor" name="5421c0abd69da94ed3e7fb898d5bb132"></a><!-- doxytag: member="dr_tools.h::dr_replace_fragment" ref="5421c0abd69da94ed3e7fb898d5bb132" args="(void *drcontext, void *tag, instrlist_t *ilist)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_replace_fragment           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Replaces the fragment with tag <code>tag</code> with the instructions in <code>ilist</code>. This routine is only valid with the -thread_private option; it replaces the fragment for the current thread only. After replacement, the existing fragment is allowed to complete if currently executing. For example, a clean call replacing the currently executing fragment will safely return to the existing code. Subsequent executions will use the new instructions.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The routine takes control of <code>ilist</code> and all responsibility for deleting it. The client should not keep, use, or reference, the instrlist or any of the instrs it contains after passing.<p>
This routine supports replacement for the current thread only. <code>drcontext</code> must be from the current thread and must be the drcontext used to create the instruction list.</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>false if the fragment does not exist and true otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="902bfca468a7a2cc3dbc45b4bd127444"></a><!-- doxytag: member="dr_tools.h::dr_request_synchronized_exit" ref="902bfca468a7a2cc3dbc45b4bd127444" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_request_synchronized_exit           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enables the -synch_at_exit runtime option, which guarantees that no thread will executed beyond its own thread exit event at process exit time. When the -synch_at_exit option is off, which is the default setting, in release builds there is no such guarantee. 
</div>
</div><p>
<a class="anchor" name="1193842150b09442a1b3c91f4e02d280"></a><!-- doxytag: member="dr_tools.h::dr_resume_all_other_threads" ref="1193842150b09442a1b3c91f4e02d280" args="(IN void **drcontexts, IN uint num_suspended)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_resume_all_other_threads           </td>
          <td>(</td>
          <td class="paramtype">IN void **&nbsp;</td>
          <td class="paramname"> <em>drcontexts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN uint&nbsp;</td>
          <td class="paramname"> <em>num_suspended</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
May only be used after invoking <a class="el" href="dr__tools_8h.html#01fbe357fcc8352ba63c9a1a23e0c207">dr_suspend_all_other_threads()</a>. This routine resumes the threads that were suspended by <a class="el" href="dr__tools_8h.html#01fbe357fcc8352ba63c9a1a23e0c207">dr_suspend_all_other_threads()</a> and must be passed the same array and count of suspended threads that were returned by <a class="el" href="dr__tools_8h.html#01fbe357fcc8352ba63c9a1a23e0c207">dr_suspend_all_other_threads()</a>. It also frees the <code>drcontexts</code> array and releases the locks acquired by <a class="el" href="dr__tools_8h.html#01fbe357fcc8352ba63c9a1a23e0c207">dr_suspend_all_other_threads()</a>. The return value indicates whether all resumption attempts were successful. 
</div>
</div><p>
<a class="anchor" name="6a94558696130c76f34dcdac0ce50c47"></a><!-- doxytag: member="dr_tools.h::dr_safe_read" ref="6a94558696130c76f34dcdac0ce50c47" args="(const void *base, size_t size, void *out_buf, size_t *bytes_read)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_safe_read           </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>out_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>bytes_read</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Safely reads <code>size</code> bytes from address <code>base</code> into buffer <code>out_buf</code>. Reading is done without the possibility of an exception occurring. Optionally returns the actual number of bytes copied into <code>bytes_read</code>. Returns true if successful. 
</div>
</div><p>
<a class="anchor" name="b94f47b693cc7dd9eecba07d8cfd1bc8"></a><!-- doxytag: member="dr_tools.h::dr_safe_write" ref="b94f47b693cc7dd9eecba07d8cfd1bc8" args="(void *base, size_t size, const void *in_buf, size_t *bytes_written)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_safe_write           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>in_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>bytes_written</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Safely writes <code>size</code> bytes from buffer <code>in_buf</code> to address <code>base</code>. Writing is done without the possibility of an exception occurring. Optionally returns the actual number of bytes copied into <code>bytes_written</code>. Returns true if successful. 
</div>
</div><p>
<a class="anchor" name="9191c67a267070ed51289d7192f986aa"></a><!-- doxytag: member="dr_tools.h::dr_set_itimer" ref="9191c67a267070ed51289d7192f986aa" args="(int which, uint millisec, void(*func)(void *drcontext, dr_mcontext_t *mcontext))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_set_itimer           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>which</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>millisec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *drcontext, <a class="el" href="struct__dr__mcontext__t.html">dr_mcontext_t</a> *mcontext)&nbsp;</td>
          <td class="paramname"> <em>func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Installs an interval timer in the itimer sharing group that contains the calling thread.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>which</em>&nbsp;</td><td>Must be one of ITIMER_REAL, ITIMER_VIRTUAL, or ITIMER_PROF </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>millisec</em>&nbsp;</td><td>The frequency of the timer, in milliseconds. Passing 0 disables the timer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>func</em>&nbsp;</td><td>The function that will be called each time the timer fires. It will be passed the context of the thread that received the itimer signal and its machine context, which has not been translated and so may contain raw code cache values. The function will be called from a signal handler that may have interrupted lock holder or other critical code, so it must be careful in its operations. If a general timer that does not interrupt client code is required, the client should create a separate thread via <a class="el" href="dr__tools_8h.html#c6b80b83502ff13d4674b13e7b30b555">dr_create_client_thread()</a> (which is guaranteed to have a private itimer) and set the itimer there, where the callback function can perform more operations safely if that new thread never acquires locks in its normal operation.</td></tr>
  </table>
</dl>
Itimer sharing varies by kernel. Prior to 2.6.12 itimers were thread-private; after 2.6.12 they are shared across a thread group, though there could be multiple thread groups in one address space. The <a class="el" href="dr__tools_8h.html#b5cd85ea911bd99dedbd8d05796260bc">dr_get_itimer()</a> function can be used to see whether a thread already has an itimer in its group to avoid re-setting an itimer set by an earlier thread.<p>
The itimer will operate successfully in the presence of an application itimer of the same type.<p>
The return value indicates whether the timer was successfully installed (or uninstalled if 0 was passed for <code>millisec</code>).<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Linux-only. </dd></dl>

</div>
</div><p>
<a class="anchor" name="05b499c8a3115e9ceb4c45dbee660738"></a><!-- doxytag: member="dr_tools.h::dr_set_tls_field" ref="05b499c8a3115e9ceb4c45dbee660738" args="(void *drcontext, void *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_set_tls_field           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the user-controlled thread-local-storage field. To generate an instruction sequence that reads the drcontext field inline in the code cache, use <a class="el" href="dr__ir__utils_8h.html#982089284bd51339f448ec4b3928d3b4">dr_insert_write_tls_field()</a>. 
</div>
</div><p>
<a class="anchor" name="f154e498d8b185931ef970676cb65351"></a><!-- doxytag: member="dr_tools.h::dr_sleep" ref="f154e498d8b185931ef970676cb65351" args="(int time_ms)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_sleep           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>time_ms</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Current thread sleeps for <code>time_ms</code> milliseconds. 
</div>
</div><p>
<a class="anchor" name="b0c5f2529d9c076b5b0b0e92a70834b7"></a><!-- doxytag: member="dr_tools.h::dr_snprintf" ref="b0c5f2529d9c076b5b0b0e92a70834b7" args="(char *buf, size_t max, const char *fmt,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int dr_snprintf           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Utility routine to print a formatted message to a string. Will not print more than max characters. If successful, returns the number of characters printed, not including the terminating null character. If the number of characters to write equals max, then the caller is responsible for supplying a terminating null character. If the number of characters to write exceeds max, then max characters are written and -1 is returned. If an error occurs, a negative value is returned. <dl class="note" compact><dt><b>Note:</b></dt><dd>This routine does not support printing wide characters. On Windows you can use _snprintf() instead (though _snprintf() does not support printing floating point values). <p>
If the data to be printed is large it will be truncated to an internal buffer size. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f63184f56cc0508e2840f64e84b1c48d"></a><!-- doxytag: member="dr_tools.h::dr_standalone_init" ref="f63184f56cc0508e2840f64e84b1c48d" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* dr_standalone_init           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a DR context that can be used in a standalone program. <dl class="warning" compact><dt><b>Warning:</b></dt><dd>This context cannot be used as the drcontext for a thread running under DR control! It is only for standalone programs that wish to use DR as a library of disassembly, etc. routines. </dd></dl>

</div>
</div><p>
<a class="anchor" name="01fbe357fcc8352ba63c9a1a23e0c207"></a><!-- doxytag: member="dr_tools.h::dr_suspend_all_other_threads" ref="01fbe357fcc8352ba63c9a1a23e0c207" args="(OUT void ***drcontexts, OUT uint *num_suspended, OUT uint *num_unsuspended)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_suspend_all_other_threads           </td>
          <td>(</td>
          <td class="paramtype">OUT void ***&nbsp;</td>
          <td class="paramname"> <em>drcontexts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT uint *&nbsp;</td>
          <td class="paramname"> <em>num_suspended</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT uint *&nbsp;</td>
          <td class="paramname"> <em>num_unsuspended</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Suspends all other threads in the process and returns an array of contexts in <code>drcontexts</code> with one context per successfully suspended threads. The contexts can be passed to routines like <a class="el" href="dr__tools_8h.html#3980d703cc13379a6b57396a7901b1d1">dr_get_thread_id()</a> or <a class="el" href="dr__ir__utils_8h.html#d78c531d7527907652e770960c07af38">dr_get_mcontext()</a>. However, the contexts may not be modified: <a class="el" href="dr__ir__utils_8h.html#ed77cd48eccfdd8eaf8c33bd6b53d8b2">dr_set_mcontext()</a> is not supported. <a class="el" href="dr__ir__utils_8h.html#d78c531d7527907652e770960c07af38">dr_get_mcontext()</a> can be called on the caller of this routine, unless in a Windows nudge callback.<p>
The number of successfully suspended threads, which is also the length of the <code>drcontexts</code> array, is returned in <code>num_suspended</code>, which is a required parameter. The number of un-successfully suspended threads, if any, is returned in the optional parameter <code>num_unsuspended</code>. The calling thread is not considered in either count. DR can fail to suspend a thread for privilege reasons (e.g., on Windows in a low-privilege process where another process injected a thread). This function returns true iff all threads were suspended, in which case <code>num_unsuspended</code> will be 0.<p>
The caller must invoke <a class="el" href="dr__tools_8h.html#1193842150b09442a1b3c91f4e02d280">dr_resume_all_other_threads()</a> in order to resume the suspended threads, free the <code>drcontexts</code> array, and release coarse-grain locks that prevent new threads from being created.<p>
This routine may not be called from any registered event callback other than the nudge event. It may be called from clean calls out of the cache. This routine may not be called while any locks are held that could block a thread processing a registered event callback or cache callout.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>A client wishing to invoke this routine from an event callback can queue up a nudge via <a class="el" href="dr__events_8h.html#9d11fb8fbffdcb0cb6e7b87f804cb459">dr_nudge_client()</a> and invoke this routine from the nudge callback. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1e01fe123ecc9908ada9c9fccbf3f6ab"></a><!-- doxytag: member="dr_tools.h::dr_syscall_get_param" ref="1e01fe123ecc9908ada9c9fccbf3f6ab" args="(void *drcontext, int param_num)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">reg_t dr_syscall_get_param           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>param_num</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Usable only from a pre-syscall (<a class="el" href="dr__events_8h.html#a37d61a7f9dde4663b8dd4c3a44732f4">dr_register_pre_syscall_event()</a>) event. Returns the value of system call parameter number <code>param_num</code>. 
</div>
</div><p>
<a class="anchor" name="d12463724bf63a891e991891c72e6a4b"></a><!-- doxytag: member="dr_tools.h::dr_syscall_get_result" ref="d12463724bf63a891e991891c72e6a4b" args="(void *drcontext)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">reg_t dr_syscall_get_result           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Usable only from a post-syscall (<a class="el" href="dr__events_8h.html#099441f8d147404355c66178e3b19f0f">dr_register_post_syscall_event()</a>) event. Returns the return value of the system call that will be presented to the application. 
</div>
</div><p>
<a class="anchor" name="76797a9310bf67ebeb820d80e11764b8"></a><!-- doxytag: member="dr_tools.h::dr_syscall_invoke_another" ref="76797a9310bf67ebeb820d80e11764b8" args="(void *drcontext)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_syscall_invoke_another           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Usable only from a post-syscall (<a class="el" href="dr__events_8h.html#099441f8d147404355c66178e3b19f0f">dr_register_post_syscall_event()</a>) event. An additional system call will be invoked immediately, using the current values of the parameters, which can be set with <a class="el" href="dr__tools_8h.html#c21a83f1812443112303ef3ea8b76de2">dr_syscall_set_param()</a>. The system call to be invoked should be specified with <a class="el" href="dr__tools_8h.html#bc80dfdf8bff3c3feb486aacd69aba7c">dr_syscall_set_sysnum()</a>.<p>
Use this routine with caution. Especially on Windows, care must be taken if the application is expected to continue afterward. When system call parameters are stored on the stack, modifying them can result in incorrect application behavior, particularly when setting more parameters than were present in the original system call, which will result in corruption of the application stack.<p>
On Windows, when the first system call is interruptible (alertable), the additional system call may be delayed.<p>
DR will set key registers such as r10 for 64-bit or xdx for sysenter or WOW64 system calls. However, DR will not set ecx for WOW64; that is up to the client. 
</div>
</div><p>
<a class="anchor" name="c21a83f1812443112303ef3ea8b76de2"></a><!-- doxytag: member="dr_tools.h::dr_syscall_set_param" ref="c21a83f1812443112303ef3ea8b76de2" args="(void *drcontext, int param_num, reg_t new_value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_syscall_set_param           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>param_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">reg_t&nbsp;</td>
          <td class="paramname"> <em>new_value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Usable only from a pre-syscall (<a class="el" href="dr__events_8h.html#a37d61a7f9dde4663b8dd4c3a44732f4">dr_register_pre_syscall_event()</a>) event, or from a post-syscall (<a class="el" href="dr__events_8h.html#099441f8d147404355c66178e3b19f0f">dr_register_post_syscall_event()</a>) event when also using <a class="el" href="dr__tools_8h.html#76797a9310bf67ebeb820d80e11764b8">dr_syscall_invoke_another()</a>. Sets the value of system call parameter number <code>param_num</code> to <code>new_value</code>. 
</div>
</div><p>
<a class="anchor" name="601cd2b724ac627aef0756a4c4eee637"></a><!-- doxytag: member="dr_tools.h::dr_syscall_set_result" ref="601cd2b724ac627aef0756a4c4eee637" args="(void *drcontext, reg_t value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_syscall_set_result           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">reg_t&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Usable only from a pre-syscall (<a class="el" href="dr__events_8h.html#a37d61a7f9dde4663b8dd4c3a44732f4">dr_register_pre_syscall_event()</a>) or post-syscall (<a class="el" href="dr__events_8h.html#099441f8d147404355c66178e3b19f0f">dr_register_post_syscall_event()</a>) event. For pre-syscall, should only be used when skipping the system call. This sets the return value of the system call that the application sees to <code>value</code>. 
</div>
</div><p>
<a class="anchor" name="bc80dfdf8bff3c3feb486aacd69aba7c"></a><!-- doxytag: member="dr_tools.h::dr_syscall_set_sysnum" ref="bc80dfdf8bff3c3feb486aacd69aba7c" args="(void *drcontext, int new_num)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_syscall_set_sysnum           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>new_num</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Usable only from a pre-syscall (<a class="el" href="dr__events_8h.html#a37d61a7f9dde4663b8dd4c3a44732f4">dr_register_pre_syscall_event()</a>) event, or from a post-syscall (<a class="el" href="dr__events_8h.html#099441f8d147404355c66178e3b19f0f">dr_register_post_syscall_event()</a>) event when also using <a class="el" href="dr__tools_8h.html#76797a9310bf67ebeb820d80e11764b8">dr_syscall_invoke_another()</a>. Sets the system call number of the system call about to be invoked to <code>new_num</code>. 
</div>
</div><p>
<a class="anchor" name="4274226adda06339e247e4a311abdd9b"></a><!-- doxytag: member="dr_tools.h::dr_thread_alloc" ref="4274226adda06339e247e4a311abdd9b" args="(void *drcontext, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* dr_thread_alloc           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allocates <code>size</code> bytes of memory from DR's memory pool specific to the thread associated with <code>drcontext</code>. 
</div>
</div><p>
<a class="anchor" name="3f1f3862009f52182e9ca1f943fa6f14"></a><!-- doxytag: member="dr_tools.h::dr_thread_free" ref="3f1f3862009f52182e9ca1f943fa6f14" args="(void *drcontext, void *mem, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_thread_free           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Frees thread-specific memory allocated by <a class="el" href="dr__tools_8h.html#4274226adda06339e247e4a311abdd9b">dr_thread_alloc()</a>. <code>size</code> must be the same as that passed to <a class="el" href="dr__tools_8h.html#4274226adda06339e247e4a311abdd9b">dr_thread_alloc()</a>. 
</div>
</div><p>
<a class="anchor" name="c262422c1e5e487113176bd4193c387f"></a><!-- doxytag: member="dr_tools.h::dr_thread_yield" ref="c262422c1e5e487113176bd4193c387f" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_thread_yield           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Current thread gives up its time quantum. 
</div>
</div><p>
<a class="anchor" name="1d4c9a29f1c962457c123322aa3e1931"></a><!-- doxytag: member="dr_tools.h::dr_trace_exists_at" ref="1d4c9a29f1c962457c123322aa3e1931" args="(void *drcontext, void *tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_trace_exists_at           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>tag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks to see that if there is a trace in the code cache at tag <code>tag</code>. 
</div>
</div><p>
<a class="anchor" name="1e3f7e4e3e4048021966c04a4b00fbc9"></a><!-- doxytag: member="dr_tools.h::dr_trace_head_at" ref="1e3f7e4e3e4048021966c04a4b00fbc9" args="(void *drcontext, void *tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_trace_head_at           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>tag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks to see if the fragment (or future fragment) with tag <code>tag</code> is marked as a trace head. 
</div>
</div><p>
<a class="anchor" name="56909cf76e4a71fca13731053ef48928"></a><!-- doxytag: member="dr_tools.h::dr_unlink_flush_region" ref="56909cf76e4a71fca13731053ef48928" args="(app_pc start, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_unlink_flush_region           </td>
          <td>(</td>
          <td class="paramtype">app_pc&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Flush all fragments containing any code from the region [<code>start</code>, <code>start</code> + <code>size</code>). Control will not enter a fragment containing code from the region after this returns, but a thread already in such a fragment will finish out the fragment. This includes the current thread if this is called from a clean call that returns to the cache. This routine may only be called during a clean call from the cache or from a nudge event handler. It may not be called from any other event callback. No locks can be held when calling this routine. Returns true if successful.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This routine may not be called from any registered event callback other than the nudge event; clean calls out of the cache may call this routine. <p>
This routine may not be called while any locks are held that could block a thread processing a registered event callback or cache callout. <p>
<a class="el" href="dr__tools_8h.html#fa5ea6649e644074ca55f456c89264e8">dr_delay_flush_region()</a> has fewer restrictions on use, but is less synchronous. <p>
Use <code>size</code> == 1 to flush fragments containing the instruction at address <code>start</code>. A flush of <code>size</code> == 0 is not allowed. <p>
This routine is only available with either the -thread_private or -enable_full_api options. It is not available when -opt_memory is specified. </dd></dl>

</div>
</div><p>
<a class="anchor" name="54934632c814904bd9e0ce9c83980466"></a><!-- doxytag: member="dr_tools.h::dr_using_all_private_caches" ref="54934632c814904bd9e0ce9c83980466" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_using_all_private_caches           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if all DynamoRIO caches are thread private. 
</div>
</div><p>
<a class="anchor" name="55ca77553e86a0656dc186ae3fc8222f"></a><!-- doxytag: member="dr_tools.h::dr_virtual_query" ref="55ca77553e86a0656dc186ae3fc8222f" args="(const byte *pc, MEMORY_BASIC_INFORMATION *mbi, size_t mbi_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t dr_virtual_query           </td>
          <td>(</td>
          <td class="paramtype">const byte *&nbsp;</td>
          <td class="paramname"> <em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MEMORY_BASIC_INFORMATION *&nbsp;</td>
          <td class="paramname"> <em>mbi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>mbi_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Equivalent to the win32 API function VirtualQuery(). See that routine for a description of arguments and return values. <dl class="note" compact><dt><b>Note:</b></dt><dd>Windows-only. </dd></dl>

</div>
</div><p>
<a class="anchor" name="eddf708cc2271dc50209b3e78e1d23fb"></a><!-- doxytag: member="dr_tools.h::dr_write_file" ref="eddf708cc2271dc50209b3e78e1d23fb" args="(file_t f, const void *buf, size_t count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t dr_write_file           </td>
          <td>(</td>
          <td class="paramtype">file_t&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes <code>count</code> bytes from <code>buf</code> to file <code>f</code>. Returns the actual number written. 
</div>
</div><p>
</div>
<hr size="1"><address style="text-align: center;"><small>
<img border=0 src="favicon.png"> &nbsp; DynamoRIO API version 2.0.0 --- Thu Apr 22 00:18:19 2010 
&nbsp; <img border=0 src="favicon.png">
</body>
</html>
