<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>DynamoRIO API: Usage Model for DynamoRIO</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
<link rel="shortcut icon" type="image/x-icon" href="favicon.ico" />
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="contents">
<h1><a class="anchor" name="using">Usage Model for DynamoRIO </a></h1>This section gives an overview of how to use DynamoRIO, divided into the following sub-sections:<p>
<ul>
<li><a class="el" href="using.html#sec_deploy">Deployment</a></li><li><a class="el" href="using.html#sec_events">Common Events</a></li><li><a class="el" href="using.html#sec_utils">Common Utilities</a></li><li><a class="el" href="using.html#sec_build">Building a Client</a></li><li><a class="el" href="using.html#sec_extlibs">Using External Libraries</a></li><li><a class="el" href="using.html#sec_extensions">DynamoRIO Extensions</a></li><li><a class="el" href="using.html#sec_comm">Communication</a></li><li><a class="el" href="using.html#sec_64bit_reach">64-Bit Reachability</a></li><li><a class="el" href="using.html#sec_options">Fine-Tuning DynamoRIO: Runtime Parameters</a></li><li><a class="el" href="using.html#sec_debugging">Diagnosing and Reporting Problems</a></li></ul>
<p>
DynamoRIO exports a rich Application Programming Interface (API) to the user for building a DynamoRIO <em>client</em>. A DynamoRIO client is a library that is coupled with DynamoRIO in order to jointly operate on an input program binary:<p>
<div align="center">
<img src="client.png" alt="client.png">
</div>
  <p>
To interact with the client, DynamoRIO provides specific events that a client can intercept. Event interception functions, if supplied by a user client, are called by DynamoRIO at appropriate times.<p>
DynamoRIO can alternatively be used as a third-party disassembly library (see <a class="el" href="page_standalone.html">IA-32/AMD64 Disassembly Library</a>).<h2><a class="anchor" name="sec_deploy">
Deployment</a></h2>
Once the DynamoRIO distribution contents are unpacked (see <a class="el" href="release_notes.html#sec_package">Distribution Contents</a>), configuration and execution of applications under DynamoRIO is handled by a set of libraries and tools. On Windows, the tools are <code>drconfig.exe</code>, <code>drrun.exe</code>, and <code>drinject.exe</code>. The corresponding libraries (whose APIs are exposed by the tools) are <code>drconfiglib.dll</code> and <code>drinjectlib.dll</code> with header files <code><a class="el" href="dr__config_8h.html" title="Deployment API for Windows. Use these functions to register processes to run under...">dr_config.h</a></code> and <code><a class="el" href="dr__inject_8h.html" title="Injection API for Windows. Use these functions to launch processes under the control...">dr_inject.h</a></code>. On Linux, the tools are the <code>drconfig</code>, <code>drrun</code>, and <code>drinject</code> scripts.<p>
When using DynamoRIO as a third-party disassembly library (see <a class="el" href="page_standalone.html">IA-32/AMD64 Disassembly Library</a>), no deployment is needed, as DynamoRIO does not control a target application when used as a regular library.<h3><a class="anchor" name="win_deploy">
Windows Deployment</a></h3>
There are two methods for running a process under DynamoRIO: the one-time configure-and-run, and the two-step separate configuration and execution. The <code>drrun.exe</code> tool supports the first, simpler model, while the <code>drconfig.exe</code> and <code>drinject.exe</code> tools support the second, more powerful model. The <code>drconfig.exe</code> tool, or the corresponding the <code>drconfiglib.dll</code> library, can also be used to <a class="el" href="using.html#sec_comm">nudge</a> running processes.<p>
Configuration information is stored in files in the current user's profile directory, which is obtained from the environment variable <code>$USERPROFILE</code>. Thus, configurations are persistent across reboots and are private to each user. DynamoRIO also supports global configurations, which are stored in the "config" subdirectory of the directory specified by the <code>DYNAMORIO_HOME</code> registry value in the registry key <code>\HKLM\SOFTWARE\DynamoRIO\DynamoRIO</code> (or for 32-bit on 64-bit Windows (WOW64) <code>\HKLM\SOFTWARE\Wow6432Node\DynamoRIO\DynamoRIO</code>). Setting that <code>DYNAMORIO_HOME</code> value and creating the directory it points to must be done manually. The provided tools support reading and writing both local and global configuration files, and automatically creating the local directory. DynamoRIO gives local files precedence when both exist. Note that applications that do not have a $USEPROFILE environment variable can only be executed using global configurations.<p>
Configurations are per-process, with the basename of the process used for identification (e.g., <code>calc.exe</code>). One-time configuration also uses the process id to specify that the configuration is for that process instance only.<p>
As an example, assume you have unpacked the DynamoRIO distribution and your current directory is its base directory. Run <code>calc.exe</code> with the bbsize sample client using the following configure-and-run command:<p>
<div class="fragment"><pre class="fragment">bin32/drrun.exe -client samples/bin32/bbsize.dll 0 <span class="stringliteral">""</span> calc
</pre></div><p>
To use system-wide injection, allowing for an application to be run under DynamoRIO regardless of how it is invoked, configure the application first (-syswide_on requires administrative privileges):<p>
<div class="fragment"><pre class="fragment">bin32/drconfig.exe -reg calc.exe -syswide_on -client samples/bin32/bbsize.dll 0 <span class="stringliteral">""</span>
</pre></div><p>
The next time <code>calc.exe</code> is started by the current user, it will run under DynamoRIO with the bbsize client.<p>
To unregister <code>calc.exe</code>, issue the following command: <div class="fragment"><pre class="fragment">bin32/drconfig.exe -unreg calc.exe
</pre></div><p>
Invoke any of the <code>drconfig.exe</code>, <code>drrun.exe</code>, or <code>drinject.exe</code> tools with no arguments to see the full list of options available.<p>
By default on Windows DynamoRIO only follows into children that are configured (via <code>drconfig.exe</code>). To follow all children, use the <a class="el" href="using.html#op_children">-follow_children</a> runtime option.<p>
To <a class="el" href="using.html#sec_comm">nudge</a> all instances of <code>calc.exe</code> running under DynamoRIO with argument "5", use: <div class="fragment"><pre class="fragment">bin32/drconfig.exe -nudge calc.exe 0 5
</pre></div> This will result in a nudge event with argument=5 delivered to the client callback registered with <a class="el" href="dr__events_8h.html#9037603d0bd5bfca4198011adb8d10eb">dr_register_nudge_event()</a> in all <code>calc.exe</code> processes running under DynamoRIO. The third argument, 0, is an ID supplied at registration which uniquely identifies the target client (see dr_deploy.h for details). Note that nudging 64-bit applications is not yet supported on Windows.<p>
To view 32-bit or WOW64 processes running under DynamoRIO the <code>drview.exe</code> tool can be used. The bin64 version will display both 32-bit and 64-bit processes and will indicate which are 32-bit. The bin32 version will display 64-bit processes but is unable to determine whether DynamoRIO is present.<p>
<dl class="attention" compact><dt><b>Attention:</b></dt><dd>Note that on Windows NT a reboot is required after using -syswide_on or -syswide_off.</dd></dl>
DynamoRIO uses the <code>\HKLM\SOFTWARE\Microsoft\Windows\Windows NT\CurrentVersion\AppInit_DLLs</code> key (for 32-bit on 64-bit Windows (WOW64), <code>\HKLM\SOFTWARE\Wow6432Node\Microsoft\Windows NT\CurrentVersion\Windows\AppInit_DLLs</code>) for -syswide_on to inject into new processes without having to directly launch them <code>drrun.exe</code> or <code>drinject.exe</code>. For injection to work, the registered process must statically link to user32.dll (only a few small non-graphical windows applications don't link user32.dll). If a target application does not link to user32.dll, DynamoRIO can still inject if the process is launched with <code>drinject.exe</code> or if the parent process (usually cmd.exe or explorer.exe for user launched processes) is running under DynamoRIO. The drinject.exe tool uses the configuration information set by <code>drconfig.exe</code> for the target application.<p>
<dl class="attention" compact><dt><b>Attention:</b></dt><dd>The -syswide_on, -syswide_off, use of global configuration files, and nudging certain processes may require administrative privileges. On Windows Vista, if UAC is enabled, use an elevated (runas admin) process. When using <code>drconfig.exe</code> and <code>drrun.exe</code> in these scenarios, be sure that the cmd shell being used was started with elevated permissions.</dd></dl>
<h3><a class="anchor" name="lin_deploy">
Linux Deployment</a></h3>
Once DynamoRIO has been unpacked, a set of three scripts provide flexibility in configuring and executing applications. The <a class="el" href="release_notes.html#limits_linux_preload">LD_PRELOAD</a> based scripts and the <a class="el" href="API_BT.html#sec_startstop">app_start()/app_stop()</a> interface are currently the only supported methods of running applications under DynamoRIO on Linux.<p>
There are two methods for invoking an application under DynamoRIO:<ol type=1>
<li>Configure and launch in one step via <code>drrun</code> </li><li>Configure via <code>drconfig</code> and launch via <code>drinject</code> </li></ol>
<p>
As an example of the simpler method, the following command runs <code>ls</code> under DynamoRIO with the bbsize sample client: <div class="fragment"><pre class="fragment">% bin32/drrun -client samples/bin32/libbbsize.so 0 <span class="stringliteral">""</span> ls
</pre></div> Run <code>drrun</code> with no options to get a list of the options and environment variable shortcuts it supports. To disable following across child execve calls, use the <a class="el" href="using.html#op_no_children">-no_follow_children</a> runtime option.<p>
Use the scripts in <code>bin32/</code> for 32-bit applications and the scripts in <code>bin64/</code> for 64-bit applications.<p>
The two-step method allows for greater control over child processes. The <code>drconfig</code> script writes a configuration file for a given application name. DynamoRIO reads its options from the configuration file at runtime. Once each process name is configured, the <code>drinject</code> script can be used to invoke the parent process. The <code>drrun</code> script can also be used but it creates a temporary configuration file that will override settings requested via <code>drconfig</code>. The configuration file for each application is stored in <code>$HOME/.dynamorio/&lt;appname&gt;.config32</code> (or a <code>config64</code> suffix for 64-bit). DynamoRIO also supports global configuration files in <code>/etc/dynamorio/&lt;appname&gt;.config32</code> when a local configuration file is not found. <code>drconfig</code> does not support directly writing a global config file but such files can be copied from or modeled on local files.<p>
If a target application executes an <code>execve</code> that discards the <code>$HOME</code> environment variable, the resulting process will not run under DynamoRIO control. Use global configuration files to handle this situation.<p>
To <a class="el" href="using.html#sec_comm">nudge</a> a process with pid <code>targetpid</code> running under DynamoRIO and pass argument "5" to the nudge callback, use the <code>nudgeunix</code> tool: <div class="fragment"><pre class="fragment">bin32/nudgeunix -pid targetpid -client 0 5
</pre></div> This will result in a nudge event with argument=5 delivered to the client callback registered with <a class="el" href="dr__events_8h.html#9037603d0bd5bfca4198011adb8d10eb">dr_register_nudge_event()</a> in the target process. The 0 argument is an ID supplied at registration which uniquely identifies the target client (see dr_deploy.h for details).<h3><a class="anchor" name="multi_client">
Multiple Clients</a></h3>
DynamoRIO does support multiple clients. It is each client's responsibility, however, to ensure compatibility with other clients. DynamoRIO makes no attempt to force cooperation among clients. For example, instruction stream modifcations made by one client are visible to other clients. Systems employing multiple clients must be aware of such interactions and design accordingly.<p>
Client registration requires users to specify the <em>priority</em> of each client. DynamoRIO calls each client's <a class="el" href="dr__api_8h.html#20a4dc9da7f6bb9121e30bb3570c6961">dr_init()</a> routine sequentially according to this priority. Clients with a numerically lower priority value are called first and therefore given the first opportunity to register callbacks (the client with priority 0 is called first). Since DynamoRIO delivers event callbacks sequentially, client priority and the order of event registration is important. For a given event, the <em>first</em> registered callback is called <em>last</em>. This scheme gives precedence to the first registered callback since that callback is given the final opportunity to modify the instruction stream or influence DynamoRIO's operation.<h2><a class="anchor" name="sec_events">
Common Events</a></h2>
A client's primary interaction with the DynamoRIO system is via a set of event callbacks. These events include the following:<p>
<ul>
<li>Basic block and trace creation or deletion</li></ul>
<p>
<ul>
<li>Process initialization and exit</li></ul>
<p>
<ul>
<li>Thread initialization and exit</li></ul>
<p>
<ul>
<li>Fork child initialization (Linux-only); meant to be used for re-initialization of data structures and creation of new log files</li></ul>
<p>
<ul>
<li>Application library load and unload</li></ul>
<p>
<ul>
<li>Application fault or exception (signal on Linux)</li></ul>
<p>
<ul>
<li>System call interception: pre-system call, post-system call, and system call filtering by number</li></ul>
<p>
<ul>
<li>Signal interception (Linux-only)</li></ul>
<p>
<ul>
<li>Nudge received - see <a class="el" href="using.html#sec_comm">Communication</a></li></ul>
<p>
Typically, a client will register for the desired events at initialization in its <a class="el" href="dr__api_8h.html#20a4dc9da7f6bb9121e30bb3570c6961">dr_init()</a> routine. DynamoRIO then calls the registered functions at the appropriate times. Each event has a specific registration routine (e.g., <a class="el" href="dr__events_8h.html#878920c40c76e2c18043f9db772a24c0">dr_register_thread_init_event()</a>) and an associated unregistration routine. The header file <a class="el" href="dr__events_8h.html" title="Event callback registration routines.">dr_events.h</a> contains the declarations for all registration and unregistration routines.<p>
Note that clients are allowed to register multiple callbacks for the same event. DynamoRIO also supports mutiple clients, each of which can register for the same event. In this case, DynamoRIO sequences event callbacks in reverse order of when they were registered. In other words, the first registered callback receives event notification last. This scheme gives priority to a callback registered earlier, since it can override or modify the actions of clients registered later. Note that DynamoRIO calls each client's <a class="el" href="dr__api_8h.html#20a4dc9da7f6bb9121e30bb3570c6961">dr_init()</a> routine according to the client's priority (see <a class="el" href="using.html#multi_client">Multiple Clients</a> and <a class="el" href="dr__config_8h.html#6e096f4225b482c50e416c5ecf68e0f9">dr_register_client()</a> in the deployment API).<p>
Systems registering multiple callbacks for a single event should be aware that client modifications are visible in subsequent callbacks. DynamoRIO makes no attempt to mitigate interference among callback functions. It is the responsibility of a client to ensure compatibility among its callback functions and the callback functions of other clients.<p>
Clients can also unregister a callback using the appropriate unregister routine (see <a class="el" href="dr__events_8h.html" title="Event callback registration routines.">dr_events.h</a>). While unusual, it is possible for one callback routine to unregister another. In this case, DynamoRIO still calls routines that were registered before the event. Unregistration takes effect before the next event.<p>
On Linux, an exec (SYS_execve) does NOT result in an exit event, but it WILL result in the client library being reloaded and its <a class="el" href="dr__api_8h.html#20a4dc9da7f6bb9121e30bb3570c6961">dr_init()</a> routine being called again. The system call events can be used for notification of SYS_execve.<h2><a class="anchor" name="sec_utils">
Common Utilities</a></h2>
DynamoRIO provides clients with a powerful library of utilities for custom runtime code transformations. The interface includes explicit support for creating <em>transparent</em> clients. See the section on <a class="el" href="transparency.html">Client Transparency</a> for a full discussion of the importance of remaining transparent when operating in the same process as the application. DynamoRIO provides common resources clients can use to avoid reliance on shared libraries that may be in use by the application. The client should only use external resources through DynamoRIO's own API, through DynamoRIO Extensions (see <a class="el" href="using.html#sec_extensions">DynamoRIO Extensions</a>), through direct system calls, or via an external agent in a separate process that communicates with the client (see <a class="el" href="using.html#sec_comm">Communication</a>). Third-party libraries can be used if they are linked statically or loaded privately and there is no possibility of global resource conflicts (e.g., a third-party library's memory allocation must be wrapped): see <a class="el" href="using.html#sec_extlibs">Using External Libraries</a> for more details.<p>
DynamoRIO's API provides:<p>
<ul>
<li>Memory allocation: both thread-private (faster as it incurs no synchronization costs) and thread-shared</li><li>Thread-local storage</li><li>Thread-local stack separate from the application stack</li><li>Simple mutexes</li><li>File creation, reading, and writing</li><li>Address space querying</li><li>Application module iterator</li><li>Processor feature identification</li><li>Extra thread creation</li><li>Symbol lookup (currently Windows-only)</li></ul>
<p>
See <a class="el" href="dr__tools_8h.html" title="Main API routines, including transparency support.">dr_tools.h</a> and <a class="el" href="dr__proc_8h.html" title="Utility routines for identifying features of the processor.">dr_proc.h</a> for specifics of each routine.<p>
Another class of utilities provided by DynamoRIO are structures and routines for decoding, encoding, and manipulating IA-32 and AMD64 instructions. These are described in <a class="el" href="API_BT.html#sec_IR">Instruction Representation</a>.<p>
<a class="anchor" name="subsec_forwards"></a> In addition, on Windows,DynamoRIO provides a number of utility functions that it fowards to a core Windows system library that we believe to be safe for clients to use:<p>
<ul>
<li>wcstoul</li><li>wcstombs</li><li>wcstol</li><li>wcsstr</li><li>wcsspn</li><li>wcsrchr</li><li>wcspbrk</li><li>wcsncpy</li><li>wcsncmp</li><li>wcsncat</li><li>wcslen</li><li>wcscspn</li><li>wcscpy</li><li>wcscmp</li><li>wcschr</li><li>wcscat</li><li>towupper</li><li>towlower</li><li>toupper</li><li>tolower</li><li>tan</li><li>strtoul</li><li>strtol</li><li>strstr</li><li>strspn</li><li>strrchr</li><li>strpbrk</li><li>strncpy</li><li>strncmp</li><li>strncat</li><li>strlen</li><li>strcspn</li><li>strcmp</li><li>strchr</li><li>sscanf</li><li>sqrt</li><li>sprintf</li><li>sin</li><li>qsort</li><li>pow</li><li>memset</li><li>memmove</li><li>memcpy</li><li>memcmp</li><li>memchr</li><li>mbstowcs</li><li>log</li><li>labs</li><li>isxdigit</li><li>iswxdigit</li><li>iswspace</li><li>iswlower</li><li>iswdigit</li><li>iswctype</li><li>iswalpha</li><li>isupper</li><li>isspace</li><li>ispunct</li><li>isprint</li><li>islower</li><li>isgraph</li><li>isdigit</li><li>iscntrl</li><li>isalpha</li><li>isalnum</li><li>floor</li><li>fabs</li><li>cos</li><li>ceil</li><li>atol</li><li>atoi</li><li>atan</li><li>abs</li><li>_wtol</li><li>_wtoi64</li><li>_wtoi</li><li>_wcsupr</li><li>_wcsnicmp</li><li>_wcslwr</li><li>_wcsicmp</li><li>_vsnprintf</li><li>_ultow</li><li>_ultoa</li><li>_ui64toa</li><li>_toupper</li><li>_tolower</li><li>_strupr</li><li>_strnicmp</li><li>_strlwr</li><li>_stricmp</li><li>_strcmpi</li><li>_snwprintf</li><li>_snprintf</li><li>_memicmp</li><li>_memccpy</li><li>_ltow</li><li>_ltoa</li><li>_itow</li><li>_itoa</li><li>_i64tow</li><li>_i64toa</li><li>_ftol</li><li>_fltused</li><li>_chkstk</li><li>_aullshr</li><li>_aullrem</li><li>_aulldiv</li><li>_atoi64</li><li>_allshr</li><li>_allshl</li><li>_allrem</li><li>_allmul</li><li>_alldiv</li><li>__toascii</li><li>__iscsymf</li><li>__iscsym</li><li>__isascii</li></ul>
<p>
In general, these routines match their standard C library counterparts. However, be warned that some of these may be more limited. In particular, _vsnprintf and _snprintf do not support floating-point values. DynamoRIO provides its own <a class="el" href="dr__tools_8h.html#b0c5f2529d9c076b5b0b0e92a70834b7">dr_snprintf()</a> that does support floating-point values, but does not support printing wide characters. When printing floating-point values be sure to <a class="el" href="transparency.html#sec_trans_floating_point">save the application's floating point state</a> so as to avoid corrupting it.<h2><a class="anchor" name="sec_64bit_reach">
64-Bit Reachability</a></h2>
To simplify reachability in a 64-bit address space, DynamoRIO guarantees that all of its code caches and heap are within the same 2GB memory region. DynamoRIO also loads client libraries within 32-bit reachability of its code caches and heap (which currently requires that client libraries have preferred bases in the lower 2GB of the address space: see <a class="el" href="release_notes.html#limits_64bit">limits_64bit</a>). This means that any static data or code in a client library, or any data allocated using DynamoRIO's API, is guaranteed to be directly reachable from code cache code.<h2><a class="anchor" name="sec_build">
Building a Client</a></h2>
To use the DynamoRIO API, a client should include the main DynamoRIO header file:<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include "<a class="code" href="dr__api_8h.html" title="Top-level include file for DynamoRIO API.">dr_api.h</a>"</span>
</pre></div><p>
The client's target operating system and architecture must be specified by setting pre-processor defines before including the DynamoRIO header files. The appropriate library must then be linked with. The define choices are:<p>
<ol type=1>
<li><code>WINDOWS</code> or <code>LINUX</code> </li><li><code>X86_32</code> or <code>X86_64</code> </li></ol>
<p>
For transparency reasons (see <a class="el" href="transparency.html">Client Transparency</a>), clients should be self-contained and should not share libraries with the application. Thus, when a client is linked the linker options for no default libraries, no startup files, and no entry point should be used. Not specifying those options will result in an unsafe client library with the potential to deadlock or crash.<p>
Additionally, 64-bit clients must set a preferred base address in the lower 2GB.<p>
The DynamoRIO release supplies <a href="http://www.cmake.org">CMake</a> configuration files to facilitate building clients with the proper compiler and linker flags. CMake is a cross-platform build system that generates Makefiles or other development system project files. A <code>DynamoRIOConfig.cmake</code> configuration file, along with supporting files, is distributed in the <code>cmake/</code> directory.<p>
In its <code>CMakeLists.txt</code> file, a client should first invoke a <code>find_package(DynamoRIO)</code> command. This can optionally take a version parameter. This adds DynamoRIO as an imported target. If found, the client should then invoke the <code>configure_DynamoRIO_client()</code> function in order to configure build settings. Here is an example:<p>
<div class="fragment"><pre class="fragment">add_library(myclient SHARED myclient.c)
find_package(DynamoRIO)
if (NOT DynamoRIO_FOUND)
  message(FATAL_ERROR "DynamoRIO package required to build")
endif(NOT DynamoRIO_FOUND)
configure_DynamoRIO_client(myclient)
</pre></div><p>
The <code>samples/CMakeLists.txt</code> file in the release package serves as another example. The top of <code>DynamoRIOConfig.cmake</code> contains detailed instructions as well.<p>
When configuring, the <code>DynamoRIO_DIR</code> CMake variable can be passed in to identify the directory that contains the <code>DynamoRIOConfig.cmake</code> file. For example:<p>
<div class="fragment"><pre class="fragment">mkdir ../build
cd ../build
cmake -DDynamoRIO_DIR=$DYNAMORIO_HOME/cmake ../myclient
make
</pre></div><p>
The compiler needs to be configured prior to invoking cmake. If using gcc with a non-default target platform, the <code>CFLAGS</code> and <code>CXXFLAGS</code> environment variables should be set prior to invoking cmake. For example, to configure a 32-bit client when gcc's default is 64-bit:<p>
<div class="fragment"><pre class="fragment">mkdir ../build
cd ../build
CFLAGS=-m32 cmake -DDynamoRIO_DIR=$DYNAMORIO_HOME/cmake ../myclient
make
</pre></div><p>
Note that <code>CXXFLAGS</code> should be set instead for a C++ client, and both should be set when building both types of clients from the same configuration (e.g., <code>samples/CMakeLists.txt</code>).<p>
If a client is not using CMake, the appropriate compiler and linker flags can be gleaned from <code>DynamoRIOConfig.cmake</code>. One method is to invoke CMake to generate a Makefile and then build with <code>VERBOSE=1</code>. We also summarize here the key flags required for 32-bit clients for <code>gcc:</code> <p>
<div class="fragment"><pre class="fragment">gcc -fPIC -shared -nostartfiles -nodefaultlibs -lgcc -DLINUX -DX86_32
    -I$DYNAMORIO_HOME/include my-client.c  
</pre></div><p>
And for <code>cl:</code> <p>
<div class="fragment"><pre class="fragment">cl my-client.c /I$DYNAMORIO_HOME/include /GS- /DWINDOWS /DX86_32
   /link /NODEFAULTLIB /NOENTRY
   /libpath:$DYNAMORIO_HOME/bin dynamorio.lib /dll /out:my-client.dll 
</pre></div><p>
For a 64-bit client with <code>cl:</code> <p>
<div class="fragment"><pre class="fragment">cl my-client.c /I$DYNAMORIO_HOME/include /GS- /DWINDOWS /DX86_64
   /link /NODEFAULTLIB /NOENTRY
   /libpath:$DYNAMORIO_HOME/bin dynamorio.lib /dll /out:my-client.dll 
   /base:0x72000000 /fixed
</pre></div><p>
For 64-bit Linux clients, setting the preferred base takes several steps. Refer to <code>DynamoRIOConfig.cmake</code> for details.<h2><a class="anchor" name="sec_extensions">
DynamoRIO Extensions</a></h2>
DynamoRIO supports extending the API presented to clients through separate libraries called DynamoRIO Extensions. Extensions are meant to include features that may be too costly to make available by default or features contributed by third parties whose licensing requires using a separate library. Extensions can be either static libraries linked with clients at build time or dynamic libraries loaded at runtime. A private loader is used to load dynamic Extensions on Windows; a private loader for Linux is in progress.<p>
Current Extensions provide symbol access and container data structures. Each Extension has its own documentation and has its functions and data structures documented separately from the main API. See <a href="page_ext.html">the full list of Extensions here</a>.<h2><a class="anchor" name="sec_extlibs">
Using External Libraries</a></h2>
Clients are free to use external libraries as long as those libraries do not use any global user-mode resources that would interfere with the running application. Furthermore, clients must either link statically to all libraries or load them using a private loader separate from the application's loader in order to prevent re-entrancy problems (see <a class="el" href="transparency.html#sec_trans_resource">Resource Usage Conflicts</a>).<p>
Currently we provide a private loader for Windows and we plan to supply a private Linux loader in the near future. With private loading, the client uses a separate copy of each library from any copy used by the application. Even with this separation, if these libraries use global resources there can still be conflicts. Our Windows private loader redirects heap allocation in the main process heap to instead use DynamoRIO's internal heap. The loader also attempts to isolate other global resource usage and global callbacks. In this release it should be considered a beta feature. Please file reports on any transparency problems observed when using the private loader.<p>
On Linux, where we do not yet have a private loader, ld provides the -wrap option, which allows us to override the C library's memory heap allocation routines with our own. For convenience, DynamoRIO exports <a class="el" href="dr__tools_8h.html#3687f50774c89e7a09833a71adbb7771">__wrap_malloc()</a>, <a class="el" href="dr__tools_8h.html#dcaad79adf4fc109015dd6a2d49b9031">__wrap_realloc()</a>, and <a class="el" href="dr__tools_8h.html#82dca5b3d5bfbd3de8891502badd861e">__wrap_free()</a> for this purpose. These routines behave like their C library counterparts, but operate on DynamoRIO's global memory pool. Use the -Xlinker flag with gcc to replace the libc routines with DynamoRIO's _wrap routines, e.g.,<p>
<div class="fragment"><pre class="fragment">  gcc -Xlinker -wrap=malloc -Xlinker -wrap=realloc -Xlinker -wrap=free ...
</pre></div><h3><a class="anchor" name="subsec_cpp">
C++ Clients</a></h3>
The ability to override the memory allocation routines makes it convenient to develop C++ clients that use the <em>new</em> and <em>delete</em> operators (as long as those operators are implemented using malloc and free). In particular, heap allocation is required to use the C++ Standard Template Library containers. When developing a C++ client, we recommend linking statically to the C++ runtime library.<p>
On Linux, this is most easily accomplished by specifying the path to the static version of the library on the gcc command line. gcc's -print-file-name option is useful for discovering this path, e.g.,<p>
<div class="fragment"><pre class="fragment">  g++ -print-file-name=libstdc++.a
</pre></div><p>
A full gcc command line for building a C++ client might look something like this:<p>
<div class="fragment"><pre class="fragment">g++ -o my-client.so -I&lt;header dir&gt; \
  -fPIC -shared -nodefaultlibs \
  -Xlinker -wrap=malloc -Xlinker -wrap=realloc -Xlinker -wrap=free \
  `g++ -print-file-name=libstdc++.a` \
  `g++ -print-file-name=libgcc.a` \
  `g++ -print-file-name=libgcc_eh.a` \
  my-client.cpp
</pre></div><p>
See also the stl_test.cpp sample and CMake build files provided with this documentation. The provided CMake build files will set these flags automatically when the <code>DynamoRIO_CXX</code> CMake variable is set (see <a class="el" href="using.html#sec_build">Building a Client</a>).<p>
On Windows, when using the Microsoft Visual C++ compiler, simply use the <code>/MT</code> compiler flag. The client will still use the <code>kernel32.dll</code> library but our private loader will load a separate copy of that library and redirect heap allocation automatically. Our private loader does not yet support locating SxS libraries, so using <code>/MD</code> will most likely not work unless using an older version of the compiler.<p>
Be aware that we have successfully built and tested several small C++ clients using the gcc toolchain, but have not performed extensive testing. Our clients successfully compile and run linked with the g++ libraries included in Red Hat Enterprise Linux 4, but on later distributions the pre-built libraries may not work and you may need to build static versions from the gcc sources with the appropriate flags (including -fPIC).<p>
We do not recommend that a client or its libraries invoke their own system calls as this bypasses DynamoRIO's monitoring of changes to the process address space and changes to threads or control flow. Such system calls will also not work properly on Linux when using sysenter on some systems. If you see an assert to that effect in debug build on Linux, try the <a class="el" href="using.html#op_sysenter">-sysenter_is_int80</a> option.<h2><a class="anchor" name="sec_comm">
Communication</a></h2>
Due to transparency limitations (see <a class="el" href="transparency.html">Client Transparency</a>), DynamoRIO can only support certain communication channels in and out of the target application process. These include:<p>
<ul>
<li>DynamoRIO deployment control and runtime options: see <a class="el" href="using.html#sec_deploy">Deployment</a> and <a class="el" href="using.html#sec_options">Fine-Tuning DynamoRIO: Runtime Parameters</a>. In particular, the deployment API allows users to pass up-front runtime information to the client.</li><li>Nudges: Since polling requires extra threads, and DynamoRIO tries not to create permanent extra threads (see <a class="el" href="transparency.html#sec_trans_thread">Thread Transparency</a>), a mechanism called <em>nudges</em> are the preferred mechanism for pushing data into the process. Nudges are used to notify DynamoRIO that it needs to re-read its options, or perform some other action. DynamoRIO also provides a custom nudge event that can be used by clients. See <a class="el" href="dr__config_8h.html#cbe479389db99b03fd1af89271b22efc">dr_nudge_process()</a> and <a class="el" href="dr__events_8h.html#9037603d0bd5bfca4198011adb8d10eb">dr_register_nudge_event()</a>.</li><li>Files can be used to send data out. An external process can wait on the file.</li></ul>
<h2><a class="anchor" name="sec_options">
Fine-Tuning DynamoRIO: Runtime Parameters</a></h2>
DynamoRIO's behavior can be fine-tuned using runtime parameters. Options are specified via <code>drconfig.exe</code>, <code>drrun.exe</code>, or <a class="el" href="dr__config_8h.html#303f226bbb38a435a622e9186627b427">dr_register_process()</a> on Windows and via the <code>drconfig</code> and <code>drrun</code> scripts on Linux. See <a class="el" href="using.html#sec_deploy">Deployment</a>.<p>
<ul>
<li><b>-follow_children</b>: <a class="anchor" name="op_children"></a> This option only applies to Windows. By default, DynamoRIO follows into only child processes configured via <code>drconfig.exe</code>. When <code>-follow_children</code> is specified DynamoRIO injects into all child processes.</li></ul>
<p>
<ul>
<li><b>-no_follow_children</b>: <a class="anchor" name="op_no_children"></a> This option only applies to Linux. By default, DynamoRIO follows into child processes across execve. When <code>-no_follow_children</code> is specified DynamoRIO only injects across an execve if a configuration file exists (typically created by <code>drconfig:</code> see <a class="el" href="using.html#sec_deploy">Deployment</a>) for the new application name.</li></ul>
<p>
<ul>
<li><b>-opt_memory</b>: <a class="anchor" name="op_memory"></a> Reduce memory usage, but potentially at the cost of performance. This option can result in memory savings as high as 20%, and usually incurs no noticable performance degradation. However, it conflicts with the <a class="el" href="using.html#op_enable">-enable_full_api option</a> and cannot be used with <a class="el" href="dr__tools_8h.html#56909cf76e4a71fca13731053ef48928">dr_unlink_flush_region()</a>.</li></ul>
<p>
<ul>
<li><b>-stack_size</b> <em>&lt;number&gt;</em>: <a class="anchor" name="op_stack_size"></a> DynamoRIO's per-thread stack is limited to 20KB by default (this may seem small, but this is much larger than its size when no client is present). This parameter can be used to increase the size; however, larger stack sizes use significantly more memory when targeting applications with hundreds of threads. The parameter can take a 'K' suffix, and must be a multiple of the page size (4K). This stack is used by the routines <a class="el" href="dr__ir__utils_8h.html#e7b7bd1e750b8a24ebf401fb6a6d6d5e">dr_insert_clean_call()</a>, <a class="el" href="dr__ir__utils_8h.html#9647e1300201596bc818ca33c95d4cc6">dr_swap_to_clean_stack()</a>, <a class="el" href="dr__ir__utils_8h.html#4608ec2db2a288aa5e2a53bb6d19054d">dr_prepare_for_call()</a>, <a class="el" href="dr__ir__utils_8h.html#359744bc2776333fbf8f057931ca8eeb">dr_insert_call_instrumentation()</a>, <a class="el" href="dr__ir__utils_8h.html#919e2106df67eaaa5bc6c49d736543b5">dr_insert_mbr_instrumentation()</a>, <a class="el" href="dr__ir__utils_8h.html#be09a1a1ca19b343279a65141c20f0a1">dr_insert_cbr_instrumentation()</a>, and <a class="el" href="dr__ir__utils_8h.html#3647b439211a8cd70c40478a4113e128">dr_insert_ubr_instrumentation()</a>. The stack is started fresh for each use, so <em>no persistent state may be stored on it</em>.</li></ul>
<p>
<ul>
<li><b>-thread_private</b>: <a class="anchor" name="op_thread_priv"></a> By default, DynamoRIO's code caches are shared across threads. This option requests code caches that are private to each thread. For applications with many threads, thread-private code caches use more memory. However, they can be more efficient, particularly when inserting thread-specific instrumentation.</li></ul>
<p>
<ul>
<li><b>-disable_traces</b>: By default, DynamoRIO builds both a <em>basic block</em> code cache and a <em>trace</em> code cache (see <a class="el" href="API_BT.html#sec_IR">Instruction Representation</a>). This option disables trace building, which can have a negative performance impact. When traces are disabled, <a class="el" href="dr__events_8h.html#88a19a6822654caf18c017e145f48a57">dr_register_trace_event()</a> has no effect. DynamoRIO tries to keep traces transparent to a client who is interested in all code and not only hot code, so there is rarely a reason to disable traces.</li></ul>
<p>
<ul>
<li><b>-enable_full_api</b>: <a class="anchor" name="op_enable"></a> DynamoRIO's default internal options balance performance with API usability. A few API functions, such as <a class="el" href="dr__tools_8h.html#56909cf76e4a71fca13731053ef48928">dr_unlink_flush_region()</a>, are incompatible with this default mode. Client users can gain access to the entire set of API functions with -enable_full_api. Note that this option may result in a small performance degradation.</li></ul>
<p>
<ul>
<li><b>-max_bb_instrs</b>: DynamoRIO stops building a basic block if it hits this application instruction count limit before hitting control flow or other block termination conditions. The default value is 1024; lower it if extensive client instrumentation is running into code cache size limit asserts.</li></ul>
<p>
<ul>
<li><b>-max_trace_bbs</b>: DynamoRIO will not build a trace with larger than this number of constituent basic block. The default value is 128; lower it if extensive client instrumentation is running into code cache size limit asserts.</li></ul>
<p>
<ul>
<li><b>-sysenter_is_int80</b>: <a class="anchor" name="op_sysenter"></a> This option only applies to Linux. If sysenter is the system call gateway, DynamoRIO normally hooks the vsyscall vdso page when it can. This option requests that DynamoRIO convert sysenter into int 0x80 instead. See <a class="el" href="using.html#sec_extlibs">Using External Libraries</a>.</li></ul>
<p>
<ul>
<li><b>-synch_at_exit</b>: <a class="anchor" name="op_synch_at_exit"></a> In debug builds, DynamoRIO synchronizes with all remaining threads at process exit time. In release build, for performance reasons, while DynamoRIO attempts to prevent other threads from executing (and thus running instrumentation code or raising events) beyond when their own thread exit events are raised, no guarantee is provided. If the client spends a long time in the process exit event, concurrent threads could cause racy access to data and thus errors. This option can be turned on in order to provide a guarantee and avoid races, but at a potential performance hit. This option can also be enabled programmatically via <a class="el" href="dr__tools_8h.html#902bfca468a7a2cc3dbc45b4bd127444">dr_request_synchronized_exit()</a>.</li></ul>
<p>
<ul>
<li><b>-syntax_intel</b>: <a class="anchor" name="op_syntax_intel"></a> This option causes DynamoRIO to output all disassembly using Intel syntax rather than the default AT&amp;T-style syntax.</li></ul>
<p>
<ul>
<li><b>-tracedump_text</b> and <b>-tracedump_binary</b>: These options cause DynamoRIO to output all traces that were created to the log file <em>traces-shared.0.TID.html</em>, where <em>TID</em> is the thread id of the initial thread; any thread-private traces (see <a class="el" href="using.html#op_thread_priv">-thread_private option</a>) produce per-thread files <em>traces.TID.html</em>. Traces are logged whenever they are flushed from the cache (which can be during execution or at the latest at program termination). The two options select either a text dump or a binary dump. The text dump takes up considerable room and time to dump, while the binary dump requires more effort to examine. The binary trace dump format is documented in <a class="el" href="dr__tools_8h.html" title="Main API routines, including transparency support.">dr_tools.h</a>, and a sample reader is provided with this distribution.</li></ul>
<p>
<ul>
<li><b>-tracedump_origins</b> When selected by itself with neither -tracedump_text nor -tracedump_binary, dumps only a text list of the constituent basic block tags of each trace to the trace log file. When combined with either of -tracedump_text or -tracedump_binary, adds a full disassembly of the constituent basic blocks to the selected dump.</li></ul>
<p>
Options controlling notifications from DynamoRIO:<p>
<ul>
<li><b>-msgbox_mask</b> <em>0xN</em>: <a class="anchor" name="op_msgbox_mask"></a> Controls whether DynamoRIO uses pop-up message boxes on Windows, or waits for a key press on Linux, when presenting information. The mask takes the following bitfields:<ul>
<li>INFORMATION = 0x1</li><li>WARNING = 0x2</li><li>ERROR = 0x4</li><li>CRITICAL = 0x8</li></ul>
<a class="el" href="dr__tools_8h.html#d444a204e7ca45f9965cfe973470375a">dr_messagebox()</a> is not affected by -msgbox_mask. For the provided Windows debug build -msgbox_mask defaults to 0xC. On Linux the default is 0, as this feature reads from standard input and might conflict with some applications.</li></ul>
<p>
<dl class="attention" compact><dt><b>Attention:</b></dt><dd>On Vista most Windows services are currently unable to display message boxes (see <a class="el" href="release_notes.html#limits_vista_service_messagebox">Limitations</a>). Since these services also don't have an associated console for stderr printing, the <a class="el" href="using.html#op_loglevel">-loglevel</a> and <a class="el" href="using.html#op_logmask">-logmask</a> options should be used instead. For the messages that would be displayed by -msgbox_mask, setting any bit in -logmask is sufficient for the message to be included in the logfile.</dd></dl>
<ul>
<li><b>-stderr_mask</b> <em>0xN</em>: Parallel to -msgbox_mask, but controls DynamoRIO's output to standard error. This option takes the same bitfields as -msgbox_mask. The API routine <a class="el" href="dr__tools_8h.html#f91a810b83f1173a5720a955c3d0fd4a">dr_is_notify_on()</a> can be used to determine if -stderr_mask is non-zero. Messages printed to stderr will only be visible for applications that have an attached console. For the provided Linux debug builds, -stderr_mask defaults to 0xF; for the Linux release builds, its default is 0xE. The default on Windows is 0.</li></ul>
<p>
Options aiding in debugging:<p>
<ul>
<li><b>-pause_on_error</b>: <a class="anchor" name="op_pause"></a> For Linux builds only, this option requests that when DynamoRIO encounters an assert or crash that it suspend the process so that a debugger can be attached.</li></ul>
<p>
<ul>
<li><b>-no_hide</b>: <a class="anchor" name="op_no_hide"></a> By default, DynamoRIO hides itself from the Windows module list, for transparency. However, this makes it more difficult to debug a process under DynamoRIO's control. The option -no_hide turns off this module hiding. This option is for Windows only.</li></ul>
<p>
Options available only in the debug build of DynamoRIO:<p>
<a class="anchor" name="op_loglevel"></a><ul>
<li><b>-loglevel</b> <em>N:</em> If N is greater than 0, DynamoRIO prints out a log of its actions. The greater the value of N, the more information DynamoRIO prints. Useful ranges are from 1 to 6. Verbosity is set to 0 by default, i.e., no log written. All log files are kept in a log directory. There is one directory per address space per run. The directories are named <em>app.NNN</em>, where <em>app</em> is the application name and <em>NNN</em> is a number that is incremented with each directory created. The directories are located by default in a subdirectory <em>logs</em> of the DynamoRIO home directory as specified in the <a class="el" href="dr__config_8h.html#303f226bbb38a435a622e9186627b427">dr_register_process()</a> or <code>drconfig.exe</code> configuration for the target application. On Linux the <code>drconfig</code> and <code>drrun</code> scripts allow for setting the logging directory. There is one main log file per directory named <em>app.0.TID.html</em>, where <em>TID</em> is the thread identifier of the initial thread. There is also a log file per thread, named <em>log.N.TID.html</em>, where <em>N</em> is the thread's creation ordinal and <em>TID</em> is its thread identifier. The loglevel may be changed during program execution, but if it began at 0 then it cannot be raised later. The -logmask parameter can be used to control which DynamoRIO modules output data to the log files. <a class="el" href="dr__tools_8h.html#332a14861f12823994465e8c9b6a3015">dr_log()</a> allows the client to write to the above logfiles.</li></ul>
<p>
<a class="anchor" name="op_logmask"></a><ul>
<li><b>-logmask</b> <em>0xN</em>: Selects which DynamoRIO modules print out logging information, at the -loglevel level. The mask is a combination of the LOG_ bitfields listed in <a class="el" href="dr__tools_8h.html" title="Main API routines, including transparency support.">dr_tools.h</a> (<a class="el" href="dr__tools_8h.html#7574ce4aa047de1f4a564c9b441e69dc">LOG_ALL</a> selects all modules).</li></ul>
<p>
<ul>
<li><b>-ignore_assert_list</b> <b>'*'</b>: <a class="anchor" name="op_ignore_assert"></a> Ignores all DynamoRIO asserts of the form "&lt;file&gt;:1234". * may be replaced by a ; separated lists of individual asserts to ignore "foo.c:333;bar.c:12".</li></ul>
<h2><a class="anchor" name="sec_debugging">
Diagnosing and Reporting Problems</a></h2>
When using a complex system like DynamoRIO, problems can be challenging to diagnose. This section contains some debugging tips and shows how to get help.<h3><a class="anchor" name="sec_reporting">
Obtaining Help and Reporting Problems</a></h3>
For questions and discussion, join the <a href="http://groups.google.com/group/dynamorio-users/">DynamoRIO Users group</a>.<p>
For bug reports, use the <a href="http://code.google.com/p/dynamorio/issues/list">Issue Tracker</a>. Please include <a href="http://code.google.com/p/dynamorio/wiki/BugReporting">a detailed description</a> of the problem (is it an application crash? a DynamoRIO crash? a hang? a debug build assert?) and how to reproduce it.<h3><a class="anchor" name="sec_diagnosing">
Debugging Tips</a></h3>
<ul>
<li>DynamoRIO disables itself when Windows is booted in safe mode (without networking). Thus, if a crash occurs in a Windows service under DynamoRIO, rebooting in safe mode will allow recovery.</li></ul>
<p>
<ul>
<li>If the client library doesn't seem to function for a given process, it is likely that the client library wasn't loaded due to errors.</li></ul>
<p>
<dl class="user" compact><dt><b></b></dt><dd>One of the common situations where this happens is when the target application runs as a different user than the user who created the client library. This results in the application process not having the right permissions to access the client library.</dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>Try running the process under the debug mode of DynamoRIO (see <a class="el" href="dr__config_8h.html#303f226bbb38a435a622e9186627b427">dr_register_process()</a>), where diagnostic messages are raised on errors like client library permissions. To see all messages, set the notification options like -msgbox_mask and -stderr_mask options to 0xf (see <a class="el" href="using.html#sec_options">Fine-Tuning DynamoRIO: Runtime Parameters</a>). This will alert you to the problem.</dd></dl>
<ul>
<li>DynamoRIO asserts of the form "&lt;file&gt;:1234" can be suppressed with the <a class="el" href="using.html#op_ignore_assert">-ignore_assert_list '*'</a> option. * may be replaced by a ; separated lists of individual asserts to suppress as so "-ignore_assert_list 'foo.c:333;bar.c:12'".</li></ul>
<p>
<ul>
<li>A process under control of DynamoRIO can be executed within a debugger. On Windows it is best to set the <a class="el" href="using.html#op_no_hide">-no_hide</a> option so the debugger can see the DynamoRIO library.</li></ul>
<p>
<dl class="user" compact><dt><b></b></dt><dd>To attach to a process on Windows, use the <a class="el" href="using.html#op_msgbox_mask">-msgbox_mask</a> option and attach the debugger while the dialog box has paused the application. On Linux, the same option can be used and the debugger attached while the application waits for enter to be pressed. Since this may not work for applications that themselves read from standard input, an alternative exists: the <a class="el" href="using.html#op_pause">-pause_on_error</a> option allows attaching a debugger when a problem occurs. To run an application on Linux under a debugger from the start you can perform the work of the <code>drrun</code> script by setting the LD_LIBRARY_PATH and LD_PRELOAD environment variables from within the debugger.</dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>For debugging on Windows we recommend using windbg version 6.3.0017 (<b>not</b> the newer versions 6.4 through 6.8, as they have problems displaying callstacks involving DynamoRIO code).</dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>Take care when setting breakpoints in an application running under DynamoRIO. If the debugger inserts <code>int3</code> it can find its way into the code cache and cause errors as the debugger will not realize that the resulting trap is from a breakpoint. Use read watchpoints on the code in question instead.</dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>On Windows, if an application invokes OuputDebugString() while under a debugger, DynamoRIO can end up losing control of the application.</dd></dl>
<ul>
<li>The DynamoRIO header files have typedefs that may conflict with other header files wrapped in ifndef DR_DO_NOT_DEFINE_&lt;type&gt; to make it easier to work around such conflicts. </li></ul>
</div>
<hr size="1"><address style="text-align: center;"><small>
<img border=0 src="favicon.png"> &nbsp; DynamoRIO API version 2.0.0 --- Thu Apr 22 00:18:19 2010 
&nbsp; <img border=0 src="favicon.png">
</body>
</html>
