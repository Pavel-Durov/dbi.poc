<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>DynamoRIO API: dr_ir_utils.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
<link rel="shortcut icon" type="image/x-icon" href="favicon.ico" />
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="contents">
<h1>dr_ir_utils.h File Reference</h1>Code transformation utilities.  
<a href="dr__ir__utils_8h.html#_details">More...</a>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a> { , <br>
&nbsp;&nbsp;<a class="el" href="dr__ir__utils_8h.html#89a6b714ff24d91d78589877047a29b9e4cd78beccb2525acc61f2536ba1ea71">SPILL_SLOT_2</a> =  1, 
<br>
&nbsp;&nbsp;<a class="el" href="dr__ir__utils_8h.html#89a6b714ff24d91d78589877047a29b9446ae7a7df24d2c3abae567a17289566">SPILL_SLOT_3</a> =  2, 
<br>
&nbsp;&nbsp;<a class="el" href="dr__ir__utils_8h.html#89a6b714ff24d91d78589877047a29b9b1b97fb0822126941b211160965034e4">SPILL_SLOT_4</a> =  3, 
<br>
&nbsp;&nbsp;<a class="el" href="dr__ir__utils_8h.html#89a6b714ff24d91d78589877047a29b957734b157aa48d5db278cb1aa372cd56">SPILL_SLOT_5</a> =  4, 
<br>
&nbsp;&nbsp;<a class="el" href="dr__ir__utils_8h.html#89a6b714ff24d91d78589877047a29b9c4c22f3fdbacb7b37b55484b5577f1e0">SPILL_SLOT_6</a> =  5, 
<br>
&nbsp;&nbsp;<a class="el" href="dr__ir__utils_8h.html#89a6b714ff24d91d78589877047a29b9bbff886ccbde7dc9ce9bd4e379eb7ac3">SPILL_SLOT_7</a> =  6, 
<br>
&nbsp;&nbsp;<a class="el" href="dr__ir__utils_8h.html#89a6b714ff24d91d78589877047a29b96bbd68ecb5a36a22f247c5806fa5fec9">SPILL_SLOT_8</a> =  7, 
<br>
&nbsp;&nbsp;<a class="el" href="dr__ir__utils_8h.html#89a6b714ff24d91d78589877047a29b9a1bffc7b66f58d71b52284c0f49d5a53">SPILL_SLOT_9</a> =  8, 
<br>
&nbsp;&nbsp;<a class="el" href="dr__ir__utils_8h.html#89a6b714ff24d91d78589877047a29b944005b876b8364b0433f880f5b9b1a68">SPILL_SLOT_10</a> =  9, 
<br>
&nbsp;&nbsp;<a class="el" href="dr__ir__utils_8h.html#89a6b714ff24d91d78589877047a29b978ba623c508dc9db382bd16205e862c5">SPILL_SLOT_11</a> =  10, 
<br>
&nbsp;&nbsp;<a class="el" href="dr__ir__utils_8h.html#89a6b714ff24d91d78589877047a29b93bd3a0c1a09dd08a8cf3cdc99902767a">SPILL_SLOT_12</a> =  11, 
<br>
&nbsp;&nbsp;<a class="el" href="dr__ir__utils_8h.html#89a6b714ff24d91d78589877047a29b92a009fac1a98d5546313cb17b0a026a7">SPILL_SLOT_13</a> =  12, 
<br>
&nbsp;&nbsp;<a class="el" href="dr__ir__utils_8h.html#89a6b714ff24d91d78589877047a29b9ce6bda60e6d81dc4914384f28d2e159e">SPILL_SLOT_14</a> =  13, 
<br>
&nbsp;&nbsp;<a class="el" href="dr__ir__utils_8h.html#89a6b714ff24d91d78589877047a29b9529c3a41f0f3324929310b94915de96e">SPILL_SLOT_15</a> =  14, 
<br>
&nbsp;&nbsp;<a class="el" href="dr__ir__utils_8h.html#89a6b714ff24d91d78589877047a29b93d4436b445175a7088cd958a7e81f9b8">SPILL_SLOT_16</a> =  15, 
<br>
&nbsp;&nbsp;<a class="el" href="dr__ir__utils_8h.html#89a6b714ff24d91d78589877047a29b98483a4f53a6c380d0356a0596745ce09">SPILL_SLOT_17</a> =  16, 
<br>
&nbsp;&nbsp;<a class="el" href="dr__ir__utils_8h.html#89a6b714ff24d91d78589877047a29b9794503b196c55da22002fc15549916fa">SPILL_SLOT_MAX</a> =  SPILL_SLOT_17
<br>
 }</td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#df9a4f63eafc7f9725f7d5bf1725ab5c">set_x86_mode</a> (void *drcontext, bool x86)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a18c8ca0720c97403a0fa9371ae792e5">get_x86_mode</a> (void *drcontext)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#f294ac021c84f5ec47230ee7df0e6c02">dr_save_reg</a> (void *drcontext, instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, reg_id_t reg, <a class="el" href="dr__ir__utils_8h.html#89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a> slot)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#453bc3ecddb4298ffdc1c429f30881b8">dr_restore_reg</a> (void *drcontext, instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, reg_id_t reg, <a class="el" href="dr__ir__utils_8h.html#89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a> slot)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="dr__ir__utils_8h.html#89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#762389f8ae9d809fd7b8f1418cdbd5ae">dr_max_opnd_accessible_spill_slot</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structopnd__t.html">opnd_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#5eab608c134db044f2d9453a8407d470">dr_reg_spill_slot_opnd</a> (void *drcontext, <a class="el" href="dr__ir__utils_8h.html#89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a> slot)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">reg_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#bb63ecfaa5256688bab9a2921fc19227">dr_read_saved_reg</a> (void *drcontext, <a class="el" href="dr__ir__utils_8h.html#89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a> slot)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#bf8d50d718883a1caf6a2de0fb3dbce3">dr_write_saved_reg</a> (void *drcontext, <a class="el" href="dr__ir__utils_8h.html#89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a> slot, reg_t value)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#44636ca6809a9fb22cf817701de9ee09">dr_save_arith_flags</a> (void *drcontext, instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, <a class="el" href="dr__ir__utils_8h.html#89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a> slot)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#563b0de37a51cb2e84337deef30a57cf">dr_restore_arith_flags</a> (void *drcontext, instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, <a class="el" href="dr__ir__utils_8h.html#89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a> slot)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#3831354cc7402d68719d8055fb3e9931">dr_insert_read_tls_field</a> (void *drcontext, instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, reg_id_t reg)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#982089284bd51339f448ec4b3928d3b4">dr_insert_write_tls_field</a> (void *drcontext, instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, reg_id_t reg)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#3b0b7e9e09a9a85ca1a707da3ded6f69">instrlist_meta_preinsert</a> (instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#98218650e1f61b58c5478cf68e25d9da">instrlist_meta_postinsert</a> (instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#824eaa9075a7aaf443b4cc4180eec81e">instrlist_meta_append</a> (instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#ffe811040a2962e5c6920a3c523212ab">instrlist_meta_fault_preinsert</a> (instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#6ea095671bab4239c659d17d4a9cda56">instrlist_meta_fault_postinsert</a> (instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#94a1526c7b520c9aefbd775adfc57108">instrlist_meta_fault_append</a> (instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#e7b7bd1e750b8a24ebf401fb6a6d6d5e">dr_insert_clean_call</a> (void *drcontext, instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, void *callee, bool save_fpstate, uint num_args,...)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#f2a3575059c29dae25ab02c9eb1d0ce9">dr_insert_call</a> (void *drcontext, instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, void *callee, uint num_args,...)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">uint&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#4608ec2db2a288aa5e2a53bb6d19054d">dr_prepare_for_call</a> (void *drcontext, instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#466c814771a85f9b53e6681f4dc5c957">dr_cleanup_after_call</a> (void *drcontext, instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, uint sizeof_param_area)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#9647e1300201596bc818ca33c95d4cc6">dr_swap_to_clean_stack</a> (void *drcontext, instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#9a2c851eeeee7e669f3e6a7b877977d1">dr_restore_app_stack</a> (void *drcontext, instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#359744bc2776333fbf8f057931ca8eeb">dr_insert_call_instrumentation</a> (void *drcontext, instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *instr, void *callee)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#919e2106df67eaaa5bc6c49d736543b5">dr_insert_mbr_instrumentation</a> (void *drcontext, instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *instr, void *callee, <a class="el" href="dr__ir__utils_8h.html#89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a> scratch_slot)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#be09a1a1ca19b343279a65141c20f0a1">dr_insert_cbr_instrumentation</a> (void *drcontext, instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *instr, void *callee)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#3647b439211a8cd70c40478a4113e128">dr_insert_ubr_instrumentation</a> (void *drcontext, instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *instr, void *callee)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#5921c4f301ea05885f305f9a30b3c0b0">dr_mcontext_xmm_fields_valid</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#d78c531d7527907652e770960c07af38">dr_get_mcontext</a> (void *drcontext, <a class="el" href="struct__dr__mcontext__t.html">dr_mcontext_t</a> *context, int *app_errno)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#ed77cd48eccfdd8eaf8c33bd6b53d8b2">dr_set_mcontext</a> (void *drcontext, <a class="el" href="struct__dr__mcontext__t.html">dr_mcontext_t</a> *context, const int *app_errno)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#86554ab412927d0a4f1b90d72f64a858">dr_redirect_execution</a> (<a class="el" href="struct__dr__mcontext__t.html">dr_mcontext_t</a> *mcontext, int app_errno)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">app_pc&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#e30dfcf7ed64d1923b9f4e101cc983cb">decode_memory_reference_size</a> (void *drcontext, app_pc pc, uint *size_in_bytes)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">byte *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a9055369e97457b8656fc8c3c0d6d49d">decode_eflags_usage</a> (void *drcontext, byte *pc, uint *usage)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">byte *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#6f62065c2b7e764fe9fb0f46557e2264">decode</a> (void *drcontext, byte *pc, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">byte *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#ad81737da9662a4e6bf697757cb25ddf">decode_from_copy</a> (void *drcontext, byte *copy_pc, byte *orig_pc, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">instrlist_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#1321b3d18f45de750edfe2ff6ba151d2">decode_as_bb</a> (void *drcontext, byte *start_pc)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">instrlist_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#dbe7afa4c8654b0ee88ccd88d1f2d698">decode_trace</a> (void *drcontext, void *tag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">byte&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#4946f4ab326ef4695fce55eb434c2cde">decode_first_opcode_byte</a> (int opcode)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#3952e7614f4bf8e62f360f08683ad8a0">decode_opcode_name</a> (int opcode)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#2a8b8756bdc063a88d206f17cc5e3e2c">decode_sizeof</a> (void *drcontext, byte *pc, int *num_prefixes _IF_X64(uint *rip_rel_pos))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">byte *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#813105fc7196a85e73580d1adfb8d336">decode_next_pc</a> (void *drcontext, byte *pc)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">byte *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#526fc9f23e78b5f1321891dc8f81b1b7">disassemble</a> (void *drcontext, byte *pc, file_t outfile)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">byte *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#2c491ac5c40069f120b0ef512ccc7166">disassemble_with_info</a> (void *drcontext, byte *pc, file_t outfile, bool show_pc, bool show_bytes)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">byte *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#2e6a5d44647c481f50ee5208281617ba">disassemble_from_copy</a> (void *drcontext, byte *copy_pc, byte *orig_pc, file_t outfile, bool show_pc, bool show_bytes)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Code transformation utilities. 
<p>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="89a6b714ff24d91d78589877047a29b9"></a><!-- doxytag: member="dr_ir_utils.h::dr_spill_slot_t" ref="89a6b714ff24d91d78589877047a29b9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="dr__ir__utils_8h.html#89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
An enum of spill slots to use with <a class="el" href="dr__ir__utils_8h.html#f294ac021c84f5ec47230ee7df0e6c02">dr_save_reg()</a>, <a class="el" href="dr__ir__utils_8h.html#453bc3ecddb4298ffdc1c429f30881b8">dr_restore_reg()</a>, <a class="el" href="dr__ir__utils_8h.html#44636ca6809a9fb22cf817701de9ee09">dr_save_arith_flags()</a>, <a class="el" href="dr__ir__utils_8h.html#563b0de37a51cb2e84337deef30a57cf">dr_restore_arith_flags()</a> and <a class="el" href="dr__ir__utils_8h.html#919e2106df67eaaa5bc6c49d736543b5">dr_insert_mbr_instrumentation()</a>. Values stored in spill slots remain valid only until the next non-meta (i.e. application) instruction. Spill slots can be accessed/modifed during clean calls and restore_state_events (see <a class="el" href="dr__events_8h.html#e7a179ac7a2d01157e1ab2852f50c902">dr_register_restore_state_event()</a>) with <a class="el" href="dr__ir__utils_8h.html#bb63ecfaa5256688bab9a2921fc19227">dr_read_saved_reg()</a> and <a class="el" href="dr__ir__utils_8h.html#bf8d50d718883a1caf6a2de0fb3dbce3">dr_write_saved_reg()</a>.<p>
Spill slots &lt;= <a class="el" href="dr__ir__utils_8h.html#762389f8ae9d809fd7b8f1418cdbd5ae">dr_max_opnd_accessible_spill_slot()</a> can be directly accessed from client inserted instructions with <a class="el" href="dr__ir__utils_8h.html#5eab608c134db044f2d9453a8407d470">dr_reg_spill_slot_opnd()</a>.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Some spill slots may be faster to access than others. Currently spill slots 1-3 are significantly faster to access than the others when running without -thread_private. When running with -thread_private all spill slots are expected to have similar performance. This is subject to change in future releases, but clients may assume that smaller numbered spill slots are faster or the same cost to access as larger numbered spill slots.<p>
The number of spill slots may change in future releases. </dd></dl>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="89a6b714ff24d91d78589877047a29b9e4cd78beccb2525acc61f2536ba1ea71"></a><!-- doxytag: member="SPILL_SLOT_2" ref="89a6b714ff24d91d78589877047a29b9e4cd78beccb2525acc61f2536ba1ea71" args="" -->SPILL_SLOT_2</em>&nbsp;</td><td>
spill slot for register save/restore routines </td></tr>
<tr><td valign="top"><em><a class="anchor" name="89a6b714ff24d91d78589877047a29b9446ae7a7df24d2c3abae567a17289566"></a><!-- doxytag: member="SPILL_SLOT_3" ref="89a6b714ff24d91d78589877047a29b9446ae7a7df24d2c3abae567a17289566" args="" -->SPILL_SLOT_3</em>&nbsp;</td><td>
spill slot for register save/restore routines </td></tr>
<tr><td valign="top"><em><a class="anchor" name="89a6b714ff24d91d78589877047a29b9b1b97fb0822126941b211160965034e4"></a><!-- doxytag: member="SPILL_SLOT_4" ref="89a6b714ff24d91d78589877047a29b9b1b97fb0822126941b211160965034e4" args="" -->SPILL_SLOT_4</em>&nbsp;</td><td>
spill slot for register save/restore routines </td></tr>
<tr><td valign="top"><em><a class="anchor" name="89a6b714ff24d91d78589877047a29b957734b157aa48d5db278cb1aa372cd56"></a><!-- doxytag: member="SPILL_SLOT_5" ref="89a6b714ff24d91d78589877047a29b957734b157aa48d5db278cb1aa372cd56" args="" -->SPILL_SLOT_5</em>&nbsp;</td><td>
spill slot for register save/restore routines </td></tr>
<tr><td valign="top"><em><a class="anchor" name="89a6b714ff24d91d78589877047a29b9c4c22f3fdbacb7b37b55484b5577f1e0"></a><!-- doxytag: member="SPILL_SLOT_6" ref="89a6b714ff24d91d78589877047a29b9c4c22f3fdbacb7b37b55484b5577f1e0" args="" -->SPILL_SLOT_6</em>&nbsp;</td><td>
spill slot for register save/restore routines </td></tr>
<tr><td valign="top"><em><a class="anchor" name="89a6b714ff24d91d78589877047a29b9bbff886ccbde7dc9ce9bd4e379eb7ac3"></a><!-- doxytag: member="SPILL_SLOT_7" ref="89a6b714ff24d91d78589877047a29b9bbff886ccbde7dc9ce9bd4e379eb7ac3" args="" -->SPILL_SLOT_7</em>&nbsp;</td><td>
spill slot for register save/restore routines </td></tr>
<tr><td valign="top"><em><a class="anchor" name="89a6b714ff24d91d78589877047a29b96bbd68ecb5a36a22f247c5806fa5fec9"></a><!-- doxytag: member="SPILL_SLOT_8" ref="89a6b714ff24d91d78589877047a29b96bbd68ecb5a36a22f247c5806fa5fec9" args="" -->SPILL_SLOT_8</em>&nbsp;</td><td>
spill slot for register save/restore routines </td></tr>
<tr><td valign="top"><em><a class="anchor" name="89a6b714ff24d91d78589877047a29b9a1bffc7b66f58d71b52284c0f49d5a53"></a><!-- doxytag: member="SPILL_SLOT_9" ref="89a6b714ff24d91d78589877047a29b9a1bffc7b66f58d71b52284c0f49d5a53" args="" -->SPILL_SLOT_9</em>&nbsp;</td><td>
spill slot for register save/restore routines </td></tr>
<tr><td valign="top"><em><a class="anchor" name="89a6b714ff24d91d78589877047a29b944005b876b8364b0433f880f5b9b1a68"></a><!-- doxytag: member="SPILL_SLOT_10" ref="89a6b714ff24d91d78589877047a29b944005b876b8364b0433f880f5b9b1a68" args="" -->SPILL_SLOT_10</em>&nbsp;</td><td>
spill slot for register save/restore routines </td></tr>
<tr><td valign="top"><em><a class="anchor" name="89a6b714ff24d91d78589877047a29b978ba623c508dc9db382bd16205e862c5"></a><!-- doxytag: member="SPILL_SLOT_11" ref="89a6b714ff24d91d78589877047a29b978ba623c508dc9db382bd16205e862c5" args="" -->SPILL_SLOT_11</em>&nbsp;</td><td>
spill slot for register save/restore routines <dl class="note" compact><dt><b>Note:</b></dt><dd>x64 only </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="89a6b714ff24d91d78589877047a29b93bd3a0c1a09dd08a8cf3cdc99902767a"></a><!-- doxytag: member="SPILL_SLOT_12" ref="89a6b714ff24d91d78589877047a29b93bd3a0c1a09dd08a8cf3cdc99902767a" args="" -->SPILL_SLOT_12</em>&nbsp;</td><td>
spill slot for register save/restore routines <dl class="note" compact><dt><b>Note:</b></dt><dd>x64 only </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="89a6b714ff24d91d78589877047a29b92a009fac1a98d5546313cb17b0a026a7"></a><!-- doxytag: member="SPILL_SLOT_13" ref="89a6b714ff24d91d78589877047a29b92a009fac1a98d5546313cb17b0a026a7" args="" -->SPILL_SLOT_13</em>&nbsp;</td><td>
spill slot for register save/restore routines <dl class="note" compact><dt><b>Note:</b></dt><dd>x64 only </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="89a6b714ff24d91d78589877047a29b9ce6bda60e6d81dc4914384f28d2e159e"></a><!-- doxytag: member="SPILL_SLOT_14" ref="89a6b714ff24d91d78589877047a29b9ce6bda60e6d81dc4914384f28d2e159e" args="" -->SPILL_SLOT_14</em>&nbsp;</td><td>
spill slot for register save/restore routines <dl class="note" compact><dt><b>Note:</b></dt><dd>x64 only </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="89a6b714ff24d91d78589877047a29b9529c3a41f0f3324929310b94915de96e"></a><!-- doxytag: member="SPILL_SLOT_15" ref="89a6b714ff24d91d78589877047a29b9529c3a41f0f3324929310b94915de96e" args="" -->SPILL_SLOT_15</em>&nbsp;</td><td>
spill slot for register save/restore routines <dl class="note" compact><dt><b>Note:</b></dt><dd>x64 only </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="89a6b714ff24d91d78589877047a29b93d4436b445175a7088cd958a7e81f9b8"></a><!-- doxytag: member="SPILL_SLOT_16" ref="89a6b714ff24d91d78589877047a29b93d4436b445175a7088cd958a7e81f9b8" args="" -->SPILL_SLOT_16</em>&nbsp;</td><td>
spill slot for register save/restore routines <dl class="note" compact><dt><b>Note:</b></dt><dd>x64 only </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="89a6b714ff24d91d78589877047a29b98483a4f53a6c380d0356a0596745ce09"></a><!-- doxytag: member="SPILL_SLOT_17" ref="89a6b714ff24d91d78589877047a29b98483a4f53a6c380d0356a0596745ce09" args="" -->SPILL_SLOT_17</em>&nbsp;</td><td>
spill slot for register save/restore routines <dl class="note" compact><dt><b>Note:</b></dt><dd>x64 only </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="89a6b714ff24d91d78589877047a29b9794503b196c55da22002fc15549916fa"></a><!-- doxytag: member="SPILL_SLOT_MAX" ref="89a6b714ff24d91d78589877047a29b9794503b196c55da22002fc15549916fa" args="" -->SPILL_SLOT_MAX</em>&nbsp;</td><td>
spill slot for register save/restore routines <dl class="note" compact><dt><b>Note:</b></dt><dd>x64 only </dd></dl>
</td></tr>
</table>
</dl>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="6f62065c2b7e764fe9fb0f46557e2264"></a><!-- doxytag: member="dr_ir_utils.h::decode" ref="6f62065c2b7e764fe9fb0f46557e2264" args="(void *drcontext, byte *pc, instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte* decode           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&nbsp;</td>
          <td class="paramname"> <em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Decodes the instruction at address <code>pc</code> into <code>instr</code>, filling in the instruction's opcode, eflags usage, prefixes, and operands. The instruction's raw bits are set to valid and pointed at <code>pc</code> (xref <a class="el" href="dr__ir__instr_8h.html#964928ee44090aba9aef343c5d34df5c">instr_get_raw_bits()</a>). Assumes that <code>instr</code> is already initialized, but uses the x86/x64 mode for the thread <code>dcontext</code> rather than that set in instr. If caller is re-using same <a class="el" href="structinstr__t.html">instr_t</a> struct over multiple decodings, caller should call <a class="el" href="dr__ir__instr_8h.html#ccd2bdee07d2e6ca0be3b252bc7b913f">instr_reset()</a> or <a class="el" href="dr__ir__instr_8h.html#b9b44a1db49dc5cd8da8b6b27fa47d50">instr_reuse()</a>. Returns the address of the next byte after the decoded instruction. Returns NULL on decoding an invalid instr and sets opcode to OP_INVALID. 
</div>
</div><p>
<a class="anchor" name="1321b3d18f45de750edfe2ff6ba151d2"></a><!-- doxytag: member="dr_ir_utils.h::decode_as_bb" ref="1321b3d18f45de750edfe2ff6ba151d2" args="(void *drcontext, byte *start_pc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">instrlist_t* decode_as_bb           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&nbsp;</td>
          <td class="paramname"> <em>start_pc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Client routine to decode instructions at an arbitrary app address, following all the rules that DynamoRIO follows internally for terminating basic blocks. Note that DynamoRIO does not validate that <code>start_pc</code> is actually the first instruction of a basic block. <dl class="note" compact><dt><b>Note:</b></dt><dd>Caller is reponsible for freeing the list and its instrs! </dd></dl>

</div>
</div><p>
<a class="anchor" name="a9055369e97457b8656fc8c3c0d6d49d"></a><!-- doxytag: member="dr_ir_utils.h::decode_eflags_usage" ref="a9055369e97457b8656fc8c3c0d6d49d" args="(void *drcontext, byte *pc, uint *usage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte* decode_eflags_usage           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&nbsp;</td>
          <td class="paramname"> <em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&nbsp;</td>
          <td class="paramname"> <em>usage</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Decodes only enough of the instruction at address <code>pc</code> to determine its eflags usage, which is returned in <code>usage</code> as EFLAGS_ constants or'ed together. Returns the address of the next byte after the decoded instruction. Returns NULL on decoding an invalid instruction. 
</div>
</div><p>
<a class="anchor" name="4946f4ab326ef4695fce55eb434c2cde"></a><!-- doxytag: member="dr_ir_utils.h::decode_first_opcode_byte" ref="4946f4ab326ef4695fce55eb434c2cde" args="(int opcode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte decode_first_opcode_byte           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>opcode</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Given an OP_ constant, returns the first byte of its opcode when encoded as an IA-32 instruction. 
</div>
</div><p>
<a class="anchor" name="ad81737da9662a4e6bf697757cb25ddf"></a><!-- doxytag: member="dr_ir_utils.h::decode_from_copy" ref="ad81737da9662a4e6bf697757cb25ddf" args="(void *drcontext, byte *copy_pc, byte *orig_pc, instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte* decode_from_copy           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&nbsp;</td>
          <td class="paramname"> <em>copy_pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&nbsp;</td>
          <td class="paramname"> <em>orig_pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Decodes the instruction at address <code>copy_pc</code> into <code>instr</code> as though it were located at address <code>orig_pc</code>. Any pc-relative operands have their values calculated as though the instruction were actually at <code>orig_pc</code>, though that address is never de-referenced. The instruction's raw bits are not valid, but its translation field (see instr_get_translation()) is set to <code>orig_pc</code>. The instruction's opcode, eflags usage, prefixes, and operands are all filled in. Assumes that <code>instr</code> is already initialized, but uses the x86/x64 mode for the thread <code>dcontext</code> rather than that set in instr. If caller is re-using same <a class="el" href="structinstr__t.html">instr_t</a> struct over multiple decodings, caller should call <a class="el" href="dr__ir__instr_8h.html#ccd2bdee07d2e6ca0be3b252bc7b913f">instr_reset()</a> or <a class="el" href="dr__ir__instr_8h.html#b9b44a1db49dc5cd8da8b6b27fa47d50">instr_reuse()</a>. Returns the address of the next byte after the decoded instruction copy at <code>copy_pc</code>. Returns NULL on decoding an invalid instr and sets opcode to OP_INVALID. 
</div>
</div><p>
<a class="anchor" name="e30dfcf7ed64d1923b9f4e101cc983cb"></a><!-- doxytag: member="dr_ir_utils.h::decode_memory_reference_size" ref="e30dfcf7ed64d1923b9f4e101cc983cb" args="(void *drcontext, app_pc pc, uint *size_in_bytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">app_pc decode_memory_reference_size           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">app_pc&nbsp;</td>
          <td class="paramname"> <em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&nbsp;</td>
          <td class="paramname"> <em>size_in_bytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculates the size, in bytes, of the memory read or write of the instr at <code>pc</code>. If the instruction is a repeating string instruction, considers only one iteration. Returns the pc of the following instruction. If the instruction at <code>pc</code> does not reference memory, or is invalid, returns NULL. 
</div>
</div><p>
<a class="anchor" name="813105fc7196a85e73580d1adfb8d336"></a><!-- doxytag: member="dr_ir_utils.h::decode_next_pc" ref="813105fc7196a85e73580d1adfb8d336" args="(void *drcontext, byte *pc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte* decode_next_pc           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&nbsp;</td>
          <td class="paramname"> <em>pc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Decodes only enough of the instruction at address <code>pc</code> to determine its size. Returns the address of the byte following the instruction. Returns NULL on decoding an invalid instruction. 
</div>
</div><p>
<a class="anchor" name="3952e7614f4bf8e62f360f08683ad8a0"></a><!-- doxytag: member="dr_ir_utils.h::decode_opcode_name" ref="3952e7614f4bf8e62f360f08683ad8a0" args="(int opcode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* decode_opcode_name           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>opcode</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Given an OP_ constant, returns the string name of its opcode. 
</div>
</div><p>
<a class="anchor" name="2a8b8756bdc063a88d206f17cc5e3e2c"></a><!-- doxytag: member="dr_ir_utils.h::decode_sizeof" ref="2a8b8756bdc063a88d206f17cc5e3e2c" args="(void *drcontext, byte *pc, int *num_prefixes _IF_X64(uint *rip_rel_pos))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int decode_sizeof           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&nbsp;</td>
          <td class="paramname"> <em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *num_prefixes &nbsp;</td>
          <td class="paramname"> <em>_IF_X64</em>uint *rip_rel_pos</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Decodes only enough of the instruction at address <code>pc</code> to determine its size. Returns that size. If <code>num_prefixes</code> is non-NULL, returns the number of prefix bytes. If <code>rip_rel_pos</code> is non-NULL, returns the offset into the instruction of a rip-relative addressing displacement (for data only: ignores control-transfer relative addressing), or 0 if none. May return 0 size for certain invalid instructions. 
</div>
</div><p>
<a class="anchor" name="dbe7afa4c8654b0ee88ccd88d1f2d698"></a><!-- doxytag: member="dr_ir_utils.h::decode_trace" ref="dbe7afa4c8654b0ee88ccd88d1f2d698" args="(void *drcontext, void *tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">instrlist_t* decode_trace           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>tag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Decodes the trace with tag <code>tag</code>, and returns an instrlist_t of the instructions comprising that fragment. If <code>tag</code> is not a valid tag for an existing trace, the routine returns NULL. Clients can use <a class="el" href="dr__tools_8h.html#1d4c9a29f1c962457c123322aa3e1931">dr_trace_exists_at()</a> to determine whether the trace exists. <dl class="note" compact><dt><b>Note:</b></dt><dd>Unlike the instruction list presented by the trace event, the list here does not include any existing client modifications. If client-modified instructions are needed, it is the responsibility of the client to record or recreate that list itself. <p>
This routine does not support decoding thread-private traces created by other than the calling thread. </dd></dl>

</div>
</div><p>
<a class="anchor" name="526fc9f23e78b5f1321891dc8f81b1b7"></a><!-- doxytag: member="dr_ir_utils.h::disassemble" ref="526fc9f23e78b5f1321891dc8f81b1b7" args="(void *drcontext, byte *pc, file_t outfile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte* disassemble           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&nbsp;</td>
          <td class="paramname"> <em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">file_t&nbsp;</td>
          <td class="paramname"> <em>outfile</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Decodes and then prints the instruction at address <code>pc</code> to file <code>outfile</code>. The default is to use AT&amp;T-style syntax, unless the <a class="el" href="using.html#op_syntax_intel">-syntax_intel</a> runtime option is specified. Returns the address of the subsequent instruction, or NULL if the instruction at <code>pc</code> is invalid. 
</div>
</div><p>
<a class="anchor" name="2e6a5d44647c481f50ee5208281617ba"></a><!-- doxytag: member="dr_ir_utils.h::disassemble_from_copy" ref="2e6a5d44647c481f50ee5208281617ba" args="(void *drcontext, byte *copy_pc, byte *orig_pc, file_t outfile, bool show_pc, bool show_bytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte* disassemble_from_copy           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&nbsp;</td>
          <td class="paramname"> <em>copy_pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&nbsp;</td>
          <td class="paramname"> <em>orig_pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">file_t&nbsp;</td>
          <td class="paramname"> <em>outfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>show_pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>show_bytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Decodes the instruction at address <code>copy_pc</code> as though it were located at address <code>orig_pc</code>, and then prints the instruction to file <code>outfile</code>. Prior to the instruction the address <code>orig_pc</code> is printed if <code>show_pc</code> and the raw bytes are printed if <code>show_bytes</code>. The default is to use AT&amp;T-style syntax, unless the <a class="el" href="using.html#op_syntax_intel">-syntax_intel</a> runtime option is specified. Returns the address of the subsequent instruction after the copy at <code>copy_pc</code>, or NULL if the instruction at <code>copy_pc</code> is invalid. 
</div>
</div><p>
<a class="anchor" name="2c491ac5c40069f120b0ef512ccc7166"></a><!-- doxytag: member="dr_ir_utils.h::disassemble_with_info" ref="2c491ac5c40069f120b0ef512ccc7166" args="(void *drcontext, byte *pc, file_t outfile, bool show_pc, bool show_bytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte* disassemble_with_info           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&nbsp;</td>
          <td class="paramname"> <em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">file_t&nbsp;</td>
          <td class="paramname"> <em>outfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>show_pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>show_bytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Decodes and then prints the instruction at address <code>pc</code> to file <code>outfile</code>. Prior to the instruction the address is printed if <code>show_pc</code> and the raw bytes are printed if <code>show_bytes</code>. The default is to use AT&amp;T-style syntax, unless the <a class="el" href="using.html#op_syntax_intel">-syntax_intel</a> runtime option is specified. Returns the address of the subsequent instruction, or NULL if the instruction at <code>pc</code> is invalid. 
</div>
</div><p>
<a class="anchor" name="466c814771a85f9b53e6681f4dc5c957"></a><!-- doxytag: member="dr_ir_utils.h::dr_cleanup_after_call" ref="466c814771a85f9b53e6681f4dc5c957" args="(void *drcontext, instrlist_t *ilist, instr_t *where, uint sizeof_param_area)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_cleanup_after_call           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>sizeof_param_area</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inserts into <code>ilist</code> prior to <code>where</code> meta-instruction(s) to restore state after a call. 
</div>
</div><p>
<a class="anchor" name="d78c531d7527907652e770960c07af38"></a><!-- doxytag: member="dr_ir_utils.h::dr_get_mcontext" ref="d78c531d7527907652e770960c07af38" args="(void *drcontext, dr_mcontext_t *context, int *app_errno)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_get_mcontext           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__dr__mcontext__t.html">dr_mcontext_t</a> *&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>app_errno</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copies the current application machine context to <code>context</code>. This routine may only be called from:<ul>
<li>A clean call invoked by <a class="el" href="dr__ir__utils_8h.html#e7b7bd1e750b8a24ebf401fb6a6d6d5e">dr_insert_clean_call()</a> or <a class="el" href="dr__ir__utils_8h.html#4608ec2db2a288aa5e2a53bb6d19054d">dr_prepare_for_call()</a></li><li>A pre- or post-syscall event (<a class="el" href="dr__events_8h.html#a37d61a7f9dde4663b8dd4c3a44732f4">dr_register_pre_syscall_event()</a>, <a class="el" href="dr__events_8h.html#099441f8d147404355c66178e3b19f0f">dr_register_post_syscall_event()</a>)</li><li>Basic block or trace creation events (<a class="el" href="dr__events_8h.html#043a3588c4cf0c2d6838140fce530e72">dr_register_bb_event()</a>, <a class="el" href="dr__events_8h.html#88a19a6822654caf18c017e145f48a57">dr_register_trace_event()</a>), but for basic block creation only when the basic block callback parameters <code>for_trace</code> and <code>translating</code> are false, and for trace creation only when <code>translating</code> is false.</li><li>A nudge callback (<a class="el" href="dr__events_8h.html#9037603d0bd5bfca4198011adb8d10eb">dr_register_nudge_event()</a>) on Linux. (On Windows nudges happen in separate dedicated threads.)</li><li>A thread or process exit event (<a class="el" href="dr__events_8h.html#0b0c102bb9a99d67c3e62ea8b3790ff1">dr_register_thread_exit_event()</a>, <a class="el" href="dr__events_8h.html#985537df683007e1392e8a3b095ef363">dr_register_exit_event()</a>)</li></ul>
<p>
Does NOT copy the pc field. If <code>app_errno</code> is non-NULL copies the saved application error code (value of GetLastError() on Windows; ignored on Linux) to <code>app_errno</code>.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>NUM_XMM_SLOTS in the <a class="el" href="struct__dr__mcontext__t.html#6ceaf657d338e8753119641ffd1ba516">dr_mcontext_t.xmm</a> array are filled in, but only if dr_mcontext_fields_valid() returns true. <p>
The context is the context saved at the <a class="el" href="dr__ir__utils_8h.html#e7b7bd1e750b8a24ebf401fb6a6d6d5e">dr_insert_clean_call()</a> or <a class="el" href="dr__ir__utils_8h.html#4608ec2db2a288aa5e2a53bb6d19054d">dr_prepare_for_call()</a> points. It does not correct for any registers saved with <a class="el" href="dr__ir__utils_8h.html#f294ac021c84f5ec47230ee7df0e6c02">dr_save_reg()</a>. To access registers saved with <a class="el" href="dr__ir__utils_8h.html#f294ac021c84f5ec47230ee7df0e6c02">dr_save_reg()</a> from a clean call use <a class="el" href="dr__ir__utils_8h.html#bb63ecfaa5256688bab9a2921fc19227">dr_read_saved_reg()</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f2a3575059c29dae25ab02c9eb1d0ce9"></a><!-- doxytag: member="dr_ir_utils.h::dr_insert_call" ref="f2a3575059c29dae25ab02c9eb1d0ce9" args="(void *drcontext, instrlist_t *ilist, instr_t *where, void *callee, uint num_args,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_insert_call           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>callee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>num_args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inserts into <code>ilist</code> prior to <code>where</code> meta-instruction(s) to set up the passed-in parameters, make a call to <code>callee</code>, and clean up the parameters.<p>
The callee must use the standard C calling convention that matches the underlying 32-bit or 64-bit binary interface convention ("cdecl"). Other calling conventions, such as "fastcall" and "stdcall", are not supported.<p>
This routine uses the existing stack. In 64-bit mode, this routine assumes that the stack pointer is currently 16-byte aligned.<p>
The application state is NOT saved or restored (use <a class="el" href="dr__ir__utils_8h.html#4608ec2db2a288aa5e2a53bb6d19054d">dr_prepare_for_call()</a> and <a class="el" href="dr__ir__utils_8h.html#466c814771a85f9b53e6681f4dc5c957">dr_cleanup_after_call()</a>, or replace this routine with <a class="el" href="dr__ir__utils_8h.html#e7b7bd1e750b8a24ebf401fb6a6d6d5e">dr_insert_clean_call()</a>). The parameter set-up may write to registers if the calling convention so dictates. The registers are NOT saved beforehand (to do so, use <a class="el" href="dr__ir__utils_8h.html#e7b7bd1e750b8a24ebf401fb6a6d6d5e">dr_insert_clean_call()</a>).<p>
It is up to the caller of this routine to preserve caller-saved registers.<p>
DR does not support translating a fault in an argument. For fault transparency, the client must perform the translation (see <a class="el" href="dr__events_8h.html#e7a179ac7a2d01157e1ab2852f50c902">dr_register_restore_state_event()</a>), or use <a class="el" href="dr__ir__utils_8h.html#e7b7bd1e750b8a24ebf401fb6a6d6d5e">dr_insert_clean_call()</a>.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This routine only supports passing arguments that are integers or pointers of a size equal to the register size: i.e., no floating-point, multimedia, or aggregate data types. The routine also supports immediate integers that are smaller than the register size, and for 64-bit mode registers or memory references that are OPSZ_4.<p>
For 64-bit mode, passing arguments that use calling convention registers (for Windows, RCX, RDX, R8, R9; for Linux, RDI, RSI, RDX, RCX, R8 and R9) are supported but may incur additional stack usage.<p>
For 64-bit mode, if a 32-bit immediate integer is specified as an argument and it has its top bit set, we assume it is intended to be sign-extended to 64-bits; otherwise we zero-extend it.<p>
For 64-bit mode, variable-sized argument operands may not work properly.<p>
Arguments that reference REG_XSP are not supported in 64-bit mode. </dd></dl>

</div>
</div><p>
<a class="anchor" name="359744bc2776333fbf8f057931ca8eeb"></a><!-- doxytag: member="dr_ir_utils.h::dr_insert_call_instrumentation" ref="359744bc2776333fbf8f057931ca8eeb" args="(void *drcontext, instrlist_t *ilist, instr_t *instr, void *callee)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_insert_call_instrumentation           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>callee</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assumes that <code>instr</code> is a near call. Inserts into <code>ilist</code> prior to <code>instr</code> instruction(s) to call callee passing two arguments:<ol type=1>
<li>address of call instruction (caller)</li><li>target address of call (callee) </li></ol>

</div>
</div><p>
<a class="anchor" name="be09a1a1ca19b343279a65141c20f0a1"></a><!-- doxytag: member="dr_ir_utils.h::dr_insert_cbr_instrumentation" ref="be09a1a1ca19b343279a65141c20f0a1" args="(void *drcontext, instrlist_t *ilist, instr_t *instr, void *callee)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_insert_cbr_instrumentation           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>callee</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assumes that <code>instr</code> is a conditional branch Inserts into <code>ilist</code> prior to <code>instr</code> instruction(s) to call callee passing three arguments:<ol type=1>
<li>address of branch instruction</li><li>target address of branch</li><li>0 if the branch is not taken, 1 if it is taken </li></ol>

</div>
</div><p>
<a class="anchor" name="e7b7bd1e750b8a24ebf401fb6a6d6d5e"></a><!-- doxytag: member="dr_ir_utils.h::dr_insert_clean_call" ref="e7b7bd1e750b8a24ebf401fb6a6d6d5e" args="(void *drcontext, instrlist_t *ilist, instr_t *where, void *callee, bool save_fpstate, uint num_args,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_insert_clean_call           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>callee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>save_fpstate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>num_args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inserts into <code>ilist</code> prior to <code>where</code> meta-instruction(s) to save state for a call, switch to this thread's DR stack, set up the passed-in parameters, make a call to <code>callee</code>, clean up the parameters, and then restore the saved state.<p>
The callee must use the standard C calling convention that matches the underlying 32-bit or 64-bit binary interface convention ("cdecl"). Other calling conventions, such as "fastcall" and "stdcall", are not supported.<p>
Stores the application state information on the DR stack, where it can be accessed from <code>callee</code> using <a class="el" href="dr__ir__utils_8h.html#d78c531d7527907652e770960c07af38">dr_get_mcontext()</a> and modified using <a class="el" href="dr__ir__utils_8h.html#ed77cd48eccfdd8eaf8c33bd6b53d8b2">dr_set_mcontext()</a>.<p>
If <code>save_fpstate</code> is true, preserves the fp/mmx/sse state on the DR stack. Note that it is relatively expensive to save this state (on the order of 200 cycles) and that it typically takes 512 bytes to store it (see <a class="el" href="dr__proc_8h.html#468a29572175ba1d3ca7dbeb1fdbb825">proc_fpstate_save_size()</a>).<p>
DR does support translating a fault in an argument (e.g., an argument that references application memory); such a fault will be treated as an application exception.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The stack used to save state and call <code>callee</code> is limited to 20KB by default; this can be changed with the -stack_size DR runtime parameter. This stack cannot be used to store state that persists beyond <code>callee's</code> return point.<p>
This routine only supports passing arguments that are integers or pointers of a size equal to the register size: i.e., no floating-point, multimedia, or aggregate data types. The routine also supports immediate integers that are smaller than the register size, and for 64-bit mode registers or memory references that are OPSZ_4.<p>
For 64-bit mode, passing arguments that use calling convention registers (for Windows, RCX, RDX, R8, R9; for Linux, RDI, RSI, RDX, RCX, R8 and R9) are supported but may incur additional stack usage.<p>
For 64-bit mode, if a 32-bit immediate integer is specified as an argument and it has its top bit set, we assume it is intended to be sign-extended to 64-bits; otherwise we zero-extend it.<p>
For 64-bit mode, variable-sized argument operands may not work properly.<p>
Arguments that reference sub-register portions of REG_XSP are not supported (full REG_XSP is supported). </dd></dl>

</div>
</div><p>
<a class="anchor" name="919e2106df67eaaa5bc6c49d736543b5"></a><!-- doxytag: member="dr_ir_utils.h::dr_insert_mbr_instrumentation" ref="919e2106df67eaaa5bc6c49d736543b5" args="(void *drcontext, instrlist_t *ilist, instr_t *instr, void *callee, dr_spill_slot_t scratch_slot)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_insert_mbr_instrumentation           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>callee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__utils_8h.html#89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a>&nbsp;</td>
          <td class="paramname"> <em>scratch_slot</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assumes that <code>instr</code> is an indirect branch. Inserts into <code>ilist</code> prior to <code>instr</code> instruction(s) to call callee passing two arguments:<ol type=1>
<li>address of branch instruction</li><li>target address of branch <dl class="note" compact><dt><b>Note:</b></dt><dd>Only the address portion of a far indirect branch is considered. <p>
<code>scratch_slot</code> must be &lt;= <a class="el" href="dr__ir__utils_8h.html#762389f8ae9d809fd7b8f1418cdbd5ae">dr_max_opnd_accessible_spill_slot()</a>. <code>scratch_slot</code> is used internally to this routine and will be clobbered. </dd></dl>
</li></ol>

</div>
</div><p>
<a class="anchor" name="3831354cc7402d68719d8055fb3e9931"></a><!-- doxytag: member="dr_ir_utils.h::dr_insert_read_tls_field" ref="3831354cc7402d68719d8055fb3e9931" args="(void *drcontext, instrlist_t *ilist, instr_t *where, reg_id_t reg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_insert_read_tls_field           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">reg_id_t&nbsp;</td>
          <td class="paramname"> <em>reg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inserts into <code>ilist</code> prior to <code>where</code> meta-instruction(s) to read into the general-purpose full-size register <code>reg</code> from the user-controlled drcontext field for this thread. Reads from the same field as <a class="el" href="dr__tools_8h.html#787aff5df1ded3de8a7ce9f3efef0594">dr_get_tls_field()</a>. 
</div>
</div><p>
<a class="anchor" name="3647b439211a8cd70c40478a4113e128"></a><!-- doxytag: member="dr_ir_utils.h::dr_insert_ubr_instrumentation" ref="3647b439211a8cd70c40478a4113e128" args="(void *drcontext, instrlist_t *ilist, instr_t *instr, void *callee)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_insert_ubr_instrumentation           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>callee</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assumes that <code>instr</code> is a direct, near, unconditional branch. Inserts into <code>ilist</code> prior to <code>instr</code> instruction(s) to call callee passing two arguments:<ol type=1>
<li>address of branch instruction</li><li>target address of branch</li></ol>
<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>Basic block eliding is controlled by -max_elide_jmp. If that option is set to non-zero, ubrs may never be seen. </dd></dl>

</div>
</div><p>
<a class="anchor" name="982089284bd51339f448ec4b3928d3b4"></a><!-- doxytag: member="dr_ir_utils.h::dr_insert_write_tls_field" ref="982089284bd51339f448ec4b3928d3b4" args="(void *drcontext, instrlist_t *ilist, instr_t *where, reg_id_t reg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_insert_write_tls_field           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">reg_id_t&nbsp;</td>
          <td class="paramname"> <em>reg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inserts into <code>ilist</code> prior to <code>where</code> meta-instruction(s) to write the general-purpose full-size register <code>reg</code> to the user-controlled drcontext field for this thread. Writes to the same field as <a class="el" href="dr__tools_8h.html#05b499c8a3115e9ceb4c45dbee660738">dr_set_tls_field()</a>. 
</div>
</div><p>
<a class="anchor" name="762389f8ae9d809fd7b8f1418cdbd5ae"></a><!-- doxytag: member="dr_ir_utils.h::dr_max_opnd_accessible_spill_slot" ref="762389f8ae9d809fd7b8f1418cdbd5ae" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="dr__ir__utils_8h.html#89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a> dr_max_opnd_accessible_spill_slot           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the largest dr_spill_slot_t that can be accessed with an <a class="el" href="structopnd__t.html">opnd_t</a> from <a class="el" href="dr__ir__utils_8h.html#5eab608c134db044f2d9453a8407d470">dr_reg_spill_slot_opnd()</a>. 
</div>
</div><p>
<a class="anchor" name="5921c4f301ea05885f305f9a30b3c0b0"></a><!-- doxytag: member="dr_ir_utils.h::dr_mcontext_xmm_fields_valid" ref="5921c4f301ea05885f305f9a30b3c0b0" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_mcontext_xmm_fields_valid           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if the xmm0 through xmm5 for Windows, or xmm0 through xmm15 for Linux, fields in dr_mcontext_t are valid for this process (i.e., whether this process is 64-bit or WOW64, and the processor supports SSE). 
</div>
</div><p>
<a class="anchor" name="4608ec2db2a288aa5e2a53bb6d19054d"></a><!-- doxytag: member="dr_ir_utils.h::dr_prepare_for_call" ref="4608ec2db2a288aa5e2a53bb6d19054d" args="(void *drcontext, instrlist_t *ilist, instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint dr_prepare_for_call           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inserts into <code>ilist</code> prior to <code>where</code> meta-instruction(s) to save state for a call. Stores the application state information on the DR stack. Returns the size of the data stored on the DR stack (in case the caller needs to align the stack pointer).<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>This routine does NOT save the fp/mmx/sse state: to do that the instrumentation routine should call <a class="el" href="dr__proc_8h.html#4a11c9d5d127ce126562ad35b4d165dd">proc_save_fpstate()</a> to save and then <a class="el" href="dr__proc_8h.html#23edceee5d1ae7c7d51a212432e6d644">proc_restore_fpstate()</a> to restore (or use <a class="el" href="dr__ir__utils_8h.html#e7b7bd1e750b8a24ebf401fb6a6d6d5e">dr_insert_clean_call()</a>).</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The preparation modifies the REG_XSP and REG_XAX registers (after saving them). Use <a class="el" href="dr__ir__utils_8h.html#e7b7bd1e750b8a24ebf401fb6a6d6d5e">dr_insert_clean_call()</a> instead if an argument to the subsequent call that references REG_XAX is desired.<p>
The stack used to save the state is limited to 20KB by default; this can be changed with the -stack_size DR runtime parameter. This stack cannot be used to store state that persists beyond a single clean call, code cache execution, or probe callback function execution. </dd></dl>

</div>
</div><p>
<a class="anchor" name="bb63ecfaa5256688bab9a2921fc19227"></a><!-- doxytag: member="dr_ir_utils.h::dr_read_saved_reg" ref="bb63ecfaa5256688bab9a2921fc19227" args="(void *drcontext, dr_spill_slot_t slot)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">reg_t dr_read_saved_reg           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__utils_8h.html#89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a>&nbsp;</td>
          <td class="paramname"> <em>slot</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Can be used from a clean call or a restore_state_event (see <a class="el" href="dr__events_8h.html#e7a179ac7a2d01157e1ab2852f50c902">dr_register_restore_state_event()</a>) to see the value saved in spill slot <code>slot</code> by <a class="el" href="dr__ir__utils_8h.html#f294ac021c84f5ec47230ee7df0e6c02">dr_save_reg()</a>. 
</div>
</div><p>
<a class="anchor" name="86554ab412927d0a4f1b90d72f64a858"></a><!-- doxytag: member="dr_ir_utils.h::dr_redirect_execution" ref="86554ab412927d0a4f1b90d72f64a858" args="(dr_mcontext_t *mcontext, int app_errno)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_redirect_execution           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__dr__mcontext__t.html">dr_mcontext_t</a> *&nbsp;</td>
          <td class="paramname"> <em>mcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>app_errno</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Immediately resumes application execution from a clean call out of the cache (see <a class="el" href="dr__ir__utils_8h.html#e7b7bd1e750b8a24ebf401fb6a6d6d5e">dr_insert_clean_call()</a> or <a class="el" href="dr__ir__utils_8h.html#4608ec2db2a288aa5e2a53bb6d19054d">dr_prepare_for_call()</a>) or an exception event with the state specified in <code>mcontext</code> (including pc, and including the xmm0 through xmm5 values if <a class="el" href="dr__ir__utils_8h.html#5921c4f301ea05885f305f9a30b3c0b0">dr_mcontext_xmm_fields_valid()</a> returns true) and the application error code (value of GetLastError() on Windows; ignored on Linux) specified by <code>app_errno</code>.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd><a class="el" href="dr__ir__utils_8h.html#d78c531d7527907652e770960c07af38">dr_get_mcontext()</a> can be used to get the register state (except pc) and the <code>app_errno</code> value saved in <a class="el" href="dr__ir__utils_8h.html#e7b7bd1e750b8a24ebf401fb6a6d6d5e">dr_insert_clean_call()</a> or <a class="el" href="dr__ir__utils_8h.html#4608ec2db2a288aa5e2a53bb6d19054d">dr_prepare_for_call()</a> <p>
If floating point state was saved by <a class="el" href="dr__ir__utils_8h.html#4608ec2db2a288aa5e2a53bb6d19054d">dr_prepare_for_call()</a> or <a class="el" href="dr__ir__utils_8h.html#e7b7bd1e750b8a24ebf401fb6a6d6d5e">dr_insert_clean_call()</a> it is not restored (other than xmm0 through xmm5, if <a class="el" href="dr__ir__utils_8h.html#5921c4f301ea05885f305f9a30b3c0b0">dr_mcontext_xmm_fields_valid()</a>). The caller should instead manually save and restore the floating point state with <a class="el" href="dr__proc_8h.html#4a11c9d5d127ce126562ad35b4d165dd">proc_save_fpstate()</a> and <a class="el" href="dr__proc_8h.html#23edceee5d1ae7c7d51a212432e6d644">proc_restore_fpstate()</a> if necessary. <p>
If the caller wishes to set any other state (such as xmm registers that are not part of the mcontext) they may do so by just setting that state in the current thread before making this call. <p>
This routine may only be called from a clean call from the cache. It can not be called from any registered event callback. <p>
This routine doesn't return. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5eab608c134db044f2d9453a8407d470"></a><!-- doxytag: member="dr_ir_utils.h::dr_reg_spill_slot_opnd" ref="5eab608c134db044f2d9453a8407d470" args="(void *drcontext, dr_spill_slot_t slot)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopnd__t.html">opnd_t</a> dr_reg_spill_slot_opnd           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__utils_8h.html#89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a>&nbsp;</td>
          <td class="paramname"> <em>slot</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns an <a class="el" href="structopnd__t.html">opnd_t</a> that directly accesses the spill slot <code>slot</code>. Only slots &lt;= <a class="el" href="dr__ir__utils_8h.html#762389f8ae9d809fd7b8f1418cdbd5ae">dr_max_opnd_accessible_spill_slot()</a> can be used with this routine. <dl class="note" compact><dt><b>Note:</b></dt><dd><code>slot</code> must be &lt;= <a class="el" href="dr__ir__utils_8h.html#762389f8ae9d809fd7b8f1418cdbd5ae">dr_max_opnd_accessible_spill_slot()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="9a2c851eeeee7e669f3e6a7b877977d1"></a><!-- doxytag: member="dr_ir_utils.h::dr_restore_app_stack" ref="9a2c851eeeee7e669f3e6a7b877977d1" args="(void *drcontext, instrlist_t *ilist, instr_t *where)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_restore_app_stack           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>where</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inserts into <code>ilist</code> prior to <code>where</code> meta-instruction(s) to restore into esp the value saved by dr_swap_to_dr_stack(). 
</div>
</div><p>
<a class="anchor" name="563b0de37a51cb2e84337deef30a57cf"></a><!-- doxytag: member="dr_ir_utils.h::dr_restore_arith_flags" ref="563b0de37a51cb2e84337deef30a57cf" args="(void *drcontext, instrlist_t *ilist, instr_t *where, dr_spill_slot_t slot)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_restore_arith_flags           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__utils_8h.html#89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a>&nbsp;</td>
          <td class="paramname"> <em>slot</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inserts into <code>ilist</code> prior to <code>where</code> meta-instruction(s) to restore the 6 arithmetic flags, assuming they were saved using <a class="el" href="dr__ir__utils_8h.html#44636ca6809a9fb22cf817701de9ee09">dr_save_arith_flags()</a> with slot <code>slot</code> and that xax holds the same value it did after the save. 
</div>
</div><p>
<a class="anchor" name="453bc3ecddb4298ffdc1c429f30881b8"></a><!-- doxytag: member="dr_ir_utils.h::dr_restore_reg" ref="453bc3ecddb4298ffdc1c429f30881b8" args="(void *drcontext, instrlist_t *ilist, instr_t *where, reg_id_t reg, dr_spill_slot_t slot)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_restore_reg           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">reg_id_t&nbsp;</td>
          <td class="paramname"> <em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__utils_8h.html#89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a>&nbsp;</td>
          <td class="paramname"> <em>slot</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inserts into <code>ilist</code> prior to <code>where</code> meta-instruction(s) to restore the register <code>reg</code> from the spill slot <code>slot</code>. See <a class="el" href="dr__ir__utils_8h.html#f294ac021c84f5ec47230ee7df0e6c02">dr_save_reg()</a> for notes on lifetime and alternative access to spill slots. 
</div>
</div><p>
<a class="anchor" name="44636ca6809a9fb22cf817701de9ee09"></a><!-- doxytag: member="dr_ir_utils.h::dr_save_arith_flags" ref="44636ca6809a9fb22cf817701de9ee09" args="(void *drcontext, instrlist_t *ilist, instr_t *where, dr_spill_slot_t slot)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_save_arith_flags           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__utils_8h.html#89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a>&nbsp;</td>
          <td class="paramname"> <em>slot</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inserts into <code>ilist</code> prior to <code>where</code> meta-instruction(s) to save the 6 arithmetic flags into xax after first saving xax to the spill slot <code>slot</code>. This is equivalent to <a class="el" href="dr__ir__utils_8h.html#f294ac021c84f5ec47230ee7df0e6c02">dr_save_reg()</a> of xax to <code>slot</code> followed by lahf and seto al instructions. See <a class="el" href="dr__ir__utils_8h.html#563b0de37a51cb2e84337deef30a57cf">dr_restore_arith_flags()</a>.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>At completion of the inserted instructions the saved flags are in the xax register. The xax register should not be modified after using this routine unless it is first saved (and later restored prior to using <a class="el" href="dr__ir__utils_8h.html#563b0de37a51cb2e84337deef30a57cf">dr_restore_arith_flags()</a>). </dd></dl>

</div>
</div><p>
<a class="anchor" name="f294ac021c84f5ec47230ee7df0e6c02"></a><!-- doxytag: member="dr_ir_utils.h::dr_save_reg" ref="f294ac021c84f5ec47230ee7df0e6c02" args="(void *drcontext, instrlist_t *ilist, instr_t *where, reg_id_t reg, dr_spill_slot_t slot)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_save_reg           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">reg_id_t&nbsp;</td>
          <td class="paramname"> <em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__utils_8h.html#89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a>&nbsp;</td>
          <td class="paramname"> <em>slot</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inserts into <code>ilist</code> prior to <code>where</code> meta-instruction(s) to save the register <code>reg</code> in the spill slot <code>slot</code>. See <a class="el" href="dr__ir__utils_8h.html#453bc3ecddb4298ffdc1c429f30881b8">dr_restore_reg()</a>. Use <a class="el" href="dr__ir__utils_8h.html#bb63ecfaa5256688bab9a2921fc19227">dr_read_saved_reg()</a> and <a class="el" href="dr__ir__utils_8h.html#bf8d50d718883a1caf6a2de0fb3dbce3">dr_write_saved_reg()</a> to access spill slots from clean calls and restore_state_events (see <a class="el" href="dr__events_8h.html#e7a179ac7a2d01157e1ab2852f50c902">dr_register_restore_state_event()</a>). <dl class="note" compact><dt><b>Note:</b></dt><dd>The stored value remains available only until the next non-meta (i.e. application) instruction. Use <a class="el" href="dr__ir__utils_8h.html#982089284bd51339f448ec4b3928d3b4">dr_insert_write_tls_field()</a> and <a class="el" href="dr__ir__utils_8h.html#3831354cc7402d68719d8055fb3e9931">dr_insert_read_tls_field()</a> for a persistent (but more costly to access) thread-local-storage location. See also <a class="el" href="dr__tools_8h.html#95b53d79cae021a473c39f3b2662323f">dr_raw_tls_calloc()</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ed77cd48eccfdd8eaf8c33bd6b53d8b2"></a><!-- doxytag: member="dr_ir_utils.h::dr_set_mcontext" ref="ed77cd48eccfdd8eaf8c33bd6b53d8b2" args="(void *drcontext, dr_mcontext_t *context, const int *app_errno)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_set_mcontext           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__dr__mcontext__t.html">dr_mcontext_t</a> *&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>app_errno</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the application machine context to <code>context</code>. This routine may only be called from:<ul>
<li>A clean call invoked by <a class="el" href="dr__ir__utils_8h.html#e7b7bd1e750b8a24ebf401fb6a6d6d5e">dr_insert_clean_call()</a> or <a class="el" href="dr__ir__utils_8h.html#4608ec2db2a288aa5e2a53bb6d19054d">dr_prepare_for_call()</a></li><li>A pre- or post-syscall event (<a class="el" href="dr__events_8h.html#a37d61a7f9dde4663b8dd4c3a44732f4">dr_register_pre_syscall_event()</a>, <a class="el" href="dr__events_8h.html#099441f8d147404355c66178e3b19f0f">dr_register_post_syscall_event()</a>) <a class="el" href="dr__events_8h.html#0b0c102bb9a99d67c3e62ea8b3790ff1">dr_register_thread_exit_event()</a>)</li><li>Basic block or trace creation events (<a class="el" href="dr__events_8h.html#043a3588c4cf0c2d6838140fce530e72">dr_register_bb_event()</a>, <a class="el" href="dr__events_8h.html#88a19a6822654caf18c017e145f48a57">dr_register_trace_event()</a>), but for basic block creation only when the basic block callback parameters <code>for_trace</code> and <code>translating</code> are false, and for trace creation only when <code>translating</code> is false.</li></ul>
<p>
Ignores the pc field. If <code>app_errno</code> is non-NULL sets the application error code (value of GetLastError() on Windows; ignored on Linux) to be restored as well.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The xmm0 through xmm5 fields are only set for 64-bit or WOW64 processes where the underlying processor supports SSE. For <a class="el" href="dr__ir__utils_8h.html#e7b7bd1e750b8a24ebf401fb6a6d6d5e">dr_insert_clean_call()</a> that requested <code>save_fpstate</code>, the xmm0 through xmm5 values set here override that saved state. Use <a class="el" href="dr__ir__utils_8h.html#5921c4f301ea05885f305f9a30b3c0b0">dr_mcontext_xmm_fields_valid()</a> to determine whether the fields are valid. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9647e1300201596bc818ca33c95d4cc6"></a><!-- doxytag: member="dr_ir_utils.h::dr_swap_to_clean_stack" ref="9647e1300201596bc818ca33c95d4cc6" args="(void *drcontext, instrlist_t *ilist, instr_t *where)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_swap_to_clean_stack           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>where</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inserts into <code>ilist</code> prior to <code>where</code> meta-instruction(s) to save the current esp and switch to this thread's DR stack. <dl class="note" compact><dt><b>Note:</b></dt><dd>The DR stack is limited to 20KB by default; this can be changed with the -stack_size DR runtime parameter. This stack cannot be used to store state that persists beyond a single clean call, code cache execution, or probe callback function execution. </dd></dl>

</div>
</div><p>
<a class="anchor" name="bf8d50d718883a1caf6a2de0fb3dbce3"></a><!-- doxytag: member="dr_ir_utils.h::dr_write_saved_reg" ref="bf8d50d718883a1caf6a2de0fb3dbce3" args="(void *drcontext, dr_spill_slot_t slot, reg_t value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_write_saved_reg           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__utils_8h.html#89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a>&nbsp;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">reg_t&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Can be used from a clean call to modify the value saved in the spill slot <code>slot</code> by <a class="el" href="dr__ir__utils_8h.html#f294ac021c84f5ec47230ee7df0e6c02">dr_save_reg()</a> such that a later <a class="el" href="dr__ir__utils_8h.html#453bc3ecddb4298ffdc1c429f30881b8">dr_restore_reg()</a> will see the new value.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This routine should only be used during a clean call out of the cache. Use at any other time could corrupt application or DynamoRIO state. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a18c8ca0720c97403a0fa9371ae792e5"></a><!-- doxytag: member="dr_ir_utils.h::get_x86_mode" ref="a18c8ca0720c97403a0fa9371ae792e5" args="(void *drcontext)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool get_x86_mode           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The decode and encode routines use a per-thread persistent flag that indicates whether to treat code as 32-bit (x86) or 64-bit (x64). This routine returns the value of that flag.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>For 64-bit DR builds only. </dd></dl>

</div>
</div><p>
<a class="anchor" name="824eaa9075a7aaf443b4cc4180eec81e"></a><!-- doxytag: member="dr_ir_utils.h::instrlist_meta_append" ref="824eaa9075a7aaf443b4cc4180eec81e" args="(instrlist_t *ilist, instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instrlist_meta_append           </td>
          <td>(</td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inserts <code>instr</code> as a non-application instruction onto the end of <code>ilist</code> 
</div>
</div><p>
<a class="anchor" name="94a1526c7b520c9aefbd775adfc57108"></a><!-- doxytag: member="dr_ir_utils.h::instrlist_meta_fault_append" ref="94a1526c7b520c9aefbd775adfc57108" args="(instrlist_t *ilist, instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instrlist_meta_fault_append           </td>
          <td>(</td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inserts <code>instr</code> as a non-application instruction that can fault (see <a class="el" href="dr__ir__instr_8h.html#94227a193446d370f0180e6a844be0c2">instr_set_meta_may_fault()</a>) onto the end of <code>ilist</code>. 
</div>
</div><p>
<a class="anchor" name="6ea095671bab4239c659d17d4a9cda56"></a><!-- doxytag: member="dr_ir_utils.h::instrlist_meta_fault_postinsert" ref="6ea095671bab4239c659d17d4a9cda56" args="(instrlist_t *ilist, instr_t *where, instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instrlist_meta_fault_postinsert           </td>
          <td>(</td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inserts <code>instr</code> as a non-application instruction that can fault (see <a class="el" href="dr__ir__instr_8h.html#94227a193446d370f0180e6a844be0c2">instr_set_meta_may_fault()</a>) into <code>ilist</code> after <code>where</code>. 
</div>
</div><p>
<a class="anchor" name="ffe811040a2962e5c6920a3c523212ab"></a><!-- doxytag: member="dr_ir_utils.h::instrlist_meta_fault_preinsert" ref="ffe811040a2962e5c6920a3c523212ab" args="(instrlist_t *ilist, instr_t *where, instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instrlist_meta_fault_preinsert           </td>
          <td>(</td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inserts <code>instr</code> as a non-application instruction that can fault (see <a class="el" href="dr__ir__instr_8h.html#94227a193446d370f0180e6a844be0c2">instr_set_meta_may_fault()</a>) into <code>ilist</code> prior to <code>where</code>. 
</div>
</div><p>
<a class="anchor" name="98218650e1f61b58c5478cf68e25d9da"></a><!-- doxytag: member="dr_ir_utils.h::instrlist_meta_postinsert" ref="98218650e1f61b58c5478cf68e25d9da" args="(instrlist_t *ilist, instr_t *where, instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instrlist_meta_postinsert           </td>
          <td>(</td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inserts <code>instr</code> as a non-application instruction into <code>ilist</code> after <code>where</code>. 
</div>
</div><p>
<a class="anchor" name="3b0b7e9e09a9a85ca1a707da3ded6f69"></a><!-- doxytag: member="dr_ir_utils.h::instrlist_meta_preinsert" ref="3b0b7e9e09a9a85ca1a707da3ded6f69" args="(instrlist_t *ilist, instr_t *where, instr_t *instr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instrlist_meta_preinsert           </td>
          <td>(</td>
          <td class="paramtype">instrlist_t *&nbsp;</td>
          <td class="paramname"> <em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>instr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inserts <code>instr</code> as a non-application instruction into <code>ilist</code> prior to <code>where</code>. 
</div>
</div><p>
<a class="anchor" name="df9a4f63eafc7f9725f7d5bf1725ab5c"></a><!-- doxytag: member="dr_ir_utils.h::set_x86_mode" ref="df9a4f63eafc7f9725f7d5bf1725ab5c" args="(void *drcontext, bool x86)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool set_x86_mode           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>x86</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The decode and encode routines use a per-thread persistent flag that indicates whether to treat code as 32-bit (x86) or 64-bit (x64). This routine sets that flag to the indicated value and returns the old value. Be sure to restore the old value prior to any further application execution to avoid problems in mis-interpreting application code.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>For 64-bit DR builds only. </dd></dl>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: center;"><small>
<img border=0 src="favicon.png"> &nbsp; DynamoRIO API version 2.0.0 --- Thu Apr 22 00:18:19 2010 
&nbsp; <img border=0 src="favicon.png">
</body>
</html>
