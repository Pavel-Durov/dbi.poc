<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>DynamoRIO API: Sample Use Cases</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
<link rel="shortcut icon" type="image/x-icon" href="favicon.ico" />
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="contents">
<h1><a class="anchor" name="API_samples">Sample Use Cases </a></h1>We provide several examples to illustrate how the DynamoRIO API is used to build a DynamoRIO client.<h2><a class="anchor" name="bt_examples">
Code Manipulation API Examples</a></h2>
<h3><a class="anchor" name="sec_ex1">
Instruction Counting</a></h3>
We now illustrate how to use the above API to implement a simple instrumentation client for counting the number of executed call and return instructions in the input program. Full code for this example is in the file <a href="https://css.csail.mit.edu/6.858/2010/samples/countcalls.c">../../samples/countcalls.c</a>.<p>
The client maintains set of three counters: num_direct_calls, num_indirect_calls, and num_returns to count three different types of instructions during execution. It keeps both thread-private and global versions of these counters. The client initializes everything by supplying the following dr_init routine:<p>
<div class="fragment"><pre class="fragment">DR_EXPORT <span class="keywordtype">void</span> 
<a class="code" href="dr__api_8h.html#20a4dc9da7f6bb9121e30bb3570c6961">dr_init</a>(<a class="code" href="dr__defines_8h.html#68540a70b4f8150a4fe6dcec91bf8825">client_id_t</a> <span class="keywordtype">id</span>)
{
  <span class="comment">/* register events */</span>
  <a class="code" href="dr__events_8h.html#985537df683007e1392e8a3b095ef363">dr_register_exit_event</a>(event_exit);
  <a class="code" href="dr__events_8h.html#878920c40c76e2c18043f9db772a24c0">dr_register_thread_init_event</a>(event_thread_init);
  <a class="code" href="dr__events_8h.html#0b0c102bb9a99d67c3e62ea8b3790ff1">dr_register_thread_exit_event</a>(event_thread_exit);
  <a class="code" href="dr__events_8h.html#043a3588c4cf0c2d6838140fce530e72">dr_register_bb_event</a>(event_basic_block);

  <span class="comment">/* make it easy to tell, by looking at log file, which client executed */</span>
  <a class="code" href="dr__tools_8h.html#332a14861f12823994465e8c9b6a3015">dr_log</a>(NULL, <a class="code" href="dr__tools_8h.html#7574ce4aa047de1f4a564c9b441e69dc">LOG_ALL</a>, 1, <span class="stringliteral">"Client 'countcalls' initializing\n"</span>);
}
</pre></div><p>
The client provides an event_exit routine that displays the final values of the global counters as well as a thread_exit routine that shows the counter totals on a per-thread basis.<p>
The client keeps track of each thread's instruction counts separately. To do this, it creates a data structure that will be separately allocated for each thread:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">typedef</span> <span class="keyword">struct </span>{
  <span class="keywordtype">int</span> num_direct_calls;
  <span class="keywordtype">int</span> num_indirect_calls;
  <span class="keywordtype">int</span> num_returns;
} per_thread_t;
</pre></div><p>
Now the thread hooks are used to initialize the data structure and to display the thread-private totals :<p>
<div class="fragment"><pre class="fragment"><span class="keyword">static</span> <span class="keywordtype">void</span> event_thread_init(<span class="keywordtype">void</span> *drcontext)
{
  <span class="comment">/* create an instance of our data structure for this thread */</span>
  per_thread *data = (per_thread *)
    <a class="code" href="dr__tools_8h.html#4274226adda06339e247e4a311abdd9b">dr_thread_alloc</a>(drcontext, <span class="keyword">sizeof</span>(per_thread));
  <span class="comment">/* store it in the slot provided in the drcontext */</span>
  <a class="code" href="dr__tools_8h.html#05b499c8a3115e9ceb4c45dbee660738">dr_set_tls_field</a>(drcontext, data);
  data-&gt;num_direct_calls = 0;
  data-&gt;num_indirect_calls = 0;
  data-&gt;num_returns = 0;
  <a class="code" href="dr__tools_8h.html#332a14861f12823994465e8c9b6a3015">dr_log</a>(drcontext, <a class="code" href="dr__tools_8h.html#7574ce4aa047de1f4a564c9b441e69dc">LOG_ALL</a>, 1, <span class="stringliteral">"countcalls: set up for thread %d\n"</span>,
         <a class="code" href="dr__tools_8h.html#3980d703cc13379a6b57396a7901b1d1">dr_get_thread_id</a>(drcontext));
}

<span class="keyword">static</span> <span class="keywordtype">void</span> event_thread_exit(<span class="keywordtype">void</span> *drcontext)
{
  per_thread *data = (per_thread *) <a class="code" href="dr__tools_8h.html#787aff5df1ded3de8a7ce9f3efef0594">dr_get_tls_field</a>(drcontext);

  ... <span class="comment">// string formatting and displaying</span>

  <span class="comment">/* clean up memory */</span>
  <a class="code" href="dr__tools_8h.html#3f1f3862009f52182e9ca1f943fa6f14">dr_thread_free</a>(drcontext, data, <span class="keyword">sizeof</span>(per_thread));
}
</pre></div><p>
The real work is done in the basic block hook. We simply look for the instructions we're interested in and insert an increment of the appropriate thread-local and global counters, remembering to save the flags, of course. This sample has separate paths for incrementing the thread private counts for shared vs. thread-private caches (see the -thread_private option) to illustrate the differences in targeting for them. Note that the shared path would work fine with private caches.<p>
<div class="fragment"><pre class="fragment"><span class="keyword">static</span> <span class="keywordtype">void</span>
insert_counter_update(<span class="keywordtype">void</span> *drcontext, instrlist_t *bb, <a class="code" href="structinstr__t.html">instr_t</a> *where, <span class="keywordtype">int</span> offset)
{
  <span class="comment">/* Since the inc instruction clobbers 5 of the arithmetic eflags,</span>
<span class="comment"> we have to save them around the inc. We could be more efficient</span>
<span class="comment"> by not bothering to save the overflow flag and constructing our</span>
<span class="comment"> own sequence of instructions to save the other 5 flags (using</span>
<span class="comment"> lahf) or by doing a liveness analysis on the flags and saving</span>
<span class="comment"> only if live.</span>
<span class="comment">   */</span>
  <a class="code" href="dr__ir__utils_8h.html#44636ca6809a9fb22cf817701de9ee09">dr_save_arith_flags</a>(drcontext, bb, where, SPILL_SLOT_1);

  <span class="comment">/* Increment the global counter using the lock prefix to make it atomic</span>
<span class="comment"> across threads. It would be cheaper to aggregate the thread counters</span>
<span class="comment"> in the exit events, but this sample is intended to illustrate inserted</span>
<span class="comment"> instrumentation.</span>
<span class="comment">   */</span>
  <a class="code" href="dr__ir__utils_8h.html#3b0b7e9e09a9a85ca1a707da3ded6f69">instrlist_meta_preinsert</a>(bb, where, <a class="code" href="dr__ir__macros_8h.html#8104e895719c1f3a8558067b023cf9c5">LOCK</a>(<a class="code" href="dr__ir__macros_8h.html#759b7342ed4080b9c12809d3b2e2718a">INSTR_CREATE_inc</a>
    (drcontext, <a class="code" href="dr__ir__macros_8h.html#54b8bd667a8a940e94bfcc7842c958eb">OPND_CREATE_ABSMEM</a>(((byte *)&amp;global_count) + offset, <a class="code" href="dr__ir__opnd_8h.html#af8fd5f0e57d456151c951e0f3715fc40ccef0d75b3f473bf275388804c8b85c">OPSZ_4</a>))));

  <span class="comment">/* Increment the thread private counter. */</span>
  <span class="keywordflow">if</span> (<a class="code" href="dr__tools_8h.html#54934632c814904bd9e0ce9c83980466">dr_using_all_private_caches</a>()) {
    per_thread_t *data = (per_thread_t *) <a class="code" href="dr__tools_8h.html#787aff5df1ded3de8a7ce9f3efef0594">dr_get_tls_field</a>(drcontext);
    <span class="comment">/* private caches - we can use an absolute address */</span>
    <a class="code" href="dr__ir__utils_8h.html#3b0b7e9e09a9a85ca1a707da3ded6f69">instrlist_meta_preinsert</a>(bb, where, <a class="code" href="dr__ir__macros_8h.html#759b7342ed4080b9c12809d3b2e2718a">INSTR_CREATE_inc</a>(drcontext, 
        <a class="code" href="dr__ir__macros_8h.html#54b8bd667a8a940e94bfcc7842c958eb">OPND_CREATE_ABSMEM</a>(((byte *)&amp;data) + offset, <a class="code" href="dr__ir__opnd_8h.html#af8fd5f0e57d456151c951e0f3715fc40ccef0d75b3f473bf275388804c8b85c">OPSZ_4</a>)));
  } <span class="keywordflow">else</span> {
    <span class="comment">/* shared caches - we must indirect via thread local storage */</span>
    <span class="comment">/* We spill xbx to use a scratch register (we could do a liveness</span>
<span class="comment"> analysis to try and find a dead register to use). Note that xax</span>
<span class="comment"> is currently holding the saved eflags. */</span>
    <a class="code" href="dr__ir__utils_8h.html#f294ac021c84f5ec47230ee7df0e6c02">dr_save_reg</a>(drcontext, bb, where, <a class="code" href="dr__ir__opnd_8h.html#18b964ebd29b492898810e8f49fa47fc">REG_XBX</a>, <a class="code" href="dr__ir__utils_8h.html#89a6b714ff24d91d78589877047a29b9e4cd78beccb2525acc61f2536ba1ea71">SPILL_SLOT_2</a>);
    <a class="code" href="dr__ir__utils_8h.html#3831354cc7402d68719d8055fb3e9931">dr_insert_read_tls_field</a>(drcontext, bb, where, <a class="code" href="dr__ir__opnd_8h.html#18b964ebd29b492898810e8f49fa47fc">REG_XBX</a>);
    <a class="code" href="dr__ir__utils_8h.html#3b0b7e9e09a9a85ca1a707da3ded6f69">instrlist_meta_preinsert</a>(bb, where,
        <a class="code" href="dr__ir__macros_8h.html#759b7342ed4080b9c12809d3b2e2718a">INSTR_CREATE_inc</a>(drcontext, <a class="code" href="dr__ir__macros_8h.html#026e7031693d6f0e4d53af107e0a1827">OPND_CREATE_MEM32</a>(<a class="code" href="dr__ir__opnd_8h.html#18b964ebd29b492898810e8f49fa47fc">REG_XBX</a>, offset)));
    <a class="code" href="dr__ir__utils_8h.html#453bc3ecddb4298ffdc1c429f30881b8">dr_restore_reg</a>(drcontext, bb, where, <a class="code" href="dr__ir__opnd_8h.html#18b964ebd29b492898810e8f49fa47fc">REG_XBX</a>, <a class="code" href="dr__ir__utils_8h.html#89a6b714ff24d91d78589877047a29b9e4cd78beccb2525acc61f2536ba1ea71">SPILL_SLOT_2</a>);
  }

  <span class="comment">/* restore flags */</span>
  <a class="code" href="dr__ir__utils_8h.html#563b0de37a51cb2e84337deef30a57cf">dr_restore_arith_flags</a>(drcontext, bb, where, SPILL_SLOT_1);
}

<span class="keyword">static</span> <a class="code" href="dr__events_8h.html#689518ac5d1ad136b13e03012702b209">dr_emit_flags_t</a>
event_basic_block(<span class="keywordtype">void</span> *drcontext, <span class="keywordtype">void</span> *tag, instrlist_t *bb,
                  <span class="keywordtype">bool</span> for_trace, <span class="keywordtype">bool</span> translating)
{
  <a class="code" href="structinstr__t.html">instr_t</a> *instr, *next_instr;

  ... <span class="comment">// some logging</span>

  <span class="keywordflow">for</span> (instr = <a class="code" href="dr__ir__instrlist_8h.html#c9a47c1b7376ca06d8dcb4b3094e5a67">instrlist_first</a>(bb); instr != NULL; instr = next_instr) {
    <span class="comment">/* grab next now so we don't go over instructions we insert */</span>
    next_instr = <a class="code" href="dr__ir__instr_8h.html#7e6028bd1058d4becc4e2d29c96fbaf5">instr_get_next</a>(instr);

    <span class="comment">/* instrument calls and returns -- ignore far calls/rets */</span>
    <span class="keywordflow">if</span> (<a class="code" href="dr__ir__instr_8h.html#5cb0fc26f65991c24002df14abb7e461">instr_is_call_direct</a>(instr)) {
      insert_counter_update(drcontext, bb, instr,
                            offsetof(per_thread_t, num_direct_calls));
    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="dr__ir__instr_8h.html#1fe1cc575e2870720ceee8ce134771f3">instr_is_call_indirect</a>(instr)) {
      insert_counter_update(drcontext, bb, instr,
                            offsetof(per_thread_t, num_indirect_calls));
    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="dr__ir__instr_8h.html#de184d50e1016f220a10f40a60a4f8ad">instr_is_return</a>(instr)) {
      insert_counter_update(drcontext, bb, instr,
                            offsetof(per_thread_t, num_returns));
    }
  }

  ... <span class="comment">// some logging</span>

  <span class="keywordflow">return</span> <a class="code" href="dr__events_8h.html#689518ac5d1ad136b13e03012702b2097d25c4546544d1a8c0b77c69230772eb">DR_EMIT_DEFAULT</a>;
}
</pre></div><p>
<dl class="user" compact><dt><b>Building the Example</b></dt><dd></dd></dl>
For general instructions on building a client, see <a class="el" href="using.html#sec_build">Building a Client</a>.<p>
To build the <code>instrcalls.c</code> client using CMake, if <code>DYNAMORIO_HOME</code> is set to the base of the DynamoRIO release package:<p>
<div class="fragment"><pre class="fragment">mkdir build
cd build
cmake -DDynamoRIO_DIR=$DYNAMORIO_HOME/cmake $DYNAMORIO_HOME/samples
make instrcalls
</pre></div><p>
To build 32-bit samples when using gcc with a default of 64-bit, use:<p>
<div class="fragment"><pre class="fragment">mkdir build
cd build
CFLAGS=-m32 CXXFLAGS=-m32 cmake -DDynamoRIO_DIR=$DYNAMORIO_HOME/cmake $DYNAMORIO_HOME/samples
make instrcalls
</pre></div><p>
The result is a shared library instrcalls.dll or libinstrcalls.so. To invoke the client library, follow the instructions under <a class="el" href="using.html#sec_deploy">Deployment</a>.<h3><a class="anchor" name="sec_ex2">
Instruction Profiling</a></h3>
The next example shows how to use the provided control flow instrumentation routines, which allow more sophisticated profiling than simply counting instructions. Full code for this example is in the file <a href="https://css.csail.mit.edu/6.858/2010/samples/instrcalls.c">../../samples/instrcalls.c</a>.<p>
As in the previous example, the client is interested in direct and indirect calls and returns. The client wants to analyze the target address of each dynamic instance of a call or return. For our example, we simply dump the data in text format to a separate file for each thread. Since FILE cannot be exported from a DLL on Windows, we use the DynamoRIO-provided file_t type that hides the distinction between FILE and HANDLE to allow the same code to work on Linux and Windows . We make use of the thread initialization and exit routines to open and close the file. We store the file for a thread in the user slot in the drcontext.<p>
<div class="fragment"><pre class="fragment"><span class="keyword">static</span> <span class="keywordtype">void</span> event_thread_init(<span class="keywordtype">void</span> *drcontext)
{
  <span class="comment">/* we're going to dump our data to a per-thread file */</span>
  file_t f;
  <span class="keywordtype">char</span> logname[512];

  ... <span class="comment">// filename generation</span>

  f = <a class="code" href="dr__tools_8h.html#e3ae2190774a204af207602791a32cb6">dr_open_file</a>(fname, <span class="keyword">false</span><span class="comment">/*write*/</span>);
  <a class="code" href="dr__tools_8h.html#7c07630dffdfd92bc6ee63abf405768c">DR_ASSERT</a>(f != <a class="code" href="dr__defines_8h.html#5f22fa59d1d8caa3fa4750147f559043">INVALID_FILE</a>);

  <span class="comment">/* store it in the slot provided in the drcontext */</span>
  <a class="code" href="dr__tools_8h.html#05b499c8a3115e9ceb4c45dbee660738">dr_set_tls_field</a>(drcontext, (<span class="keywordtype">void</span> *)f);

  ... <span class="comment">// logging</span>
}

<span class="keyword">static</span> <span class="keywordtype">void</span> event_thread_exit(<span class="keywordtype">void</span> *drcontext)
{
  file_t f = (file_t)(ptr_uint_t) <a class="code" href="dr__tools_8h.html#787aff5df1ded3de8a7ce9f3efef0594">dr_get_tls_field</a>(drcontext);
  <a class="code" href="dr__tools_8h.html#c25b305e0be9f6c09f9761b14f3bbc74">dr_close_file</a>(f);
}
</pre></div><p>
The basic block hook inserts a call to a procedure for each type of instruction, using the API-provided dr_insert_call_instrumentation and dr_insert_mbr_instrumentation routines, which insert calls to procedures with a certain signature.<p>
<div class="fragment"><pre class="fragment"><span class="keyword">static</span> <a class="code" href="dr__events_8h.html#689518ac5d1ad136b13e03012702b209">dr_emit_flags_t</a> 
event_basic_block(<span class="keywordtype">void</span> *drcontext, <span class="keywordtype">void</span> *tag, instrlist_t *bb,
                  <span class="keywordtype">bool</span> for_trace, <span class="keywordtype">bool</span> translating)
{
  <a class="code" href="structinstr__t.html">instr_t</a> *instr, *next_instr;

  ... <span class="comment">// logging</span>

  <span class="keywordflow">for</span> (instr = <a class="code" href="dr__ir__instrlist_8h.html#c9a47c1b7376ca06d8dcb4b3094e5a67">instrlist_first</a>(bb); instr != NULL; instr = next_instr) {
    next_instr = <a class="code" href="dr__ir__instr_8h.html#7e6028bd1058d4becc4e2d29c96fbaf5">instr_get_next</a>(instr);
    <span class="keywordflow">if</span> (!<a class="code" href="dr__ir__instr_8h.html#feaf6ea858ca81c8b9968e4be43749f6">instr_opcode_valid</a>(instr))
        <span class="keywordflow">continue</span>;
    <span class="comment">/* instrument calls and returns -- ignore far calls/rets */</span>
    <span class="keywordflow">if</span> (<a class="code" href="dr__ir__instr_8h.html#5cb0fc26f65991c24002df14abb7e461">instr_is_call_direct</a>(instr)) {
        <a class="code" href="dr__ir__utils_8h.html#359744bc2776333fbf8f057931ca8eeb">dr_insert_call_instrumentation</a>(drcontext, bb, instr, (app_pc)at_call);
    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="dr__ir__instr_8h.html#1fe1cc575e2870720ceee8ce134771f3">instr_is_call_indirect</a>(instr)) {
        <a class="code" href="dr__ir__utils_8h.html#919e2106df67eaaa5bc6c49d736543b5">dr_insert_mbr_instrumentation</a>(drcontext, bb, instr, (app_pc)at_call_ind,
                                      SPILL_SLOT_1);
    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="dr__ir__instr_8h.html#de184d50e1016f220a10f40a60a4f8ad">instr_is_return</a>(instr)) {
        <a class="code" href="dr__ir__utils_8h.html#919e2106df67eaaa5bc6c49d736543b5">dr_insert_mbr_instrumentation</a>(drcontext, bb, instr, (app_pc)at_return,
                                      SPILL_SLOT_1);
    }
  }
  <span class="keywordflow">return</span> <a class="code" href="dr__events_8h.html#689518ac5d1ad136b13e03012702b2097d25c4546544d1a8c0b77c69230772eb">DR_EMIT_DEFAULT</a>;
}
</pre></div><p>
These procedures look like this :<p>
<div class="fragment"><pre class="fragment"><span class="keyword">static</span> <span class="keywordtype">void</span>
at_call(app_pc instr_addr, app_pc target_addr)
{
  file_t f = (file_t)(ptr_uint_t) <a class="code" href="dr__tools_8h.html#787aff5df1ded3de8a7ce9f3efef0594">dr_get_tls_field</a>(<a class="code" href="dr__tools_8h.html#13217cc252506b06184c7c72adedf26c">dr_get_current_drcontext</a>());
  <a class="code" href="struct__dr__mcontext__t.html">dr_mcontext_t</a> mc;
  <a class="code" href="dr__ir__utils_8h.html#d78c531d7527907652e770960c07af38">dr_get_mcontext</a>(<a class="code" href="dr__tools_8h.html#13217cc252506b06184c7c72adedf26c">dr_get_current_drcontext</a>(), &amp;mc, NULL);
  <a class="code" href="dr__tools_8h.html#fe7ede5b10890505021ac03e8f9ba97f">dr_fprintf</a>(f, <span class="stringliteral">"CALL @ "</span>PFX<span class="stringliteral">" to "</span>PFX<span class="stringliteral">", TOS is "</span>PFX<span class="stringliteral">"\n"</span>,
             instr_addr, target_addr, mc.<a class="code" href="struct__dr__mcontext__t.html#4e1c58a65a0b7aa6c55b5f18a2e2fd34">xsp</a>);
}

<span class="keyword">static</span> <span class="keywordtype">void</span>
at_call_ind(app_pc instr_addr, app_pc target_addr)
{
  file_t f = (file_t)(ptr_uint_t) <a class="code" href="dr__tools_8h.html#787aff5df1ded3de8a7ce9f3efef0594">dr_get_tls_field</a>(<a class="code" href="dr__tools_8h.html#13217cc252506b06184c7c72adedf26c">dr_get_current_drcontext</a>());
  <a class="code" href="dr__tools_8h.html#fe7ede5b10890505021ac03e8f9ba97f">dr_fprintf</a>(f, <span class="stringliteral">"CALL INDIRECT @ "</span>PFX<span class="stringliteral">" to "</span>PFX<span class="stringliteral">"\n"</span>, instr_addr, target_addr);
}

<span class="keyword">static</span> <span class="keywordtype">void</span>
at_return(app_pc instr_addr, app_pc target_addr)
{
  file_t f = (file_t)(ptr_uint_t) <a class="code" href="dr__tools_8h.html#787aff5df1ded3de8a7ce9f3efef0594">dr_get_tls_field</a>(<a class="code" href="dr__tools_8h.html#13217cc252506b06184c7c72adedf26c">dr_get_current_drcontext</a>());
  <a class="code" href="dr__tools_8h.html#fe7ede5b10890505021ac03e8f9ba97f">dr_fprintf</a>(f, <span class="stringliteral">"RETURN @ "</span>PFX<span class="stringliteral">" to "</span>PFX<span class="stringliteral">"\n"</span>, instr_addr, target_addr);
}
</pre></div><p>
The address of the instruction and the address of its target are both provided. These routines could perform some sort of analysis based on these addresses. In our example we simply print out the data.<h3><a class="anchor" name="sec_ex3">
Modifying Existing Instrumentation</a></h3>
In this example, we show how to update or replace existing instrumentation after it executes. This ability is useful for clients performing adaptive optimization. In this example, however, we are interested in recording the direction of all conditional branches, but wish to remove the overhead of instrumentation once we've gathered that information. This code could form part of a dynamic CFG builder, where we want to observe the control-flow edges that execute at runtime, but remove the instrumentation after it executes.<p>
While DynamoRIO supports direct fragment replacement, another method for re-instrumentation is to flush the fragment from the code cache and rebuild it in the basic block event callback. In other words, we take the following approach:<p>
<ol type=1>
<li>In the basic block event callback, insert separate instrumentation for the taken and fall-through edges.</li><li>When the basic block executes, note the direction taken and flush the fragment from the code cache.</li><li>When the basic block event triggers again, insert instrumentation only for the unseen edge. After both edges have triggered, remove all instrumentation for the cbr.</li></ol>
<p>
We insert separate clean calls for the taken and fall-through cases. In each clean call, we record the observed direction and immediately flush the basic block using <a class="el" href="dr__tools_8h.html#be87d17869a51a66d59eecf459d71cc0">dr_flush_region()</a>. Since that routine removes the calling block, we redirect execution to the target or fall-through address with <a class="el" href="dr__ir__utils_8h.html#86554ab412927d0a4f1b90d72f64a858">dr_redirect_execution()</a>. The file <a href="https://css.csail.mit.edu/6.858/2010/samples/cbr.c">../../samples/cbr.c</a> contains the full code for this sample.<h3><a class="anchor" name="sec_ex4">
Optimization</a></h3>
For the next example we consider a client application for a simple optimization. The optimizer replaces every increment/decrement operation with a corresponding add/subtract operation if running on a Pentium 4, where the add/subtract is less expensive. For optimizations, we are less concerned with covering all the code that is executed; on the contrary, in order to amortize the optimization overhead, we only want to apply the optimization to hot code. Thus, we apply the optimization at the trace level rather than the basic block level. Full code for this example is in the file <a href="https://css.csail.mit.edu/6.858/2010/samples/inc2add.c">../../samples/inc2add.c</a>.<h3><a class="anchor" name="sec_ex5">
Custom Tracing</a></h3>
This example demonstrates the custom tracing interface. It changes DynamoRIO's tracing behavior to favor making traces that start at a call and end right after a return. It demonstrates the use of both custom trace API elements :<p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> query_end_trace(<span class="keywordtype">void</span> *drcontext, <span class="keywordtype">void</span> *trace_tag, <span class="keywordtype">void</span> *next_tag);
<span class="keywordtype">bool</span> <a class="code" href="dr__tools_8h.html#9e262e93823dbc5914eca34540afbc07">dr_mark_trace_head</a>(<span class="keywordtype">void</span> *drcontext, <span class="keywordtype">void</span> *tag);
</pre></div><p>
Full code for this example is in the file <a href="https://css.csail.mit.edu/6.858/2010/samples/inline.c">../../samples/inline.c</a>.<h3><a class="anchor" name="sec_ex6">
Use of Floating Point Operation in a Client</a></h3>
Because saving the floating point state is very expensive, DynamoRIO seeks to do so on an as needed basis. If a client wishes to use floating point operations it must save and restore the application's floating point state around the usage. For an inserted clean call out of the code cache, this can be conveniently done using <a class="el" href="dr__ir__utils_8h.html#e7b7bd1e750b8a24ebf401fb6a6d6d5e">dr_insert_clean_call()</a> and passing true for the save_fpstate parameter. It can also be done explicitly using these routines:<p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> <a class="code" href="dr__proc_8h.html#4a11c9d5d127ce126562ad35b4d165dd">proc_save_fpstate</a>(byte *buf);
<span class="keywordtype">void</span> <a class="code" href="dr__proc_8h.html#23edceee5d1ae7c7d51a212432e6d644">proc_restore_fpstate</a>(byte *buf);
</pre></div><p>
These routines must be used if floating point operations are performed in non-inserted-call locations, such as event callbacks. Note that there are restrictions on how these methods may be called: see the documentation in the header files for additional information. Note also that the floating point state must be saved around calls to our provided printing routines when they are used to print floats. However, it is not necessary to save and restore the floating point state around floating point operations if they are being used in the initialization or termination routines.<p>
This example client counts the number of basic blocks processed and keeps statistics on their average size using floating point operations. Full code for this example is in the file <a href="https://css.csail.mit.edu/6.858/2010/samples/bbsize.c">../../samples/bbsize.c</a>.<h3><a class="anchor" name="sec_ex7">
Use of Custom Client Statistics with the Windows GUI</a></h3>
The new Windows GUI will display custom client statistics, if they are placed in shared memory with a certain name. The sample <a href="https://css.csail.mit.edu/6.858/2010/samples/stats.c">../../samples/stats.c</a> gives code for the protocol used in the form of a sample client that counts total instructions, floating-point instructions, and system calls.<h3><a class="anchor" name="sec_ex8">
Use of Standalone API</a></h3>
The binary tracedump reader also functions as an example of <a class="el" href="page_standalone.html">IA-32/AMD64 Disassembly Library</a> : <a href="https://css.csail.mit.edu/6.858/2010/samples/tracedump.c">../../samples/tracedump.c</a>.<h3><a class="anchor" name="sec_ex9">
Other examples</a></h3>
The sample <a href="https://css.csail.mit.edu/6.858/2010/samples/strace.c">../../samples/strace.c</a> displays how to use the system call events and API routines.<p>
The sample <a href="https://css.csail.mit.edu/6.858/2010/samples/signal.c">../../samples/signal.c</a> demonstrates how to use the signal event.<p>
The sample <a href="https://css.csail.mit.edu/6.858/2010/samples/prefetch.c">../../samples/prefetch.c</a> demonstrates modifying the dynamic code stream for compatibilty between different processor types.<p>
The sample <a href="https://css.csail.mit.edu/6.858/2010/samples/div.c">../../samples/div.c</a> demonstrates profiling the types of values fed to a particular opcode.<p>
The sample <a href="https://css.csail.mit.edu/6.858/2010/samples/empty.c">../../samples/empty.c</a> is provided as an example client that does nothing. </div>
<hr size="1"><address style="text-align: center;"><small>
<img border=0 src="favicon.png"> &nbsp; DynamoRIO API version 2.0.0 --- Thu Apr 22 00:18:19 2010 
&nbsp; <img border=0 src="favicon.png">
</body>
</html>
