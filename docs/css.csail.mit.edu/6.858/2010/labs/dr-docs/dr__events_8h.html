<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>DynamoRIO API: dr_events.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
<link rel="shortcut icon" type="image/x-icon" href="favicon.ico" />
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="contents">
<h1>dr_events.h File Reference</h1>Event callback registration routines.  
<a href="dr__events_8h.html#_details">More...</a>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__dr__fault__fragment__info__t.html">_dr_fault_fragment_info_t</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__dr__restore__state__info__t.html">_dr_restore_state_info_t</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__dr__exception__t.html">_dr_exception_t</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__dr__siginfo__t.html">_dr_siginfo_t</a></td></tr>

<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef struct <br class="typebreak">
<a class="el" href="struct__dr__fault__fragment__info__t.html">_dr_fault_fragment_info_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#ef4b133cb2bf598ee968170d982c4e62">dr_fault_fragment_info_t</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef struct <br class="typebreak">
<a class="el" href="struct__dr__restore__state__info__t.html">_dr_restore_state_info_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#19a4bd60d7607be81d77f466fd8d7f49">dr_restore_state_info_t</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef struct <a class="el" href="struct__dr__exception__t.html">_dr_exception_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#debe39e781c20b42f61c7d03ed560587">dr_exception_t</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef struct <a class="el" href="struct__dr__siginfo__t.html">_dr_siginfo_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#b49900139eb46d5dde3b2b69c175c072">dr_siginfo_t</a></td></tr>

<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#689518ac5d1ad136b13e03012702b209">dr_emit_flags_t</a> { <br>
&nbsp;&nbsp;<a class="el" href="dr__events_8h.html#689518ac5d1ad136b13e03012702b2097d25c4546544d1a8c0b77c69230772eb">DR_EMIT_DEFAULT</a> =  0, 
<br>
&nbsp;&nbsp;<a class="el" href="dr__events_8h.html#689518ac5d1ad136b13e03012702b20980b741b6a35dc7424940a873bfee2ced">DR_EMIT_STORE_TRANSLATIONS</a> =  0x01
<br>
 }</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#4982c54b45ecb525aec1be6b00a9664a">dr_custom_trace_action_t</a> </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#f86ce68b89c76d46c92d36e58ddb7a33">dr_signal_action_t</a> { <br>
&nbsp;&nbsp;<a class="el" href="dr__events_8h.html#f86ce68b89c76d46c92d36e58ddb7a3345815215e4567ecfbe504d5bb7ab01bf">DR_SIGNAL_DELIVER</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="dr__events_8h.html#f86ce68b89c76d46c92d36e58ddb7a33eb1a9eb7969b688a26e6e06fef4c6973">DR_SIGNAL_SUPPRESS</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="dr__events_8h.html#f86ce68b89c76d46c92d36e58ddb7a330c437214d4411687fe54ad8bb93399a1">DR_SIGNAL_BYPASS</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="dr__events_8h.html#f86ce68b89c76d46c92d36e58ddb7a33866dcc1af9f9076edcbed9c8afb17e93">DR_SIGNAL_REDIRECT</a>
<br>
 }</td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#985537df683007e1392e8a3b095ef363">dr_register_exit_event</a> (void(*func)(void))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#69823e6d3133bb7da291fbe1b1313f8c">dr_unregister_exit_event</a> (void(*func)(void))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#043a3588c4cf0c2d6838140fce530e72">dr_register_bb_event</a> (<a class="el" href="dr__events_8h.html#689518ac5d1ad136b13e03012702b209">dr_emit_flags_t</a>(*func)(void *drcontext, void *tag, instrlist_t *bb, bool for_trace, bool translating))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#c10e7ca1490fc450cab526c335693314">dr_unregister_bb_event</a> (<a class="el" href="dr__events_8h.html#689518ac5d1ad136b13e03012702b209">dr_emit_flags_t</a>(*func)(void *drcontext, void *tag, instrlist_t *bb, bool for_trace, bool translating))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#88a19a6822654caf18c017e145f48a57">dr_register_trace_event</a> (<a class="el" href="dr__events_8h.html#689518ac5d1ad136b13e03012702b209">dr_emit_flags_t</a>(*func)(void *drcontext, void *tag, instrlist_t *trace, bool translating))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#58a65167f2d758f179ddbf9deb7c381b">dr_unregister_trace_event</a> (<a class="el" href="dr__events_8h.html#689518ac5d1ad136b13e03012702b209">dr_emit_flags_t</a>(*func)(void *drcontext, void *tag, instrlist_t *trace, bool translating))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#753fffe98b1f5ec53555bdbe21645782">dr_register_end_trace_event</a> (<a class="el" href="dr__events_8h.html#4982c54b45ecb525aec1be6b00a9664a">dr_custom_trace_action_t</a>(*func)(void *drcontext, void *tag, void *next_tag))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#f65bd74863fdb3fe4306bfce41085e47">dr_unregister_end_trace_event</a> (<a class="el" href="dr__events_8h.html#4982c54b45ecb525aec1be6b00a9664a">dr_custom_trace_action_t</a>(*func)(void *drcontext, void *tag, void *next_tag))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#698501b03d64f07e1a32fc82c021b27a">dr_register_delete_event</a> (void(*func)(void *drcontext, void *tag))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#c1ece32fa94f968b82ec94cfb2237f42">dr_unregister_delete_event</a> (void(*func)(void *drcontext, void *tag))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#e7a179ac7a2d01157e1ab2852f50c902">dr_register_restore_state_event</a> (void(*func)(void *drcontext, void *tag, <a class="el" href="struct__dr__mcontext__t.html">dr_mcontext_t</a> *mcontext, bool restore_memory, bool app_code_consistent))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#f6f7e16b706395ed4047ed293b44dd55">dr_unregister_restore_state_event</a> (void(*func)(void *drcontext, void *tag, <a class="el" href="struct__dr__mcontext__t.html">dr_mcontext_t</a> *mcontext, bool restore_memory, bool app_code_consistent))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#000e59a3f500a2d4a1d0123ce6032f77">dr_register_restore_state_ex_event</a> (bool(*func)(void *drcontext, bool restore_memory, <a class="el" href="struct__dr__restore__state__info__t.html">dr_restore_state_info_t</a> *info))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#b69d9b422f6429e0e2b5ac01f030d2bf">dr_unregister_restore_state_ex_event</a> (bool(*func)(void *drcontext, bool restore_memory, <a class="el" href="struct__dr__restore__state__info__t.html">dr_restore_state_info_t</a> *info))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#878920c40c76e2c18043f9db772a24c0">dr_register_thread_init_event</a> (void(*func)(void *drcontext))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#ff5286475e21b7a5aaca3e084f8ad1ef">dr_unregister_thread_init_event</a> (void(*func)(void *drcontext))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#0b0c102bb9a99d67c3e62ea8b3790ff1">dr_register_thread_exit_event</a> (void(*func)(void *drcontext))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#c85b9e60aee5a1b51f102f99471ef4b3">dr_unregister_thread_exit_event</a> (void(*func)(void *drcontext))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#82afd28406cbf06396e1a17ab100c6ea">dr_register_fork_init_event</a> (void(*func)(void *drcontext))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#4b02bc04d51b3d58cd741653ef1a26ce">dr_unregister_fork_init_event</a> (void(*func)(void *drcontext))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#ca6b098123ef80cae05ce767a7dd9d98">dr_register_module_load_event</a> (void(*func)(void *drcontext, const <a class="el" href="struct__module__data__t.html">module_data_t</a> *info, bool loaded))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#bebbe6e0b3b09aa7fc8200f98fdcd9ed">dr_unregister_module_load_event</a> (void(*func)(void *drcontext, const <a class="el" href="struct__module__data__t.html">module_data_t</a> *info, bool loaded))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#2a40613f5e73d800acaeadd400bb1fab">dr_register_module_unload_event</a> (void(*func)(void *drcontext, const <a class="el" href="struct__module__data__t.html">module_data_t</a> *info))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#a50729c1507abb3cb56aa1759fcef782">dr_unregister_module_unload_event</a> (void(*func)(void *drcontext, const <a class="el" href="struct__module__data__t.html">module_data_t</a> *info))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#69adae9409a1871149da69e97747b84c">dr_register_exception_event</a> (bool(*func)(void *drcontext, <a class="el" href="struct__dr__exception__t.html">dr_exception_t</a> *excpt))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#58f9e43726286983fbc2098705e6511d">dr_unregister_exception_event</a> (bool(*func)(void *drcontext, <a class="el" href="struct__dr__exception__t.html">dr_exception_t</a> *excpt))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#7ec572232450344efcba8923cae71d51">dr_register_filter_syscall_event</a> (bool(*func)(void *drcontext, int sysnum))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#7971a22fd3ed5db49daeebb4a828b802">dr_unregister_filter_syscall_event</a> (bool(*func)(void *drcontext, int sysnum))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#a37d61a7f9dde4663b8dd4c3a44732f4">dr_register_pre_syscall_event</a> (bool(*func)(void *drcontext, int sysnum))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#35ce4aa4c919b8fb3cbda7df31a8efd5">dr_unregister_pre_syscall_event</a> (bool(*func)(void *drcontext, int sysnum))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#099441f8d147404355c66178e3b19f0f">dr_register_post_syscall_event</a> (void(*func)(void *drcontext, int sysnum))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#b1068388ccc574a34456940f20b4e832">dr_unregister_post_syscall_event</a> (void(*func)(void *drcontext, int sysnum))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#3ac512c0bd9feea08cb04dd923efb589">dr_register_signal_event</a> (<a class="el" href="dr__events_8h.html#f86ce68b89c76d46c92d36e58ddb7a33">dr_signal_action_t</a>(*func)(void *drcontext, <a class="el" href="struct__dr__siginfo__t.html">dr_siginfo_t</a> *siginfo))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#617160964e0d99807f40d06f2e627152">dr_unregister_signal_event</a> (<a class="el" href="dr__events_8h.html#f86ce68b89c76d46c92d36e58ddb7a33">dr_signal_action_t</a>(*func)(void *drcontext, <a class="el" href="struct__dr__siginfo__t.html">dr_siginfo_t</a> *siginfo))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#9037603d0bd5bfca4198011adb8d10eb">dr_register_nudge_event</a> (void(*func)(void *drcontext, uint64 argument), <a class="el" href="dr__defines_8h.html#68540a70b4f8150a4fe6dcec91bf8825">client_id_t</a> id)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#bb75728570a2dd0f91493c1b857db525">dr_unregister_nudge_event</a> (void(*func)(void *drcontext, uint64 argument), <a class="el" href="dr__defines_8h.html#68540a70b4f8150a4fe6dcec91bf8825">client_id_t</a> id)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#9d11fb8fbffdcb0cb6e7b87f804cb459">dr_nudge_client</a> (<a class="el" href="dr__defines_8h.html#68540a70b4f8150a4fe6dcec91bf8825">client_id_t</a> id, uint64 argument)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Event callback registration routines. 
<p>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="debe39e781c20b42f61c7d03ed560587"></a><!-- doxytag: member="dr_events.h::dr_exception_t" ref="debe39e781c20b42f61c7d03ed560587" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__dr__exception__t.html">_dr_exception_t</a>  <a class="el" href="struct__dr__exception__t.html">dr_exception_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Data structure passed with an exception event. Contains the machine context and the Win32 exception record. 
</div>
</div><p>
<a class="anchor" name="ef4b133cb2bf598ee968170d982c4e62"></a><!-- doxytag: member="dr_events.h::dr_fault_fragment_info_t" ref="ef4b133cb2bf598ee968170d982c4e62" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__dr__fault__fragment__info__t.html">_dr_fault_fragment_info_t</a>  <a class="el" href="struct__dr__fault__fragment__info__t.html">dr_fault_fragment_info_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Data structure passed within dr_exception_t, dr_siginfo_t, and dr_restore_state_info_t. Contains information about the code fragment inside the code cache at the exception/signal/translation interruption point. 
</div>
</div><p>
<a class="anchor" name="19a4bd60d7607be81d77f466fd8d7f49"></a><!-- doxytag: member="dr_events.h::dr_restore_state_info_t" ref="19a4bd60d7607be81d77f466fd8d7f49" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__dr__restore__state__info__t.html">_dr_restore_state_info_t</a>  <a class="el" href="struct__dr__restore__state__info__t.html">dr_restore_state_info_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Data structure passed to a restore_state_ex event handler (see <a class="el" href="dr__events_8h.html#000e59a3f500a2d4a1d0123ce6032f77">dr_register_restore_state_ex_event()</a>). Contains the machine context at the translation point and other translation information. 
</div>
</div><p>
<a class="anchor" name="b49900139eb46d5dde3b2b69c175c072"></a><!-- doxytag: member="dr_events.h::dr_siginfo_t" ref="b49900139eb46d5dde3b2b69c175c072" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__dr__siginfo__t.html">_dr_siginfo_t</a>  <a class="el" href="struct__dr__siginfo__t.html">dr_siginfo_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Data structure passed with a signal event. Contains the machine context at the signal interruption point and other signal information. 
</div>
</div><p>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="4982c54b45ecb525aec1be6b00a9664a"></a><!-- doxytag: member="dr_events.h::dr_custom_trace_action_t" ref="4982c54b45ecb525aec1be6b00a9664a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="dr__events_8h.html#4982c54b45ecb525aec1be6b00a9664a">dr_custom_trace_action_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
DR will call the end trace event if it is registered prior to adding each basic block to a trace being generated. The return value of the event callback should be from the dr_custom_trace_action_t enum.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>DR treats CUSTOM_TRACE_CONTINUE as an advisement only. Certain fragments are not suitable to be included in a trace and if DR runs into one it will end the trace regardless of what the client returns through the event callback. </dd></dl>

</div>
</div><p>
<a class="anchor" name="689518ac5d1ad136b13e03012702b209"></a><!-- doxytag: member="dr_events.h::dr_emit_flags_t" ref="689518ac5d1ad136b13e03012702b209" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="dr__events_8h.html#689518ac5d1ad136b13e03012702b209">dr_emit_flags_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Flags controlling the behavior of basic blocks and traces when emitted into the code cache. For multiple clients, the flags returned by each client are or-ed together. <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="689518ac5d1ad136b13e03012702b2097d25c4546544d1a8c0b77c69230772eb"></a><!-- doxytag: member="DR_EMIT_DEFAULT" ref="689518ac5d1ad136b13e03012702b2097d25c4546544d1a8c0b77c69230772eb" args="" -->DR_EMIT_DEFAULT</em>&nbsp;</td><td>
Emit as normal. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="689518ac5d1ad136b13e03012702b20980b741b6a35dc7424940a873bfee2ced"></a><!-- doxytag: member="DR_EMIT_STORE_TRANSLATIONS" ref="689518ac5d1ad136b13e03012702b20980b741b6a35dc7424940a873bfee2ced" args="" -->DR_EMIT_STORE_TRANSLATIONS</em>&nbsp;</td><td>
Store translation information at emit time rather than calling the basic block or trace event later to recreate the information. Note that even if a standalone basic block has stored translations, if when it is added to a trace it does not request storage (and the trace callback also does not request storage) then the basic block callback may still be called to translate for the trace.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="dr__events_8h.html#043a3588c4cf0c2d6838140fce530e72">dr_register_bb_event()</a> </dd></dl>
</td></tr>
</table>
</dl>

</div>
</div><p>
<a class="anchor" name="f86ce68b89c76d46c92d36e58ddb7a33"></a><!-- doxytag: member="dr_events.h::dr_signal_action_t" ref="f86ce68b89c76d46c92d36e58ddb7a33" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="dr__events_8h.html#f86ce68b89c76d46c92d36e58ddb7a33">dr_signal_action_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return value of client signal event callback, determining how DR will proceed with the signal. <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="f86ce68b89c76d46c92d36e58ddb7a3345815215e4567ecfbe504d5bb7ab01bf"></a><!-- doxytag: member="DR_SIGNAL_DELIVER" ref="f86ce68b89c76d46c92d36e58ddb7a3345815215e4567ecfbe504d5bb7ab01bf" args="" -->DR_SIGNAL_DELIVER</em>&nbsp;</td><td>
Deliver signal to the application as normal. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="f86ce68b89c76d46c92d36e58ddb7a33eb1a9eb7969b688a26e6e06fef4c6973"></a><!-- doxytag: member="DR_SIGNAL_SUPPRESS" ref="f86ce68b89c76d46c92d36e58ddb7a33eb1a9eb7969b688a26e6e06fef4c6973" args="" -->DR_SIGNAL_SUPPRESS</em>&nbsp;</td><td>
Suppress signal as though it never happened. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="f86ce68b89c76d46c92d36e58ddb7a330c437214d4411687fe54ad8bb93399a1"></a><!-- doxytag: member="DR_SIGNAL_BYPASS" ref="f86ce68b89c76d46c92d36e58ddb7a330c437214d4411687fe54ad8bb93399a1" args="" -->DR_SIGNAL_BYPASS</em>&nbsp;</td><td>
Deliver signal according to the default SIG_DFL action, as would happen if the application had no handler. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="f86ce68b89c76d46c92d36e58ddb7a33866dcc1af9f9076edcbed9c8afb17e93"></a><!-- doxytag: member="DR_SIGNAL_REDIRECT" ref="f86ce68b89c76d46c92d36e58ddb7a33866dcc1af9f9076edcbed9c8afb17e93" args="" -->DR_SIGNAL_REDIRECT</em>&nbsp;</td><td>
Do not deliver the signal. Instead, redirect control to the application state specified in <a class="el" href="struct__dr__siginfo__t.html#8acd8739ada44ea401e0a82926136a0e">dr_siginfo_t.mcontext</a>. </td></tr>
</table>
</dl>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="9d11fb8fbffdcb0cb6e7b87f804cb459"></a><!-- doxytag: member="dr_events.h::dr_nudge_client" ref="9d11fb8fbffdcb0cb6e7b87f804cb459" args="(client_id_t id, uint64 argument)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_nudge_client           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#68540a70b4f8150a4fe6dcec91bf8825">client_id_t</a>&nbsp;</td>
          <td class="paramname"> <em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64&nbsp;</td>
          <td class="paramname"> <em>argument</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Triggers an asynchronous nudge event in the current process. The callback function registered with <a class="el" href="dr__events_8h.html#9037603d0bd5bfca4198011adb8d10eb">dr_register_nudge_event()</a> will be called with the supplied <code>argument</code> (in a new non-application thread on Windows).<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>On Linux, the nudge will not be delivered until this thread exits the code cache. Thus, if this routine is called from a clean call, <a class="el" href="dr__ir__utils_8h.html#86554ab412927d0a4f1b90d72f64a858">dr_redirect_execution()</a> should be used to ensure cache exit.<p>
Not yet supported for 32-bit processes running on 64-bit Windows (WOW64). </dd></dl>

</div>
</div><p>
<a class="anchor" name="043a3588c4cf0c2d6838140fce530e72"></a><!-- doxytag: member="dr_events.h::dr_register_bb_event" ref="043a3588c4cf0c2d6838140fce530e72" args="(dr_emit_flags_t(*func)(void *drcontext, void *tag, instrlist_t *bb, bool for_trace, bool translating))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_register_bb_event           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__events_8h.html#689518ac5d1ad136b13e03012702b209">dr_emit_flags_t</a>(*)(void *drcontext, void *tag, instrlist_t *bb, bool for_trace, bool translating)&nbsp;</td>
          <td class="paramname"> <em>func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Registers a callback function for the basic block event. DR calls <code>func</code> before inserting a new basic block into the code cache. When adding a basic block to a new trace, DR calls <code>func</code> again with <code>for_trace</code> set to true, giving the client the opportunity to keep its same instrumentation in the trace, or to change it. The original basic block's instrumentation is unchanged by whatever action is taken in the <code>for_trace</code> call.<p>
DR may call <code>func</code> again if it needs to translate from code cache addresses back to application addresses, which happens on faulting instructions as well as in certain situations involving suspended threads or forcibly relocated threads. The <code>translating</code> parameter distinguishes the two types of calls and is further explained below.<p>
<ul>
<li><code>drcontext</code> is a pointer to the input program's machine context. Clients should not inspect or modify the context; it is provided as an opaque pointer (i.e., <code>void *</code>) to be passed to API routines that require access to this internal data. drcontext is specific to the current thread, but in normal configurations the basic block being created is thread-shared: thus, when allocating data structures with the same lifetime as the basic block, usually global heap (<a class="el" href="dr__tools_8h.html#60faa40f7e8c819c34fd25cb367c5473">dr_global_alloc()</a>) is a better choice than heap tied to the thread that happened to first create the basic block (<a class="el" href="dr__tools_8h.html#4274226adda06339e247e4a311abdd9b">dr_thread_alloc()</a>). Thread-private heap is fine for temporary structures such as <a class="el" href="structinstr__t.html">instr_t</a> and instrlist_t.</li></ul>
<p>
<ul>
<li><code>tag</code> is a unique identifier for the basic block fragment. Use <a class="el" href="dr__tools_8h.html#724aa7f7e87a604071fffa0a01925bf0">dr_fragment_app_pc()</a> to translate it to an application address.</li><li><code>bb</code> is a pointer to the list of instructions that comprise the basic block. Clients can examine, manipulate, or completely replace the instructions in the list.</li></ul>
<p>
<ul>
<li><code>translating</code> indicates whether this callback is for basic block creation (false) or is for address translation (true). This is further explained below.</li></ul>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a <a class="el" href="dr__events_8h.html#689518ac5d1ad136b13e03012702b209">dr_emit_flags_t</a> flag.</dd></dl>
The user is free to inspect and modify the block before it executes, but must adhere to the following restrictions:<ul>
<li>If there is more than one non-meta branch, only the last can be conditional.</li><li>A non-meta conditional branch or direct call must be the final instruction in the block.</li><li>There can only be one indirect branch (call, jump, or return) in a basic block, and it must be the final instruction in the block.</li><li>The exit control-flow of a block ending in a system call or int instruction cannot be changed, nor can instructions be inserted after the system call or int instruction itself, unless the system call or int instruction is removed entirely.</li><li>The number of an interrupt cannot be changed. (Note that the parameter to a system call, normally kept in the eax register, can be freely changed in a basic block: but not in a trace.)</li><li>A system call or interrupt instruction can only be added if it satisfies the above constraints: i.e., if it is the final instruction in the block and the only system call or interrupt.</li><li>The block's application source code (as indicated by the translation targets, set by <a class="el" href="dr__ir__instr_8h.html#f1beda2d570ba04d74ca9cbd7c31bb1d">instr_set_translation()</a>) must remain within the original bounds of the block (the one exception to this is that a jump can translate to its target). Otherwise, DR's cache consistency algorithms cannot guarantee to properly invalidate the block if the source application code is modified. To send control to other application code regions, truncate the block and use a direct jump to target the desired address, which will then materialize in the subsequent block, rather than embedding the desired instructions in this block.</li><li>There is a limit on the size of a basic block in the code cache. DR performs its own modifications, especially on memory writes for cache consistency of self-modifying (or false sharing) code regions. If an assert fires in debug build indicating a limit was reached, either truncate blocks or use the -max_bb_instrs runtime option to ask DR to make them smaller.</li></ul>
<p>
To support transparent fault handling, DR must translate a fault in the code cache into a fault at the corresponding application address. DR must also be able to translate when a suspended thread is examined by the application or by DR itself for internal synchronization purposes. If the client is only adding observational instrumentation (i.e., meta instructions: see <a class="el" href="dr__ir__instr_8h.html#2335bd8d05936e8308506ef11f1be401">instr_set_ok_to_mangle()</a>) (which should not fault) and is not modifying, reordering, or removing application instructions, these details can be ignored. In that case the client should return <a class="el" href="dr__events_8h.html#689518ac5d1ad136b13e03012702b2097d25c4546544d1a8c0b77c69230772eb">DR_EMIT_DEFAULT</a> and set up its basic block callback to be deterministic and idempotent. If the client is performing modifications, then in order for DR to properly translate a code cache address the client must use <a class="el" href="dr__ir__instr_8h.html#f1beda2d570ba04d74ca9cbd7c31bb1d">instr_set_translation()</a> in the basic block creation callback to set the corresponding application address (the address that should be presented to the application as the faulting address, or the address that should be restarted after a suspend) for each modified instruction and each added non-meta instruction (see <a class="el" href="dr__ir__instr_8h.html#2335bd8d05936e8308506ef11f1be401">instr_set_ok_to_mangle()</a>).<p>
There are two methods for using the translated addresses:<p>
<ol type=1>
<li>Return <a class="el" href="dr__events_8h.html#689518ac5d1ad136b13e03012702b20980b741b6a35dc7424940a873bfee2ced">DR_EMIT_STORE_TRANSLATIONS</a> from the basic block creation callback. DR will then store the translation addresses and use the stored information on a fault. The basic block callback for <code>tag</code> will not be called with <code>translating</code> set to true. Note that unless <a class="el" href="dr__events_8h.html#689518ac5d1ad136b13e03012702b20980b741b6a35dc7424940a873bfee2ced">DR_EMIT_STORE_TRANSLATIONS</a> is also returned for <code>for_trace</code> calls (or <a class="el" href="dr__events_8h.html#689518ac5d1ad136b13e03012702b20980b741b6a35dc7424940a873bfee2ced">DR_EMIT_STORE_TRANSLATIONS</a> is returned in the trace callback), each constituent block comprising the trace will need to be re-created with both <code>for_trace</code> and <code>translating</code> set to true. Storing translations uses additional memory that can be significant: up to 20% in some cases, as it prevents DR from using its simple data structures and forces it to fall back to its complex, corner-case design. This is why DR does not store all translations by default.</li><li>Return <a class="el" href="dr__events_8h.html#689518ac5d1ad136b13e03012702b2097d25c4546544d1a8c0b77c69230772eb">DR_EMIT_DEFAULT</a> from the basic block creation callback. DR will then call the callback again during fault translation with <code>translating</code> set to true. All modifications to <code>bb</code> that were performed on the creation callback must be repeated on the translating callback. This option is only possible when basic block modifications are deterministic and idempotent, but it saves memory. Naturally, global state changes triggered by block creation should be wrapped in checks for <code>translating</code> being false. Even in this case, <a class="el" href="dr__ir__instr_8h.html#f1beda2d570ba04d74ca9cbd7c31bb1d">instr_set_translation()</a> should be called for non-meta instructions even when <code>translating</code> is false, as DR may decide to store the translations at creation time for reasons of its own.</li></ol>
<p>
Furthermore, if the client's modifications change any part of the machine state besides the program counter, the client should use <a class="el" href="dr__events_8h.html#e7a179ac7a2d01157e1ab2852f50c902">dr_register_restore_state_event()</a> or <a class="el" href="dr__events_8h.html#000e59a3f500a2d4a1d0123ce6032f77">dr_register_restore_state_ex_event()</a> to restore the registers and application memory to their original application values.<p>
For meta instructions that do not reference application memory (i.e., they should not fault), leave the translation field as NULL. A NULL value instructs DR to use the subsequent non-meta instruction's translation as the application address, and to fail when translating the full state. Since the full state will only be needed when relocating a thread (as stated, there will not be a fault here), failure indicates that this is not a valid relocation point, and DR's thread synchronization scheme will use another spot. If the translation field is set to a non-NULL value, the client should be willing to also restore the rest of the machine state at that point (restore spilled registers, etc.) via <a class="el" href="dr__events_8h.html#e7a179ac7a2d01157e1ab2852f50c902">dr_register_restore_state_event()</a> or <a class="el" href="dr__events_8h.html#000e59a3f500a2d4a1d0123ce6032f77">dr_register_restore_state_ex_event()</a>. This is necessary for meta instructions that reference application memory. DR takes care of such potentially-faulting instructions added by its own API routines (<a class="el" href="dr__ir__utils_8h.html#e7b7bd1e750b8a24ebf401fb6a6d6d5e">dr_insert_clean_call()</a> arguments that reference application data, <a class="el" href="dr__ir__utils_8h.html#919e2106df67eaaa5bc6c49d736543b5">dr_insert_mbr_instrumentation()</a>'s read of application indirect branch data, etc.)<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>In order to present a more straightforward code stream to clients, this release of DR disables several internal optimizations. As a result, some applications may see a performance degradation. Applications making heavy use of system calls are the most likely to be affected. Future releases may allow clients some control over performance versus visibility.<p>
If multiple clients are present, the instruction list for a basic block passed to earlier-registered clients will contain the instrumentation and modifications put in place by later-registered clients.<p>
Basic blocks can be deleted due to hitting capacity limits or cache consistency events (when the source application code of a basic block is modified). In that case, the client will see a new basic block callback if the block is then executed again after deletion. The deletion event (<a class="el" href="dr__events_8h.html#698501b03d64f07e1a32fc82c021b27a">dr_register_delete_event()</a>) will be raised at deletion time.<p>
If the -thread_private runtime option is specified, clients should expect to see duplicate tags for separate threads, albeit with different dcrcontext values. Additionally, DR employs a cache-sizing algorithm for thread private operation that proactively deletes fragments. Even with thread-shared caches enabled, however, certain situations cause DR to emit thread-private basic blocks (e.g., self-modifying code). In this case, clients should be prepared to see duplicate tags without an intermediate deletion. </dd></dl>

</div>
</div><p>
<a class="anchor" name="698501b03d64f07e1a32fc82c021b27a"></a><!-- doxytag: member="dr_events.h::dr_register_delete_event" ref="698501b03d64f07e1a32fc82c021b27a" args="(void(*func)(void *drcontext, void *tag))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_register_delete_event           </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext, void *tag)&nbsp;</td>
          <td class="paramname"> <em>func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Registers a callback function for the fragment deletion event. DR calls <code>func</code> whenever it removes a fragment from the code cache. Due to DR's high-performance non-precise flushing, a fragment can be made inaccessible but not actually freed for some time. A new fragment can thus be created before the deletion event for the old fragment is raised. We recommended using a counter to ignore subsequent deletion events when using per-fragment data structures and duplicate fragments are seen.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>drcontext may be NULL when thread-shared fragments are being deleted during process exit. For this reason, thread-private heap should not be used for data structures intended to be freed at thread-shared fragment deletion. </dd></dl>

</div>
</div><p>
<a class="anchor" name="753fffe98b1f5ec53555bdbe21645782"></a><!-- doxytag: member="dr_events.h::dr_register_end_trace_event" ref="753fffe98b1f5ec53555bdbe21645782" args="(dr_custom_trace_action_t(*func)(void *drcontext, void *tag, void *next_tag))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_register_end_trace_event           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__events_8h.html#4982c54b45ecb525aec1be6b00a9664a">dr_custom_trace_action_t</a>(*)(void *drcontext, void *tag, void *next_tag)&nbsp;</td>
          <td class="paramname"> <em>func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Registers a callback function for the end-trace event. DR calls <code>func</code> before extending a trace with a new basic block. The <code>func</code> should return one of the <a class="el" href="dr__events_8h.html#4982c54b45ecb525aec1be6b00a9664a">dr_custom_trace_action_t</a> enum values. 
</div>
</div><p>
<a class="anchor" name="69adae9409a1871149da69e97747b84c"></a><!-- doxytag: member="dr_events.h::dr_register_exception_event" ref="69adae9409a1871149da69e97747b84c" args="(bool(*func)(void *drcontext, dr_exception_t *excpt))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_register_exception_event           </td>
          <td>(</td>
          <td class="paramtype">bool(*)(void *drcontext, <a class="el" href="struct__dr__exception__t.html">dr_exception_t</a> *excpt)&nbsp;</td>
          <td class="paramname"> <em>func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Registers a callback function for the exception event. DR calls <code>func</code> whenever the application throws an exception. If <code>func</code> returns true, the exception is delivered to the application's handler along with any changes made to <code>excpt-&gt;mcontext</code>. If <code>func</code> returns false, the faulting instruction in the code cache is re-executed using <code>excpt-&gt;raw_mcontext</code>, including any changes made to that structure. Clients are expected to use <code>excpt-&gt;raw_mcontext</code> when using faults as a mechanism to push rare cases out of an instrumentation fastpath that need to examine instrumentation instructions rather than the translated application state and should normally not examine it for application instruction faults. Certain registers may not contain proper application values in <code>excpt-&gt;raw_mcontext</code> for exceptions in application instructions. Clients are cautioned against relying on any details of code cache layout or register usage beyond instrumentation inserted by the client itself when examining <code>excpt-&gt;raw_mcontext</code>.<p>
DR raises this event for exceptions outside the code cache that could come from code generated by a client. For such exceptions, mcontext is not translated and is identical to raw_mcontext.<p>
To skip the passing of the exception to the application's exception handlers and to send control elsewhere instead, a client can call <a class="el" href="dr__ir__utils_8h.html#86554ab412927d0a4f1b90d72f64a858">dr_redirect_execution()</a> from <code>func</code>.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd><code>excpt-&gt;fault_fragment_info</code> data is provided with <code>excpt-&gt;raw_mcontext</code>. It is valid only if <code>excpt-&gt;fault_fragment_info.cache_start_pc</code> is not <code>NULL</code>. It provides clients information about the code fragment being executed at the exception interruption point. Clients are cautioned against relying on any details of code cache layout or register usage beyond instrumentation inserted by the client itself. <p>
Only valid on Windows. <p>
The function is not called for RaiseException. </dd></dl>

</div>
</div><p>
<a class="anchor" name="985537df683007e1392e8a3b095ef363"></a><!-- doxytag: member="dr_events.h::dr_register_exit_event" ref="985537df683007e1392e8a3b095ef363" args="(void(*func)(void))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_register_exit_event           </td>
          <td>(</td>
          <td class="paramtype">void(*)(void)&nbsp;</td>
          <td class="paramname"> <em>func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Registers a callback function for the process exit event. DR calls <code>func</code> when the process exits. Note that in release build it is possible for other threads to still be executing, so synchronization should be used for global variables; alternatively, the -synch_at_exit option can be set, or the <a class="el" href="dr__tools_8h.html#902bfca468a7a2cc3dbc45b4bd127444">dr_request_synchronized_exit()</a> routine invoked, to guarantee that only one thread is active at exit time (at a potential performance cost).<p>
On Linux, SYS_execve does NOT result in an exit event, but it WILL result in the client library being reloaded and its <a class="el" href="dr__api_8h.html#20a4dc9da7f6bb9121e30bb3570c6961">dr_init()</a> routine being called. 
</div>
</div><p>
<a class="anchor" name="7ec572232450344efcba8923cae71d51"></a><!-- doxytag: member="dr_events.h::dr_register_filter_syscall_event" ref="7ec572232450344efcba8923cae71d51" args="(bool(*func)(void *drcontext, int sysnum))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_register_filter_syscall_event           </td>
          <td>(</td>
          <td class="paramtype">bool(*)(void *drcontext, int sysnum)&nbsp;</td>
          <td class="paramname"> <em>func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Registers a callback function for the syscall filter event. DR calls <code>func</code> to decide whether to invoke the syscall events for each system call site encountered with a statically-determinable system call number. If <code>func</code> returns true, the pre-syscall (<a class="el" href="dr__events_8h.html#a37d61a7f9dde4663b8dd4c3a44732f4">dr_register_pre_syscall_event()</a>) and post-syscall (<a class="el" href="dr__events_8h.html#099441f8d147404355c66178e3b19f0f">dr_register_post_syscall_event()</a>) events will be invoked. Otherwise, the events may or may not occur, depending on whether DR itself needs to intercept them and whether the system call number is statically determinable. System call number determination can depend on whether the -opt_speed option is enabled. If a system call number is not determinable, the filter event will not be called, but the pre and post events will be called.<p>
Intercepting every system call can be detrimental to performance for certain types of applications. Filtering provides for greater performance by letting uninteresting system calls execute without interception overhead. 
</div>
</div><p>
<a class="anchor" name="82afd28406cbf06396e1a17ab100c6ea"></a><!-- doxytag: member="dr_events.h::dr_register_fork_init_event" ref="82afd28406cbf06396e1a17ab100c6ea" args="(void(*func)(void *drcontext))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_register_fork_init_event           </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext)&nbsp;</td>
          <td class="paramname"> <em>func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Registers a callback function for the fork event. DR calls <code>func</code> whenever the application forks a new process. <dl class="note" compact><dt><b>Note:</b></dt><dd>Valid on Linux only. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ca6b098123ef80cae05ce767a7dd9d98"></a><!-- doxytag: member="dr_events.h::dr_register_module_load_event" ref="ca6b098123ef80cae05ce767a7dd9d98" args="(void(*func)(void *drcontext, const module_data_t *info, bool loaded))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_register_module_load_event           </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext, const <a class="el" href="struct__module__data__t.html">module_data_t</a> *info, bool loaded)&nbsp;</td>
          <td class="paramname"> <em>func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Registers a callback function for the module load event. DR calls <code>func</code> whenever the application loads a module. The <code>loaded</code> parameter indicates whether the module is about to be loaded (the normal case) or is already loaded (if the module was already there at the time DR initialized). <dl class="note" compact><dt><b>Note:</b></dt><dd>The client should be aware that if the module is being loaded it may not be fully processed by the loader (relocating, rebinding and on Linux segment remapping may have not yet occurred). <p>
The module_data_t <code>*info</code> passed to the callback routine is valid only for the duration of the callback and should not be freed; a persistent copy can be made with <a class="el" href="dr__tools_8h.html#8c99a2d79ed312cd852d57e975601adc">dr_copy_module_data()</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2a40613f5e73d800acaeadd400bb1fab"></a><!-- doxytag: member="dr_events.h::dr_register_module_unload_event" ref="2a40613f5e73d800acaeadd400bb1fab" args="(void(*func)(void *drcontext, const module_data_t *info))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_register_module_unload_event           </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext, const <a class="el" href="struct__module__data__t.html">module_data_t</a> *info)&nbsp;</td>
          <td class="paramname"> <em>func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Registers a callback function for the module unload event. DR calls <code>func</code> whenever the application unloads a module. <dl class="note" compact><dt><b>Note:</b></dt><dd>The module_data_t <code>*info</code> passed to the callback routine is valid only for the duration of the callback and should not be freed; a persistent copy can be made with <a class="el" href="dr__tools_8h.html#8c99a2d79ed312cd852d57e975601adc">dr_copy_module_data()</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9037603d0bd5bfca4198011adb8d10eb"></a><!-- doxytag: member="dr_events.h::dr_register_nudge_event" ref="9037603d0bd5bfca4198011adb8d10eb" args="(void(*func)(void *drcontext, uint64 argument), client_id_t id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_register_nudge_event           </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext, uint64 argument)&nbsp;</td>
          <td class="paramname"> <em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#68540a70b4f8150a4fe6dcec91bf8825">client_id_t</a>&nbsp;</td>
          <td class="paramname"> <em>id</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Registers a callback function for nudge events. External entities can nudge a process through the <a class="el" href="dr__config_8h.html#cbe479389db99b03fd1af89271b22efc">dr_nudge_process()</a> API routine on Windows or using the <code>nudgeunix</code> tool on Linux. DR then calls <code>func</code> whenever the current process receives the nudge. On Windows, the nudge event is delivered in a new non-application thread. Callers must specify the target client by passing the client ID that was provided in <a class="el" href="dr__api_8h.html#20a4dc9da7f6bb9121e30bb3570c6961">dr_init()</a>. 
</div>
</div><p>
<a class="anchor" name="099441f8d147404355c66178e3b19f0f"></a><!-- doxytag: member="dr_events.h::dr_register_post_syscall_event" ref="099441f8d147404355c66178e3b19f0f" args="(void(*func)(void *drcontext, int sysnum))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_register_post_syscall_event           </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext, int sysnum)&nbsp;</td>
          <td class="paramname"> <em>func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Registers a callback function for the post-syscall event. DR calls <code>func</code> whenever the application just finished invoking a system call, if any client asked for that system call number to be intercepted via the filter event (<a class="el" href="dr__events_8h.html#7ec572232450344efcba8923cae71d51">dr_register_filter_syscall_event()</a>) or if DR itself needs to intercept the system call. The result of the system call can be modified with <a class="el" href="dr__tools_8h.html#601cd2b724ac627aef0756a4c4eee637">dr_syscall_set_result()</a>.<p>
System calls that change control flow or terminate the current thread or process typically do not have a post-syscall event. These include SYS_exit, SYS_exit_group, SYS_execve, SYS_sigreturn, and SYS_rt_sigreturn on Linux, and NtTerminateThread, NtTerminateProcess (depending on the parameters), NtCallbackReturn, and NtContinue on Windows.<p>
The application's machine state can be accessed and set with <a class="el" href="dr__ir__utils_8h.html#d78c531d7527907652e770960c07af38">dr_get_mcontext()</a> and <a class="el" href="dr__ir__utils_8h.html#ed77cd48eccfdd8eaf8c33bd6b53d8b2">dr_set_mcontext()</a>.<p>
Additional system calls may be invoked by calling <a class="el" href="dr__tools_8h.html#76797a9310bf67ebeb820d80e11764b8">dr_syscall_invoke_another()</a> prior to returning from the post-syscall event callback. The system call to be invoked should be specified with <a class="el" href="dr__tools_8h.html#bc80dfdf8bff3c3feb486aacd69aba7c">dr_syscall_set_sysnum()</a>, and its parameters can be set with <a class="el" href="dr__tools_8h.html#c21a83f1812443112303ef3ea8b76de2">dr_syscall_set_param()</a>. 
</div>
</div><p>
<a class="anchor" name="a37d61a7f9dde4663b8dd4c3a44732f4"></a><!-- doxytag: member="dr_events.h::dr_register_pre_syscall_event" ref="a37d61a7f9dde4663b8dd4c3a44732f4" args="(bool(*func)(void *drcontext, int sysnum))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_register_pre_syscall_event           </td>
          <td>(</td>
          <td class="paramtype">bool(*)(void *drcontext, int sysnum)&nbsp;</td>
          <td class="paramname"> <em>func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Registers a callback function for the pre-syscall event. DR calls <code>func</code> whenever the application is about to invoke a system call, if any client asked for that system call number to be intercepted via the filter event (<a class="el" href="dr__events_8h.html#7ec572232450344efcba8923cae71d51">dr_register_filter_syscall_event()</a>).<p>
The application parameters to the system call can be viewed with <a class="el" href="dr__tools_8h.html#1e01fe123ecc9908ada9c9fccbf3f6ab">dr_syscall_get_param()</a> and set with <a class="el" href="dr__tools_8h.html#c21a83f1812443112303ef3ea8b76de2">dr_syscall_set_param()</a>. The system call number can also be changed with <a class="el" href="dr__tools_8h.html#bc80dfdf8bff3c3feb486aacd69aba7c">dr_syscall_set_sysnum()</a>.<p>
The application's machine state can be accessed and set with <a class="el" href="dr__ir__utils_8h.html#d78c531d7527907652e770960c07af38">dr_get_mcontext()</a> and <a class="el" href="dr__ir__utils_8h.html#ed77cd48eccfdd8eaf8c33bd6b53d8b2">dr_set_mcontext()</a>. Changing registers in this way overlaps with system call parameter changes on some platforms. On Linux, for SYS_clone, client changes to the ebp/rbp register will be ignored by the clone child.<p>
If <code>func</code> returns true, the application's system call is invoked normally; if <code>func</code> returns false, the system call is skipped. If it is skipped, the return value can be set with <a class="el" href="dr__tools_8h.html#601cd2b724ac627aef0756a4c4eee637">dr_syscall_set_result()</a>. If the system call is skipped, there will not be a post-syscall event. 
</div>
</div><p>
<a class="anchor" name="e7a179ac7a2d01157e1ab2852f50c902"></a><!-- doxytag: member="dr_events.h::dr_register_restore_state_event" ref="e7a179ac7a2d01157e1ab2852f50c902" args="(void(*func)(void *drcontext, void *tag, dr_mcontext_t *mcontext, bool restore_memory, bool app_code_consistent))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_register_restore_state_event           </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext, void *tag, <a class="el" href="struct__dr__mcontext__t.html">dr_mcontext_t</a> *mcontext, bool restore_memory, bool app_code_consistent)&nbsp;</td>
          <td class="paramname"> <em>func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Registers a callback function for the machine state restoration event. DR calls <code>func</code> whenever it needs to translate a code cache machine context from the code cache to its corresponding original application context. DR needs to translate when instructions fault in the cache as well as when a suspended thread is examined or relocated for internal purposes.<p>
If a client is only adding instrumentation (meta-code: see <a class="el" href="dr__ir__instr_8h.html#7b0251c70b4ab2a46801eeb49f1b8fda">instr_ok_to_mangle()</a>) that does not reference application memory, and is not reordering or removing application instructions, then it need not register for this event. If, however, a client is modifying application code or is adding code that can fault, the client must be capable of restoring the original context.<p>
When DR needs to translate a code cache context, DR recreates the faulting instruction's containing fragment, storing translation information along the way, by calling the basic block and/or trace event callbacks with the <code>translating</code> parameter set to true. DR uses the recreated code to identify the application instruction (<code>mcontext.pc</code>) corresponding to the faulting code cache instruction. If the client asked to store translation information by returning <a class="el" href="dr__events_8h.html#689518ac5d1ad136b13e03012702b20980b741b6a35dc7424940a873bfee2ced">DR_EMIT_STORE_TRANSLATIONS</a> from the basic block or trace event callback, then this step of re-calling the event callback is skipped and the stored value is used as the application address (<code>mcontext.pc</code>).<p>
DR then calls the fault state restoration event to allow the client to restore the registers and application memory to their proper values as they would have appeared if the original application code had been executed up to the <code>mcontext.pc</code> instruction. Memory should only be restored if the <code>restore_memory</code> parameter is true; if it is false, DR may only be querying for the address (<code>mcontext.pc</code>) or register state and may not relocate this thread.<p>
The <code>app_code_consistent</code> parameter indicates whether the original application code containing the instruction being translated is guaranteed to still be in the same state it was when the code was placed in the code cache. This guarantee varies depending on the type of cache consistency being used by DR.<p>
The client can update <code>mcontext.pc</code> in this callback.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The passed-in <code>drcontext</code> may correspond to a different thread than the thread executing the callback. Do not assume that the executing thread is the target thread. </dd></dl>

</div>
</div><p>
<a class="anchor" name="000e59a3f500a2d4a1d0123ce6032f77"></a><!-- doxytag: member="dr_events.h::dr_register_restore_state_ex_event" ref="000e59a3f500a2d4a1d0123ce6032f77" args="(bool(*func)(void *drcontext, bool restore_memory, dr_restore_state_info_t *info))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_register_restore_state_ex_event           </td>
          <td>(</td>
          <td class="paramtype">bool(*)(void *drcontext, bool restore_memory, <a class="el" href="struct__dr__restore__state__info__t.html">dr_restore_state_info_t</a> *info)&nbsp;</td>
          <td class="paramname"> <em>func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Registers a callback function for the machine state restoration event with extended information.<p>
This event is identical to that for <a class="el" href="dr__events_8h.html#e7a179ac7a2d01157e1ab2852f50c902">dr_register_restore_state_event()</a> with the following exceptions:<p>
<ul>
<li>Additional information is provided in the dr_restore_state_info_t structure, including the pre-translation context (containing the address inside the code cache of the translation point) and the starting address of the containing fragment in the code cache. Certain registers may not contain proper application values in <code>info-&gt;raw_mcontext</code>. Clients are cautioned against relying on any details of code cache layout or register usage beyond instrumentation inserted by the client itself when examining <code>info-&gt;raw_mcontext</code>.</li></ul>
<p>
<ul>
<li>The callback function returns a boolean indicating the success of the translation. When DR is translating not for a fault but for thread relocation, the <code>restore_memory</code> parameter will be false. Such translation can target a meta-instruction that can fault (see <a class="el" href="dr__ir__instr_8h.html#94227a193446d370f0180e6a844be0c2">instr_set_meta_may_fault()</a>). For that scenario, a client can choose not to translate. Such instructions do not always require full translation for faults, and allowing translation failure removes the requirement that a client must translate at all such instructions. Note, however, that returning false can cause performance degradation as DR must then resume the thread and attempt to re-suspend it at a safer spot. Clients must return true for translation points in application code in order to avoid catastropic failure to suspend, and should thus identify whether translation points are inside their own instrumentation before returning false. Translation for relocation will never occur in meta instructions, so clients only need to look for meta-may-fault instructions. Clients should never return false when <code>restore_memory</code> is true. </li></ul>

</div>
</div><p>
<a class="anchor" name="3ac512c0bd9feea08cb04dd923efb589"></a><!-- doxytag: member="dr_events.h::dr_register_signal_event" ref="3ac512c0bd9feea08cb04dd923efb589" args="(dr_signal_action_t(*func)(void *drcontext, dr_siginfo_t *siginfo))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_register_signal_event           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__events_8h.html#f86ce68b89c76d46c92d36e58ddb7a33">dr_signal_action_t</a>(*)(void *drcontext, <a class="el" href="struct__dr__siginfo__t.html">dr_siginfo_t</a> *siginfo)&nbsp;</td>
          <td class="paramname"> <em>func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Requests that DR call the provided callback function <code>func</code> whenever a signal is received by any application thread. The return value of <code>func</code> determines whether DR delivers the signal to the application. To redirect execution return DR_SIGNAL_REDIRECT (do not call <a class="el" href="dr__ir__utils_8h.html#86554ab412927d0a4f1b90d72f64a858">dr_redirect_execution()</a> from a signal callback). The callback function will be called even if the application has no handler or has registered a SIG_IGN or SIG_DFL handler.<p>
Modifications to the fields of <code>siginfo-&gt;mcontext</code> will be propagated to the application if it has a handler for the signal, if DR_SIGNAL_DELIVER is returned.<p>
The <code>siginfo-&gt;raw_mcontext</code> data is only provided for non-delayable signals (e.g., SIGSEGV) that must be delivered immediately. Whether it is supplied is specified in <code>siginfo-&gt;raw_mcontext_valid</code>. It is intended for clients using faults as a mechanism to push rare cases out of an instrumentation fastpath that need to examine instrumentation instructions rather than the translated application state. Certain registers may not contain proper application values in <code>excpt-&gt;raw_mcontext</code> for exceptions in application instructions. Clients are cautioned against relying on any details of code cache layout or register usage beyond instrumentation inserted by the client itself. If DR_SIGNAL_SUPPRESS is returned, <code>siginfo-&gt;mcontext</code> is ignored and <code>siginfo-&gt;raw_mcontext</code> is used as the resumption context. The client's changes to <code>siginfo-&gt;raw_mcontext</code> will take effect.<p>
For a delayable signal, DR raises a signal event only when about to deliver the signal to the application. Thus, if the application has blocked a delayable signal, the corresponding signal event will not occur until the application unblocks the signal, even if such a signal is delivered by the kernel. For non-delayable signals, DR will raise a signal event on initial receipt of the signal, with the <code>siginfo-&gt;blocked</code> field set. Such a blocked signal will have a second event raised when it is delivered to the application (if it is not suppressed by the client, and if there is not already a pending blocked signal, for non-real-time signals).<p>
DR raises this event for faults outside the code cache that could come from code generated by a client. For such cases, mcontext is not translated and is identical to raw_mcontext.<p>
DR will not raise a signal event for a SIGSEGV or SIGBUS raised by a client code fault rather than the application. Use <a class="el" href="dr__tools_8h.html#6a94558696130c76f34dcdac0ce50c47">dr_safe_read()</a> or <a class="el" href="dr__tools_8h.html#b94f47b693cc7dd9eecba07d8cfd1bc8">dr_safe_write()</a> to prevent such faults.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd><code>siginfo-&gt;fault_fragment_info</code> data is provided with <code>siginfo-&gt;raw_mcontext</code>. It is valid only if <code>siginfo-&gt;fault_fragment_info.cache_start_pc</code> is not <code>NULL</code>. It provides clients information about the code fragment being executed at the signal interruption point. Clients are cautioned against relying on any details of code cache layout or register usage beyond instrumentation inserted by the client itself.<p>
Only valid on Linux.<p>
DR always requests SA_SIGINFO for all signals.<p>
This version of DR does not intercept the signals SIGCONT, SIGSTOP, SIGTSTP, SIGTTIN, or SIGTTOU. Future versions should add support for these signals.<p>
If the client uses signals for its own communication it should set a flag to distinguish its own uses of signals from the application's use. Races where the two are re-ordered should not be problematic. </dd></dl>

</div>
</div><p>
<a class="anchor" name="0b0c102bb9a99d67c3e62ea8b3790ff1"></a><!-- doxytag: member="dr_events.h::dr_register_thread_exit_event" ref="0b0c102bb9a99d67c3e62ea8b3790ff1" args="(void(*func)(void *drcontext))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_register_thread_exit_event           </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext)&nbsp;</td>
          <td class="paramname"> <em>func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Registers a callback function for the thread exit event. DR calls <code>func</code> whenever an application thread exits.<p>
There are some potential races at process exit time with the thread exit event for all remaining threads. In debug builds, DynamoRIO synchronizes with all remaining threads at process exit time, guaranteeing that no other threads are executing when the thread exit events are raised. In release build, however, for performance reasons, while DynamoRIO attempts to prevent other threads from executing (and thus running instrumentation code or raising events) beyond when their own thread exit events are raised, no guarantee is provided. The <code>-synch_at_exit</code> option can be turned on in order to provide such a guarantee, at a potential performance hit. 
</div>
</div><p>
<a class="anchor" name="878920c40c76e2c18043f9db772a24c0"></a><!-- doxytag: member="dr_events.h::dr_register_thread_init_event" ref="878920c40c76e2c18043f9db772a24c0" args="(void(*func)(void *drcontext))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_register_thread_init_event           </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext)&nbsp;</td>
          <td class="paramname"> <em>func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Registers a callback function for the thread initialization event. DR calls <code>func</code> whenever the application creates a new thread. 
</div>
</div><p>
<a class="anchor" name="88a19a6822654caf18c017e145f48a57"></a><!-- doxytag: member="dr_events.h::dr_register_trace_event" ref="88a19a6822654caf18c017e145f48a57" args="(dr_emit_flags_t(*func)(void *drcontext, void *tag, instrlist_t *trace, bool translating))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_register_trace_event           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__events_8h.html#689518ac5d1ad136b13e03012702b209">dr_emit_flags_t</a>(*)(void *drcontext, void *tag, instrlist_t *trace, bool translating)&nbsp;</td>
          <td class="paramname"> <em>func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Registers a callback function for the trace event. DR calls <code>func</code> before inserting a new trace into the code cache. DR may call <code>func</code> again if it needs to translate from code cache addresses back to application addresses, which happens on faulting instructions as well as in certain situations involving suspended threads or forcibly relocated threads. The <code>translating</code> parameter distinguishes the two types of calls and behaves identically to the same parameter in the basic block callback: see <a class="el" href="dr__events_8h.html#043a3588c4cf0c2d6838140fce530e72">dr_register_bb_event()</a> for further details.<p>
Traces are not built if the -disable_traces runtime option is specified.<p>
<ul>
<li><code>drcontext</code> is a pointer to the input program's machine context. Clients should not inspect or modify the context; it is provided as an opaque pointer (i.e., <code>void *</code>) to be passed to API routines that require access to this internal data.</li><li><code>tag</code> is a unique identifier for the trace fragment.</li><li><code>trace</code> is a pointer to the list of instructions that comprise the trace.</li><li><code>translating</code> indicates whether this callback is for trace creation (false) or is for fault address recreation (true). This is further explained below.</li></ul>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a <a class="el" href="dr__events_8h.html#689518ac5d1ad136b13e03012702b209">dr_emit_flags_t</a> flag.</dd></dl>
The user is free to inspect and modify the trace before it executes, with certain restrictions on introducing control-flow that include those for basic blocks (see <a class="el" href="dr__events_8h.html#043a3588c4cf0c2d6838140fce530e72">dr_register_bb_event()</a>). Additional restrictions unique to traces also apply:<ul>
<li>Only one non-meta direct branch that targets the subsequent block in the trace can be present in each block.</li><li>Each block must end with a non-meta control transfer.</li><li>The parameter to a system call, normally kept in the eax register, cannot be changed.</li><li>A system call or interrupt instruction cannot be added.</li></ul>
<p>
If hitting a size limit due to extensive instrumentation, reduce the -max_trace_bbs option to start with a smaller trace.<p>
The basic block restrictions on modifying application source code apply to traces as well. If the user wishes to change which basic blocks comprise the trace, either the <a class="el" href="dr__events_8h.html#753fffe98b1f5ec53555bdbe21645782">dr_register_end_trace_event()</a> should be used or the <code>for_trace</code> basic block callbacks should modify their continuation addresses via direct jumps.<p>
All of the comments for <a class="el" href="dr__events_8h.html#043a3588c4cf0c2d6838140fce530e72">dr_register_bb_event()</a> regarding transparent fault handling and state translation apply to the trace callback as well. Please read those comments carefully.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>As each basic block is added to a new trace, the basic block callback (see <a class="el" href="dr__events_8h.html#043a3588c4cf0c2d6838140fce530e72">dr_register_bb_event()</a>) is called with its <code>for_trace</code> parameter set to true. In order to preserve basic block instrumentation inside of traces, a client need only act identically with respect to the <code>for_trace</code> parameter; it can ignore the trace event if its goal is to place instrumentation on all code.<p>
Certain control flow modifications applied to a basic block can prevent it from becoming part of a trace: e.g., adding additional non-meta control transfers.<p>
If multiple clients are present, the instruction list for a trace passed to earlier-registered clients will contain the instrumentation and modifications put in place by later-registered clients; similarly for each constituent basic block.<p>
Traces can be deleted due to hitting capacity limits or cache consistency events (when the source application code of a trace is modified). In that case, the client will see a new trace callback if a new trace containing that code is created again after deletion. The deletion event (<a class="el" href="dr__events_8h.html#698501b03d64f07e1a32fc82c021b27a">dr_register_delete_event()</a>) will be raised at deletion time. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c10e7ca1490fc450cab526c335693314"></a><!-- doxytag: member="dr_events.h::dr_unregister_bb_event" ref="c10e7ca1490fc450cab526c335693314" args="(dr_emit_flags_t(*func)(void *drcontext, void *tag, instrlist_t *bb, bool for_trace, bool translating))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_unregister_bb_event           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__events_8h.html#689518ac5d1ad136b13e03012702b209">dr_emit_flags_t</a>(*)(void *drcontext, void *tag, instrlist_t *bb, bool for_trace, bool translating)&nbsp;</td>
          <td class="paramname"> <em>func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unregister a callback function for the basic block event. <dl class="return" compact><dt><b>Returns:</b></dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered).</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>We do not recommend unregistering for the basic block event unless it aways returned <a class="el" href="dr__events_8h.html#689518ac5d1ad136b13e03012702b20980b741b6a35dc7424940a873bfee2ced">DR_EMIT_STORE_TRANSLATIONS</a> (including when <code>for_trace</code> is true, or if the client has a trace creation callback that returns <a class="el" href="dr__events_8h.html#689518ac5d1ad136b13e03012702b20980b741b6a35dc7424940a873bfee2ced">DR_EMIT_STORE_TRANSLATIONS</a>). Unregistering can prevent proper state translation on a later fault or other translation event for this basic block or for a trace that includes this basic block. Instead of unregistering, turn the event callback into a nop. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c1ece32fa94f968b82ec94cfb2237f42"></a><!-- doxytag: member="dr_events.h::dr_unregister_delete_event" ref="c1ece32fa94f968b82ec94cfb2237f42" args="(void(*func)(void *drcontext, void *tag))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_unregister_delete_event           </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext, void *tag)&nbsp;</td>
          <td class="paramname"> <em>func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unregister a callback function for the fragment deletion event. <dl class="return" compact><dt><b>Returns:</b></dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered). </dd></dl>

</div>
</div><p>
<a class="anchor" name="f65bd74863fdb3fe4306bfce41085e47"></a><!-- doxytag: member="dr_events.h::dr_unregister_end_trace_event" ref="f65bd74863fdb3fe4306bfce41085e47" args="(dr_custom_trace_action_t(*func)(void *drcontext, void *tag, void *next_tag))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_unregister_end_trace_event           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__events_8h.html#4982c54b45ecb525aec1be6b00a9664a">dr_custom_trace_action_t</a>(*)(void *drcontext, void *tag, void *next_tag)&nbsp;</td>
          <td class="paramname"> <em>func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unregister a callback function for the end-trace event. <dl class="return" compact><dt><b>Returns:</b></dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered). </dd></dl>

</div>
</div><p>
<a class="anchor" name="58f9e43726286983fbc2098705e6511d"></a><!-- doxytag: member="dr_events.h::dr_unregister_exception_event" ref="58f9e43726286983fbc2098705e6511d" args="(bool(*func)(void *drcontext, dr_exception_t *excpt))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_unregister_exception_event           </td>
          <td>(</td>
          <td class="paramtype">bool(*)(void *drcontext, <a class="el" href="struct__dr__exception__t.html">dr_exception_t</a> *excpt)&nbsp;</td>
          <td class="paramname"> <em>func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unregister a callback function for the exception event. <dl class="return" compact><dt><b>Returns:</b></dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered). </dd></dl>

</div>
</div><p>
<a class="anchor" name="69823e6d3133bb7da291fbe1b1313f8c"></a><!-- doxytag: member="dr_events.h::dr_unregister_exit_event" ref="69823e6d3133bb7da291fbe1b1313f8c" args="(void(*func)(void))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_unregister_exit_event           </td>
          <td>(</td>
          <td class="paramtype">void(*)(void)&nbsp;</td>
          <td class="paramname"> <em>func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unregister a callback function for the process exit event. <dl class="return" compact><dt><b>Returns:</b></dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered). </dd></dl>

</div>
</div><p>
<a class="anchor" name="7971a22fd3ed5db49daeebb4a828b802"></a><!-- doxytag: member="dr_events.h::dr_unregister_filter_syscall_event" ref="7971a22fd3ed5db49daeebb4a828b802" args="(bool(*func)(void *drcontext, int sysnum))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_unregister_filter_syscall_event           </td>
          <td>(</td>
          <td class="paramtype">bool(*)(void *drcontext, int sysnum)&nbsp;</td>
          <td class="paramname"> <em>func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unregister a callback function for the syscall filter event. <dl class="return" compact><dt><b>Returns:</b></dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered). </dd></dl>

</div>
</div><p>
<a class="anchor" name="4b02bc04d51b3d58cd741653ef1a26ce"></a><!-- doxytag: member="dr_events.h::dr_unregister_fork_init_event" ref="4b02bc04d51b3d58cd741653ef1a26ce" args="(void(*func)(void *drcontext))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_unregister_fork_init_event           </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext)&nbsp;</td>
          <td class="paramname"> <em>func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unregister a callback function for the fork event. <dl class="return" compact><dt><b>Returns:</b></dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered). </dd></dl>

</div>
</div><p>
<a class="anchor" name="bebbe6e0b3b09aa7fc8200f98fdcd9ed"></a><!-- doxytag: member="dr_events.h::dr_unregister_module_load_event" ref="bebbe6e0b3b09aa7fc8200f98fdcd9ed" args="(void(*func)(void *drcontext, const module_data_t *info, bool loaded))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_unregister_module_load_event           </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext, const <a class="el" href="struct__module__data__t.html">module_data_t</a> *info, bool loaded)&nbsp;</td>
          <td class="paramname"> <em>func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unregister a callback for the module load event. <dl class="return" compact><dt><b>Returns:</b></dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered). </dd></dl>

</div>
</div><p>
<a class="anchor" name="a50729c1507abb3cb56aa1759fcef782"></a><!-- doxytag: member="dr_events.h::dr_unregister_module_unload_event" ref="a50729c1507abb3cb56aa1759fcef782" args="(void(*func)(void *drcontext, const module_data_t *info))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_unregister_module_unload_event           </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext, const <a class="el" href="struct__module__data__t.html">module_data_t</a> *info)&nbsp;</td>
          <td class="paramname"> <em>func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unregister a callback function for the module unload event. <dl class="return" compact><dt><b>Returns:</b></dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered). </dd></dl>

</div>
</div><p>
<a class="anchor" name="bb75728570a2dd0f91493c1b857db525"></a><!-- doxytag: member="dr_events.h::dr_unregister_nudge_event" ref="bb75728570a2dd0f91493c1b857db525" args="(void(*func)(void *drcontext, uint64 argument), client_id_t id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_unregister_nudge_event           </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext, uint64 argument)&nbsp;</td>
          <td class="paramname"> <em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#68540a70b4f8150a4fe6dcec91bf8825">client_id_t</a>&nbsp;</td>
          <td class="paramname"> <em>id</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unregister a callback function for the nudge event. <dl class="return" compact><dt><b>Returns:</b></dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered). </dd></dl>

</div>
</div><p>
<a class="anchor" name="b1068388ccc574a34456940f20b4e832"></a><!-- doxytag: member="dr_events.h::dr_unregister_post_syscall_event" ref="b1068388ccc574a34456940f20b4e832" args="(void(*func)(void *drcontext, int sysnum))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_unregister_post_syscall_event           </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext, int sysnum)&nbsp;</td>
          <td class="paramname"> <em>func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unregister a callback function for the post-syscall event. <dl class="return" compact><dt><b>Returns:</b></dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered). </dd></dl>

</div>
</div><p>
<a class="anchor" name="35ce4aa4c919b8fb3cbda7df31a8efd5"></a><!-- doxytag: member="dr_events.h::dr_unregister_pre_syscall_event" ref="35ce4aa4c919b8fb3cbda7df31a8efd5" args="(bool(*func)(void *drcontext, int sysnum))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_unregister_pre_syscall_event           </td>
          <td>(</td>
          <td class="paramtype">bool(*)(void *drcontext, int sysnum)&nbsp;</td>
          <td class="paramname"> <em>func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unregister a callback function for the pre-syscall event. <dl class="return" compact><dt><b>Returns:</b></dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered). </dd></dl>

</div>
</div><p>
<a class="anchor" name="f6f7e16b706395ed4047ed293b44dd55"></a><!-- doxytag: member="dr_events.h::dr_unregister_restore_state_event" ref="f6f7e16b706395ed4047ed293b44dd55" args="(void(*func)(void *drcontext, void *tag, dr_mcontext_t *mcontext, bool restore_memory, bool app_code_consistent))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_unregister_restore_state_event           </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext, void *tag, <a class="el" href="struct__dr__mcontext__t.html">dr_mcontext_t</a> *mcontext, bool restore_memory, bool app_code_consistent)&nbsp;</td>
          <td class="paramname"> <em>func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unregister a callback function for the machine state restoration event. <dl class="return" compact><dt><b>Returns:</b></dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered). </dd></dl>

</div>
</div><p>
<a class="anchor" name="b69d9b422f6429e0e2b5ac01f030d2bf"></a><!-- doxytag: member="dr_events.h::dr_unregister_restore_state_ex_event" ref="b69d9b422f6429e0e2b5ac01f030d2bf" args="(bool(*func)(void *drcontext, bool restore_memory, dr_restore_state_info_t *info))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_unregister_restore_state_ex_event           </td>
          <td>(</td>
          <td class="paramtype">bool(*)(void *drcontext, bool restore_memory, <a class="el" href="struct__dr__restore__state__info__t.html">dr_restore_state_info_t</a> *info)&nbsp;</td>
          <td class="paramname"> <em>func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unregister a callback function for the machine state restoration event with extended ifnormation. <dl class="return" compact><dt><b>Returns:</b></dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered). </dd></dl>

</div>
</div><p>
<a class="anchor" name="617160964e0d99807f40d06f2e627152"></a><!-- doxytag: member="dr_events.h::dr_unregister_signal_event" ref="617160964e0d99807f40d06f2e627152" args="(dr_signal_action_t(*func)(void *drcontext, dr_siginfo_t *siginfo))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_unregister_signal_event           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__events_8h.html#f86ce68b89c76d46c92d36e58ddb7a33">dr_signal_action_t</a>(*)(void *drcontext, <a class="el" href="struct__dr__siginfo__t.html">dr_siginfo_t</a> *siginfo)&nbsp;</td>
          <td class="paramname"> <em>func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unregister a callback function for the signal event. <dl class="return" compact><dt><b>Returns:</b></dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered). </dd></dl>

</div>
</div><p>
<a class="anchor" name="c85b9e60aee5a1b51f102f99471ef4b3"></a><!-- doxytag: member="dr_events.h::dr_unregister_thread_exit_event" ref="c85b9e60aee5a1b51f102f99471ef4b3" args="(void(*func)(void *drcontext))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_unregister_thread_exit_event           </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext)&nbsp;</td>
          <td class="paramname"> <em>func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unregister a callback function for the thread exit event. <dl class="return" compact><dt><b>Returns:</b></dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered). </dd></dl>

</div>
</div><p>
<a class="anchor" name="ff5286475e21b7a5aaca3e084f8ad1ef"></a><!-- doxytag: member="dr_events.h::dr_unregister_thread_init_event" ref="ff5286475e21b7a5aaca3e084f8ad1ef" args="(void(*func)(void *drcontext))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_unregister_thread_init_event           </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext)&nbsp;</td>
          <td class="paramname"> <em>func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unregister a callback function for the thread initialization event. <dl class="return" compact><dt><b>Returns:</b></dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered). </dd></dl>

</div>
</div><p>
<a class="anchor" name="58a65167f2d758f179ddbf9deb7c381b"></a><!-- doxytag: member="dr_events.h::dr_unregister_trace_event" ref="58a65167f2d758f179ddbf9deb7c381b" args="(dr_emit_flags_t(*func)(void *drcontext, void *tag, instrlist_t *trace, bool translating))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_unregister_trace_event           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__events_8h.html#689518ac5d1ad136b13e03012702b209">dr_emit_flags_t</a>(*)(void *drcontext, void *tag, instrlist_t *trace, bool translating)&nbsp;</td>
          <td class="paramname"> <em>func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unregister a callback function for the trace event. <dl class="return" compact><dt><b>Returns:</b></dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered).</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>We do not recommend unregistering for the trace event unless it always returned <a class="el" href="dr__events_8h.html#689518ac5d1ad136b13e03012702b20980b741b6a35dc7424940a873bfee2ced">DR_EMIT_STORE_TRANSLATIONS</a>, as doing so can prevent proper state translation on a later fault or other translation event. Instead of unregistering, turn the event callback into a nop. </dd></dl>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: center;"><small>
<img border=0 src="favicon.png"> &nbsp; DynamoRIO API version 2.0.0 --- Thu Apr 22 00:18:17 2010 
&nbsp; <img border=0 src="favicon.png">
</body>
</html>
